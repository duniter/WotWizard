(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1Sentries;
	
	

	IMPORT
		
		A := UtilAvlTree, B := Duniter1Blockchain, BA := Duniter1Basic, Math, TextMappers, TextModels, TextViews, J := UtilJson;
	
	TYPE
		
		Action = POINTER TO RECORD (B.Action)
			output: BA.String;
		END;
		
		Uid = POINTER TO RECORD (A.Elem)
			uid: B.String;
		END;
	
	PROCEDURE (i1: Uid) Compare (i2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH i2: Uid DO
				RETURN BA.CompP(i1.uid, i2.uid);
			END;
		END Compare;
	
	PROCEDURE List (): J.Json;
		
		VAR
			
			ok, b: BOOLEAN;
			pubkey: B.Pubkey;
			n: INTEGER;
			ids: A.Tree;
			id: Uid;
			e: A.Elem;
			mt: LONGINT;
		
		BEGIN (*List*)
			J.StartObject;
			J.PushInteger(ENTIER(Math.Ceiling(Math.Power(B.IdLen(), 1 / B.pars.stepMax))));
			J.BuildField("threshold");
			A.New(ids);
			ok := B.NextSentry(TRUE, pubkey);
			WHILE ok DO
				NEW(id);
				b := B.IdPub(pubkey, id.uid); ASSERT(b, 100);
				e := id;
				b := ids.SearchIns(e, n); ASSERT(~ b, 101);
				ok := B.NextSentry(FALSE, pubkey);
			END;
			J.StartArray;
			e := ids.Next(NIL);
			WHILE e # NIL DO
				J.StartObject;
				J.PushString(e(Uid).uid);
				J.BuildField("name");
				J.BuildObject;
				e := ids.Next(e);
			END;
			J.BuildArray;
			J.BuildField("sentries");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			RETURN J.GetJson();
		END List;
	
	PROCEDURE Json (j: J.Json; IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Json*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			j.Write(f);
			BA.VRegister(TextViews.dir.New(t), BA.waitLoc, name$, 100, "Sentries.Json");
		END Json;
	
	PROCEDURE (a: Action) Activate;
		
		BEGIN (*Activate*)
			Json(List(), a.output);
		END Activate;
	
	PROCEDURE Do* (IN output: ARRAY OF CHAR);
		
		VAR
			
			a: Action;
		
		BEGIN (*Do*)
			NEW(a);
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END Do;
	
	END Duniter1Sentries.
