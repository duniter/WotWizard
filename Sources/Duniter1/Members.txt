(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1Members;
	
	

	IMPORT
		
		(*
		L := StdLog,
		*)
		
		A := UtilAvlTree, B := Duniter1Blockchain, BA := Duniter1Basic, U := HermesUtil, O := HermesOperations, Strings, TextMappers, TextModels, TextViews, J := UtilJson;
	
	CONST
		
		countA = 0;
		countFA = 1;
		countFPMA = 2;
		firstEntriesA = 3;
		fEFluxA = 4;
		fEFluxPerMemberA = 5;
		lossA = 6;
		lossFluxA = 7;
		lossFluxPMA = 8;
	
	TYPE
		
		Action = POINTER TO RECORD (B.Action)
			what: INTEGER;
			output: BA.String;
			timeUnit: LONGINT;
		END;
		
		Event = POINTER TO RECORD (A.Elem)
			date: LONGINT;
			number: INTEGER;
		END;
		
		Events* = POINTER TO ARRAY OF RECORD
			date-: LONGINT;
			number-: INTEGER;
		END;
		
		EventsR* = POINTER TO ARRAY OF RECORD
			date-: LONGINT;
			number-: REAL;
		END;
	
	VAR
		
		globalEvents-: POINTER TO RECORD
			events-: Events;
		END;
		
		globalEventsR-: POINTER TO RECORD
			eventsR-: EventsR;
		END;
	
	PROCEDURE (ev1: Event) Compare (ev2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH ev2: Event DO
				IF ev1.date < ev2.date THEN
					RETURN A.lt;
				END;
				IF ev1.date > ev2.date THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE DoCount (OUT counts: Events; json: BOOLEAN; OUT j: J.Json);
		
		(* Number of members, event by event *)
		
		VAR
			
			ok, ok2, b: BOOLEAN;
			pk: B.Pubkey;
			jb, lb, n: INTEGER;
			mT, time, list: LONGINT;
			t: A.Tree;
			ev: Event;
			e: A.Elem;
			mt: LONGINT;
		
		BEGIN (*DoCount*)
			A.New(t);
			ok := B.JLNextPubkey(TRUE, pk);
			WHILE ok DO
				ok2 := B.JLPub(pk, list) & B.JLPubLNext(list, jb, lb);
				WHILE ok2 DO
					b := B.TimeOf(jb, mT, time); ASSERT(b, 100);
					NEW(ev); e := ev;
					ev.date := time; ev.number := 0;
					b := t.SearchIns(e, n);
					INC(e(Event).number);
					IF lb # B.hasNotLeaved THEN
						b := B.TimeOf(lb, mT, time); ASSERT(b, 101);
						NEW(ev); e := ev;
						ev.date := time; ev.number := 0;
						b := t.SearchIns(e, n);
						DEC(e(Event).number);
					END;
					ok2 := B.JLPubLNext(list, jb, lb);
				END;
				ok := B.JLNextPubkey(FALSE, pk);
			END;
			n := t.NumberOfElems();
			IF n = 0 THEN
				counts := NIL;
			ELSE
				NEW(counts, t.NumberOfElems());
				n := 0;
				e := t.Next(NIL);
				WHILE e # NIL DO
					WITH e: Event DO
						counts[n].date := e.date;
						counts[n].number := e.number;
					END;
					INC(n);
					e := t.Next(e);
				END;
				FOR n := 1 TO LEN(counts) - 1 DO
					INC(counts[n].number, counts[n - 1].number);
				END;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEvents);
			globalEvents.events := counts;
			j := J.BuildJsonFrom(globalEvents);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoCount;
	
	PROCEDURE DoCountFlux (timeUnit: LONGINT; OUT countsR: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of members, event by event *)
		
		CONST
			
			pointsNb = 80;
			degree = 2;
			
		VAR
			
			counts: Events;
			dots, dotsD: U.Dots;
			i, oldPointsNb, oldDegree: INTEGER;
			b: BOOLEAN;
			mt: LONGINT;
		
		BEGIN (*DoCountFlux*)
			DoCount(counts, FALSE, j);
			IF counts = NIL THEN
				countsR := NIL;
				j := NIL;
				RETURN;
			END;
			NEW(dots, LEN(counts));
			FOR i := 0 TO LEN(counts) - 1 DO
				dots[i].x := counts[i].date / timeUnit;
				dots[i].y := counts[i].number;
			END;
			O.GetDeriveOptions(oldPointsNb, oldDegree);
			O.SetDeriveOptions(pointsNb, degree);
			b := O.Derive(dots, dotsD);
			O.SetDeriveOptions(oldPointsNb, oldDegree);
			NEW(countsR, LEN(counts));
			FOR i := 0 TO LEN(counts) - 1 DO
				countsR[i].date := counts[i].date;
				countsR[i].number := dotsD[i].y;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := countsR;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoCountFlux;
	
	PROCEDURE DoCountFluxPerMember (timeUnit: LONGINT; OUT countsR: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of first entries per member, event by event *)
		
		VAR
			
			counts: Events;
			c: INTEGER;
			mt: LONGINT;
		
		BEGIN (*DoCountFluxPerMember*)
			DoCountFlux(timeUnit, countsR, FALSE, j);
			DoCount(counts, FALSE, j);
			IF countsR = NIL THEN
				j := NIL;
				RETURN;
			END;
			FOR c := 0 TO LEN(countsR) - 1 DO
				countsR[c].number := countsR[c].number / counts[c].number;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := countsR;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoCountFluxPerMember;
	
	PROCEDURE DoFirstEntries (OUT fE: Events; json: BOOLEAN; OUT j: J.Json);
		
		(* Number of first entries, event by event *)
		
		VAR
			
			ok, ok2, b: BOOLEAN;
			pk: B.Pubkey;
			jb, jb0, lb, n: INTEGER;
			mT, time, list: LONGINT;
			t: A.Tree;
			ev: Event;
			e: A.Elem;
			mt: LONGINT;
		
		BEGIN (*DoFirstEntries*)
			A.New(t);
			ok := B.JLNextPubkey(TRUE, pk);
			WHILE ok DO
				ok2 := B.JLPub(pk, list) & B.JLPubLNext(list, jb, lb);
				WHILE ok2 DO
					jb0 := jb;
					ok2 := B.JLPubLNext(list, jb, lb);
				END;
				b := B.TimeOf(jb0, mT, time); ASSERT(b, 102);
				NEW(ev); e := ev;
				ev.date := time; ev.number := 0;
				b := t.SearchIns(e, n);
				INC(e(Event).number);
				ok := B.JLNextPubkey(FALSE, pk);
			END;
			NEW(fE, t.NumberOfElems());
			n := 0;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: Event DO
					fE[n].date := e.date;
					fE[n].number := e.number;
				END;
				INC(n);
				e := t.Next(e);
			END;
			FOR n := 1 TO LEN(fE) - 1 DO
				INC(fE[n].number, fE[n - 1].number);
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEvents);
			globalEvents.events := fE;
			j := J.BuildJsonFrom(globalEvents);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoFirstEntries;
	
	PROCEDURE DoFEFlux (timeUnit: LONGINT; OUT fER: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of first entries, event by event *)
		
		CONST
			
			pointsNb = 80;
			degree = 2;
			
		VAR
			
			fE: Events;
			dots, dotsD: U.Dots;
			i, oldPointsNb, oldDegree: INTEGER;
			b: BOOLEAN;
			mt: LONGINT;
		
		BEGIN (*DoFEFlux*)
			DoFirstEntries(fE, FALSE, j);
			IF fE = NIL THEN
				fER := NIL;
				j := NIL;
				RETURN;
			END;
			NEW(dots, LEN(fE));
			FOR i := 0 TO LEN(fE) - 1 DO
				dots[i].x := fE[i].date / timeUnit;
				dots[i].y := fE[i].number;
			END;
			O.GetDeriveOptions(oldPointsNb, oldDegree);
			O.SetDeriveOptions(pointsNb, degree);
			b := O.Derive(dots, dotsD);
			O.SetDeriveOptions(oldPointsNb, oldDegree);
			NEW(fER, LEN(fE));
			FOR i := 0 TO LEN(fE) - 1 DO
				fER[i].date := fE[i].date;
				fER[i].number := dotsD[i].y;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := fER;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoFEFlux;
	
	PROCEDURE DoFEFluxPerMember (timeUnit: LONGINT; OUT fER: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of first entries per member, event by event *)
		
		VAR
			
			counts: Events;
			c, f: INTEGER;
			mt: LONGINT;
		
		BEGIN (*DoFEFluxPerMember*)
			DoFEFlux(timeUnit, fER, FALSE, j);
			DoCount(counts, FALSE, j);
			IF fER = NIL THEN
				j := NIL;
				RETURN;
			END;
			c := 0;
			FOR f := 0 TO LEN(fER) - 1 DO
				WHILE (c < LEN(counts) - 1) & (counts[c + 1].date <= fER[f].date) DO
					INC(c);
				END;
				fER[f].number := fER[f].number / counts[c].number;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := fER;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoFEFluxPerMember;
	
	PROCEDURE DoLoss (OUT losses: Events; json: BOOLEAN; OUT j: J.Json);
		
		(* Loss of members, event by event *)
		
		VAR
			
			ok, ok2, b: BOOLEAN;
			pk: B.Pubkey;
			jb, lb, n: INTEGER;
			mT, time, list: LONGINT;
			t: A.Tree;
			ev, ev0: Event;
			e: A.Elem;
			mt: LONGINT;
		
		BEGIN (*DoLoss*)
			A.New(t);
			ok := B.JLNextPubkey(TRUE, pk);
			WHILE ok DO
				ok2 := B.JLPub(pk, list) & B.JLPubLNext(list, jb, lb);
				WHILE ok2 DO
					IF ok2 THEN
						b := B.TimeOf(jb, mT, time); ASSERT(b, 100);
						NEW(ev); e := ev;
						ev.date := time; ev.number := 0;
						b := t.SearchIns(e, n);
						ev0 := e(Event);
						INC(ev0.number);
					END;
					IF lb # B.hasNotLeaved THEN
						b := B.TimeOf(lb, mT, time); ASSERT(b, 101);
						NEW(ev); e := ev;
						ev.date := time; ev.number := 0;
						b := t.SearchIns(e, n);
						DEC(e(Event).number);
					END;
					ok2 := B.JLPubLNext(list, jb, lb);
				END;
				DEC(ev0.number);
				ok := B.JLNextPubkey(FALSE, pk);
			END;
			n := t.NumberOfElems();
			IF n = 0 THEN
				losses := NIL;
			ELSE
				NEW(losses, t.NumberOfElems());
				n := 0;
				e := t.Next(NIL);
				WHILE e # NIL DO
					WITH e: Event DO
						losses[n].date := e.date;
						losses[n].number := - e.number;
					END;
					INC(n);
					e := t.Next(e);
				END;
				FOR n := 1 TO LEN(losses) - 1 DO
					INC(losses[n].number, losses[n - 1].number);
				END;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEvents);
			globalEvents.events := losses;
			j := J.BuildJsonFrom(globalEvents);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoLoss;
	
	PROCEDURE DoLossFlux (timeUnit: LONGINT; OUT lossesR: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of losses, event by event *)
		
		CONST
			
			pointsNb = 80;
			degree = 2;
			
		VAR
			
			losses: Events;
			dots, dotsD: U.Dots;
			i, oldPointsNb, oldDegree: INTEGER;
			b: BOOLEAN;
			mt: LONGINT;
		
		BEGIN (*DoLossFlux*)
			DoLoss(losses, FALSE, j);
			IF losses = NIL THEN
				lossesR := NIL;
				j := NIL;
				RETURN;
			END;
			NEW(dots, LEN(losses));
			FOR i := 0 TO LEN(losses) - 1 DO
				dots[i].x := losses[i].date / timeUnit;
				dots[i].y := losses[i].number;
			END;
			O.GetDeriveOptions(oldPointsNb, oldDegree);
			O.SetDeriveOptions(pointsNb, degree);
			b := O.Derive(dots, dotsD);
			O.SetDeriveOptions(oldPointsNb, oldDegree);
			NEW(lossesR, LEN(losses));
			FOR i := 0 TO LEN(losses) - 1 DO
				lossesR[i].date := losses[i].date;
				lossesR[i].number := dotsD[i].y;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := lossesR;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoLossFlux;
	
	PROCEDURE DoLossFluxPerMember (timeUnit: LONGINT; OUT lossesR: EventsR; json: BOOLEAN; OUT j: J.Json);
		
		(* Flux of losses per member, event by event *)
		
		VAR
			
			counts: Events;
			l: INTEGER;
			mt: LONGINT;
		
		BEGIN (*DoLossFluxPerMember*)
			DoLossFlux(timeUnit, lossesR, FALSE, j);
			DoCount(counts, FALSE, j);
			IF lossesR = NIL THEN
				j := NIL;
				RETURN;
			END;
			ASSERT((counts # NIL) & (LEN(counts) = LEN(lossesR)), 100);
			FOR l := 0 TO LEN(lossesR) - 1 DO
				lossesR[l].number := lossesR[l].number / counts[l].number;
			END;
			IF ~json THEN
				RETURN;
			END;
			J.StartObject;
			NEW(globalEventsR);
			globalEventsR.eventsR := lossesR;
			j := J.BuildJsonFrom(globalEventsR);
			J.PushField(j(J.Object).fields[0]);
			J.PushInteger(timeUnit);
			J.BuildField("time_unit");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			j := J.GetJson();
		END DoLossFluxPerMember;
	
	PROCEDURE Json (j: J.Json; IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Json*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			j.Write(f);
			BA.VRegister(TextViews.dir.New(t), BA.waitLoc, name$, 100, "Members.Json");
		END Json;
	
	PROCEDURE (a: Action) Activate;
		
		VAR
			
			j: J.Json;
			events: Events;
			eventsR: EventsR;
		
		BEGIN (*Activate*)
			CASE a.what OF
				|countA:
					DoCount(events, TRUE, j);
					Json(j, a.output);
				|countFA:
					DoCountFlux(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
				|countFPMA:
					DoCountFluxPerMember(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
				|firstEntriesA:
					DoFirstEntries(events, TRUE, j);
					Json(j, a.output);
				|fEFluxA:
					DoFEFlux(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
				|fEFluxPerMemberA:
					DoFEFluxPerMember(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
				|lossA:
					DoLoss(events, TRUE, j);
					Json(j, a.output);
				|lossFluxA:
					DoLossFlux(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
				|lossFluxPMA:
					DoLossFluxPerMember(a.timeUnit, eventsR, TRUE, j);
					Json(j, a.output);
			END;
		END Activate;
	
	PROCEDURE Count* (IN output: ARRAY OF CHAR);
		
		(* Number of members, event by event *)
		
		VAR
			
			a: Action;
		
		BEGIN (*Count*)
			NEW(a);
			a.what := countA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END Count;
	
	PROCEDURE CountFlux* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Number of members, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*CountFlux*)
			NEW(a);
			a.what := countFA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END CountFlux;
	
	PROCEDURE CountFluxPerMember* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Number of members, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*CountFluxPerMember*)
			NEW(a);
			a.what := countFPMA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END CountFluxPerMember;
	
	PROCEDURE FirstEntries* (IN output: ARRAY OF CHAR);
		
		(* Number of first entries, event by event *)
		
		VAR
			
			a: Action;
		
		BEGIN (*FirstEntries*)
			NEW(a);
			a.what := firstEntriesA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END FirstEntries;
	
	PROCEDURE FEFlux* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Flux of first entries, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*FEFlux*)
			NEW(a);
			a.what := fEFluxA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END FEFlux;
	
	PROCEDURE FEFluxPerMember* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Flux of first entries per member, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*FEFluxPerMember*)
			NEW(a);
			a.what := fEFluxPerMemberA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END FEFluxPerMember;
	
	PROCEDURE Loss* (IN output: ARRAY OF CHAR);
		
		(* Loss of members, event by event *)
		
		VAR
			
			a: Action;
		
		BEGIN (*Loss*)
			NEW(a);
			a.what := lossA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END Loss;
	
	PROCEDURE LossFlux* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Flux of losses, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*LossFlux*)
			NEW(a);
			a.what := lossFluxA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END LossFlux;
	
	PROCEDURE LossFluxPerMember* (IN output, timeUnit: ARRAY OF CHAR);
		
		(* Flux of losses per member, event by event *)
		
		VAR
			
			a: Action;
			res: INTEGER;
		
		BEGIN (*LossFluxPerMember*)
			NEW(a);
			a.what := lossFluxPMA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			Strings.StringToLInt(timeUnit, a.timeUnit, res); ASSERT(res = 0, 100);
			B.AddAction(a);
		END LossFluxPerMember;
	
	END Duniter1Members.
