(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1EventsPrint;
	
	

	IMPORT
		
		BA := Duniter1BasicPrint, GS := Duniter1GQLSender, J := UtilJson, Dialog, TextMappers, TextModels, TextViews, Views;
	
	CONST
		
		waitDelay = 100;
		
		memEndsJson = "MemEnds";
		missEndsJson = "MissEnds";
		certEndsJson = "CertEnds";
	
	TYPE
		
		 Action = POINTER TO RECORD (BA.WaitFor)
			title: Views.Title;
		END;
		
		Membership* = RECORD
			id*: BA.String;
			limit*: LONGINT;
		END;
		
		Memberships* = POINTER TO ARRAY OF Membership;
		
		Mems* = POINTER TO RECORD
			limits*: Memberships;
			block*: INTEGER;
			now*: LONGINT;
		END;
	
	VAR
		
		globalMems*: Mems;
	
	PROCEDURE Print (ms: Memberships; IN title: ARRAY OF CHAR; block: INTEGER; now: LONGINT);
		
		VAR
			
			i, j, m, l: INTEGER;
			s: Views.Title;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			dt: BA.DateTime;
		
		BEGIN (*Print*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			f.WriteMsg("#Duniter1:Block");
			f.WriteString(" ");
			f.WriteInt(block);
			f.WriteTab;
			BA.TimestampToString(now, dt);
			f.WriteString(dt);
			l := LEN(dt$);
			f.WriteString(" (UTC+0)");
			f.WriteLn; f.WriteLn;
			Dialog.MapString(title, s);
			f.WriteString(s);
			f.WriteLn; f.WriteLn;
			IF ms # NIL THEN
				m := LEN(ms);
				FOR i := 0 TO m - 1 DO
					f.WriteString('    ');
					BA.TimestampToString(ms[i].limit, dt);
					f.WriteString(dt);
					FOR j := LEN(dt$) TO l DO
						f.WriteString(" ");
					END;
					f.WriteString('    ');
					f.WriteString(ms[i].id);
					f.WriteLn;
				END;
			END;
			Views.OpenAux(TextViews.dir.New(t), s);
		END Print;
	
	PROCEDURE (a: Action) End (IN name: ARRAY OF CHAR);
		
		VAR
			
			j: J.Json;
		
		BEGIN (*End*)
			j := J.ReadFile(BA.waitDir, name); ASSERT(j # NIL, 100);
			NEW(globalMems);
			j.ApplyTo(globalMems);
			Print(globalMems.limits, a.title, globalMems.block, globalMems.now);
			globalMems := NIL;
		END End;
	
	PROCEDURE PrintMembershipsEnds*;
		
		VAR
			
			a: Action;
		
		BEGIN (*PrintMembershipsEnds*)
			BA.SwitchOff(BA.waitDir, memEndsJson + ".json");
			GS.Send("Duniter1Events", "MembershipsEnds", "", memEndsJson);
			NEW(a);
			a.title := "#Duniter1:LimitsM";
			a.Do(BA.waitDir, memEndsJson + ".json", waitDelay);
		END PrintMembershipsEnds;
	
	PROCEDURE PrintMissingEnds*;
		
		VAR
			
			a: Action;
		
		BEGIN (*PrintMissingEnds*)
			BA.SwitchOff(BA.waitDir, missEndsJson + ".json");
			GS.Send("Duniter1Events", "MissingEnds", "", missEndsJson);
			NEW(a);
			a.title := "#Duniter1:LimitsMissing";
			a.Do(BA.waitDir, missEndsJson + ".json", waitDelay);
		END PrintMissingEnds;
	
	PROCEDURE PrintCertifsEnds*;
		
		VAR
			
			a: Action;
		
		BEGIN (*PrintCertifsEnds*)
			BA.SwitchOff(BA.waitDir, certEndsJson + ".json");
			GS.Send("Duniter1Events", "CertifsEnds", "", certEndsJson);
			NEW(a);
			a.title := "#Duniter1:LimitsC";
			a.Do(BA.waitDir, certEndsJson + ".json", waitDelay);
		END PrintCertifsEnds;
	
	END Duniter1EventsPrint.

Duniter1EventsPrint.PrintMembershipsEnds;

Duniter1EventsPrint.PrintMissingEnds;

Duniter1EventsPrint.PrintCertifsEnds;
