(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1WWViews;
	
	
	
	(* This module creates views displaying WotWizard forecasts *)
		
	IMPORT
		
		(*
		StdLog,
		*)
		
		B := Duniter1BlockchainPrint, BA := Duniter1BasicPrint, GS := Duniter1GQLSender, Containers, Controllers, Controls, DevSearch, Dialog, Documents, Files, Fonts, Math, J := UtilJson, Models, Ports, Properties, Sequencers, StdCmds, Stores, Strings, TextControllers, TextMappers, TextModels, TextRulers, TextViews, Views, Windows;
	
	CONST
		
		waitDelay = 100;
		
		wwResult = "WWResult.json"; (* Json file containing metadata & calculated entries *)
		wwDone = "WWDone.json";
		
		(* File containing previous entries data output *)
		oldEntriesName = "WW_Old_Entries.odc";
		(* File containing previous metadata output *)
		oldMetaName = "WW_Old_Meta.odc";
		
		title = "WotWizard"; (* Title of the outputs *)
		
		width = 80 * Ports.mm; (* Original window width *)
		height = 150 * Ports.mm; (* Original window height *)
		
		(* Output sorts *)
		byDate = 0; byName = 1; meta = 2;
		
		(* Sizes of fonts *)
		titleSize = 20 * Fonts.point;
		headSize = 14 * Fonts.point;
		corpusSize = 10 * Fonts.point;
		
		(* Indentations widths *)
		indent = 5 * Ports.mm;
		indentM = 2 * Ports.mm;
		
		(* Extra widths of buttons *)
		radioOffset = 5 * Ports.mm;
		buttonOffset = 5 * Ports.mm;
		
		(* Tab stops *)
		firstCtrlPos = width * 1 DIV 6;
		secondCtrlPos = width * 3 DIV 6;
		thirdCtrlPos = width * 5 DIV 6;
	
	TYPE
		
		 Action = POINTER TO RECORD (BA.WaitFor)
			v: View;
		END;
		
		(* Type of the view which displays the WotWizard lists *)
		View = POINTER TO LIMITED RECORD (Views.View)
			block: INTEGER;
			nowS: BA.DateTime; (* Current date *)
			meta: J.Json;
			dates: By_dates;
			names: By_names;
			modified: BOOLEAN; (* The sets of permutations have been modified *)
			text: TextViews.View; (* The displayed text *)
		END;
		
		(* Return the first View *)
		FindMsg = RECORD (Views.Message)
			v: View;
		END;
		
		Cert* = RECORD
			from*: BA.String;
			date*,
			limit*: LONGINT;
		END;
		
		Certs* = POINTER TO ARRAY OF Cert;

		Certif* = POINTER TO RECORD
			from*,
			to*: BA.String;
			date*,
			limit*: LONGINT;
		END;

		Dossier* = POINTER TO RECORD
			newcomer*: BA.String;
			main_certifs*: INTEGER;
			proportion_of_sentries*: REAL;
			date*,
			limit*: LONGINT;
			certifs*: Certs;
		END;
		
		CertOrDoss* = RECORD 
			certif*: Certif;
			dossier*: Dossier;
		END;
		
		File* = POINTER TO ARRAY OF CertOrDoss;
		
		Meta* = POINTER TO RECORD
			permutations*: INTEGER;
			computation_duration*: LONGINT;
			certNb*,
			dossNb*: INTEGER;
			certifs_dossiers*: File;
		END;
		
		Name* = RECORD
			name*: B.String;
			proba*: REAL;
			proba_int*: INTEGER;
		END;
		
		Names* = POINTER TO ARRAY OF Name;
		
		By_date* = RECORD
			after*: BOOLEAN;
			date*: LONGINT;
			names*: Names;
		END;
		
		By_dates* = POINTER TO ARRAY OF By_date;
		
		Date* = RECORD
			after*: BOOLEAN;
			date*: LONGINT;
			proba*: REAL;
			proba_int*: INTEGER;
		END;
		
		Dates* = POINTER TO ARRAY OF Date;
		
		By_name* = RECORD
			name*: B.String;
			dates*: Dates;
		END;
		
		By_names* = POINTER TO ARRAY OF By_name;
		
		Result* = POINTER TO RECORD
			meta*: Meta;
			dates*: By_dates;
			names*: By_names;
			block*: INTEGER;
			now*: LONGINT;
		END;
		
		PerCent* = ARRAY 5 OF CHAR;
		
		CCert* = RECORD
			from-: BA.String;
			date-,
			limit-: BA.DateTime;
		END;
		
		CCerts* = POINTER TO ARRAY OF CCert;

		CCertif* = POINTER TO RECORD (CCertOrDoss)
			certification-: RECORD
				date-,
				limit-: BA.DateTime;
				from-,
				to-: BA.String;
			END;
		END;

		CDossier* = POINTER TO RECORD (CCertOrDoss)
			dossier-: RECORD
				date-,
				limit-: BA.DateTime;
				newcomer-: BA.String;
				main_certifs-: INTEGER;
				proportion_of_sentries-: PerCent;
				certifs-: CCerts;
			END;
		END;
		
		CCertOrDoss* = POINTER TO ABSTRACT RECORD 
		END;
		
		CFile* = POINTER TO ARRAY OF CCertOrDoss;
		
		CMeta* = POINTER TO RECORD
			permutations-: INTEGER;
			computation_duration-: BA.TimeString;
			certNb-,
			dossNb-: INTEGER;
			certifs_dossiers-: CFile;
		END;
		
		CResult* = POINTER TO RECORD
			meta-: CMeta;
			dates-: By_dates;
			names-: By_names;
			block-: INTEGER;
			now-: LONGINT;
		END;
	
	VAR
		
		globalRes*: Result;
		globalMeta-: CMeta;
		
		dateNameMeta*: INTEGER; (* Sort of the output *)
		
		showOldEntries-: BOOLEAN;
	
	(* Find the first View *)
	PROCEDURE FindFirst (): View;
		
		VAR
			
			w: Windows.Window;
			msg: FindMsg;
		
		BEGIN (*FindFirst*)
			w := Windows.dir.First();
			WHILE w # NIL DO
				IF (w.frame # NIL) & (w.frame.view # NIL) & (w.frame.view IS Documents.Document) & (w.frame.view(Documents.Document).ThisView() IS View) THEN
					RETURN w.frame.view(Documents.Document).ThisView()(View);
				END;
				w := Windows.dir.Next(w);
			END;
			msg.v := NIL;
			Views.Omnicast(msg);
			RETURN msg.v;
		END FindFirst;
	
	PROCEDURE SetNotDirty (v: Views.View);
		
		VAR
			
			d: Stores.Domain;
			any: ANYPTR;
			seq: Sequencers.Sequencer;
		
		BEGIN (*SetNotDirty*)
			ASSERT(v # NIL, 20);
			d := v.Domain();
			IF d # NIL THEN
				any := d.GetSequencer();
				IF (any # NIL) & (any IS Sequencers.Sequencer) THEN
					seq := any(Sequencers.Sequencer);
					seq.SetDirty(FALSE);
				END;
			END;
		END SetNotDirty;
	
	(* Test the equality of the two permutations sorted by dates o1 and o2 *)
	PROCEDURE OccursEqual (d1, d2: By_dates): BOOLEAN;
		
		VAR
			
			i, j: INTEGER;
			n1, n2: Names;
		
		BEGIN (*OccursEqual*)
			IF ((d1 = NIL) # (d2 = NIL)) OR (LEN(d1) # LEN(d2)) THEN
				RETURN FALSE;
			END;
			IF d1 # NIL THEN
				FOR i := 0 TO LEN(d1) - 1 DO
					IF (d1[i].after # d2[i].after) OR (d1[i].date # d2[i].date) THEN
						RETURN FALSE;
					END;
					n1 := d1[i].names; n2 := d2[i].names;
					IF ((n1 = NIL) # (n2 = NIL)) OR (LEN(n1) # LEN(n2)) THEN
						RETURN FALSE;
					END;
					IF n1 # NIL THEN
						FOR j := 0 TO LEN(n1) - 1 DO
							IF (n1[j].name$ # n2[j].name$) OR (ENTIER(Math.Round(n1[j].proba * 100)) # ENTIER(Math.Round(n2[j].proba * 100))) THEN
								RETURN FALSE;
							END;
						END;
					END;
				END;
			END;
			RETURN TRUE;
		END OccursEqual;
	
	(* Print the permutation occurD sorted by dates *)
	PROCEDURE ByDates (IN f: TextMappers.Formatter; nL: INTEGER; d: By_dates);
		
		VAR
			
			r: TextRulers.Ruler;
			s: BA.DateTime;
			l, i, j: INTEGER;
			n: Names;
		
		BEGIN (*ByDates*)
			IF d = NIL THEN
				RETURN;
			END;
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			l := 0;
			FOR i := 0 TO LEN(d) - 1 DO
				IF d[i].names # NIL THEN
					FOR j := 0 TO LEN(d[i].names) - 1 DO
						l := MAX(l, f.rider.attr.font.StringWidth(d[i].names[j].name$ + '+ '));
					END;
				END;
			END;
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, indent);
			TextRulers.SetFixedRight(r, width);
			TextRulers.AddTab(r, indent + l);
			f.WriteView(r);
			f.WriteLn; f.WritePara;
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
			f.WriteInt(nL); f.WriteString(" ");
			f.WriteMsg("#Duniter1:newcomers");
			f.WriteLn;
			FOR i := 0 TO LEN(d) - 1 DO
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
				f.WriteLn; f.WritePara;
				BA.TimestampToString(d[i].date, s);
				f.WriteString(s);
				IF d[i].after THEN
					f.WriteString("+");
				END;
				f.WriteLn;
				n := d[i].names;
				IF n # NIL THEN
					f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
					FOR j := 0 TO LEN(n) - 1 DO
						f.WriteString(n[j].name);
						f.WriteTab;
						f.WriteString(": ");
						f.WriteMsg("#Duniter1:Proba");
						f.WriteString(" = ");
						f.WriteIntForm(ENTIER(Math.Round(n[j].proba * 100)), 10, 3, "", FALSE); (* Digit space *)
						f.WriteString("%");
						f.WriteLn;
					END;
				END;
			END;
		END ByDates;
	
	(* Print the permutation occurN sorted by names *)
	PROCEDURE ByNames (IN f: TextMappers.Formatter; n: By_names);
		
		VAR
			
			r: TextRulers.Ruler;
			s: BA.DateTime;
			i, j: INTEGER;
			d: Dates;
		
		BEGIN (*ByNames*)
			IF n = NIL THEN
				RETURN;
			END;
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, indent);
			TextRulers.SetFixedRight(r, width);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			BA.TimestampToString(0, s);
			TextRulers.AddTab(r, indent + f.rider.attr.font.StringWidth(s + '+ '));
			f.WriteView(r);
			f.WriteLn; f.WritePara;
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
			f.WriteInt(LEN(n)); f.WriteString(" ");
			f.WriteMsg("#Duniter1:newcomers");
			f.WriteLn;
			FOR i := 0 TO LEN(n) - 1 DO
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
				f.WriteLn; f.WritePara;
				f.WriteString(n[i].name);
				f.WriteLn;
				d := n[i].dates;
				IF d # NIL THEN
					f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
					FOR j := 0 TO LEN(d) - 1 DO
						BA.TimestampToString(d[j].date, s);
						f.WriteString(s);
						IF d[j].after THEN
							f.WriteString("+");
						END;
						f.WriteTab;
						f.WriteString(": ");
						f.WriteMsg("#Duniter1:Proba");
						f.WriteString(" = ");
						f.WriteIntForm(ENTIER(Math.Round(d[j].proba * 100)), 10, 3, "", FALSE); (* Digit space *)
						f.WriteString("%");
						f.WriteLn;
					END;
				END;
			END;
		END ByNames;
	
	(* Print the metadata m with the help of f *)
	PROCEDURE PrintMeta (IN f: TextMappers.Formatter; m: J.Json);
		
		CONST
			
			tabNb = 10;
		
		VAR
			
			r: TextRulers.Ruler;
			i: INTEGER;
		
		BEGIN (*PrintMeta*)
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, 0);
			TextRulers.SetFixedRight(r, width);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			FOR i := 1 TO tabNb DO
				TextRulers.AddTab(r, i * indentM);
			END;
			f.WriteView(r);
			IF m # NIL THEN
				m.Write(f);
			END;
		END PrintMeta;
	
	PROCEDURE ConvertMeta (m: Meta; OUT cM: CMeta);
		
		PROCEDURE ConvertFile (f: File; OUT cF: CFile);
			
			VAR
				
				i: INTEGER;
			
			PROCEDURE ConvertCertOrDoss (IN cd: CertOrDoss; OUT cCd: CCertOrDoss);
				
				VAR
					
					c: CCertif;
					d: CDossier;
				
				PROCEDURE ConvertCerts (c: Certs; OUT cc: CCerts);
					
					VAR
						
						i: INTEGER;
					
					PROCEDURE ConvertCert (IN c: Cert; OUT cc: CCert);
						
						BEGIN (*ConvertCert*)
							cc.from := c.from;
							BA.TimestampToString(c.date, cc.date);
							BA.TimestampToString(c.limit, cc.limit);
						END ConvertCert;
					
					BEGIN (*ConvertCerts*)
						IF c = NIL THEN
							cc := NIL;
						ELSE
							NEW(cc, LEN(c));
							FOR i := 0 TO LEN(c) - 1 DO
								ConvertCert(c[i], cc[i]);
							END ;
						END;
					END ConvertCerts;
				
				BEGIN (*ConvertCertOrDoss*)
					IF cd.certif = NIL THEN ASSERT(cd.dossier # NIL, 100);
						NEW(d);
						d.dossier.newcomer := cd.dossier.newcomer;
						d.dossier.main_certifs := cd.dossier.main_certifs;
						Strings.IntToString(SHORT(ENTIER(100 * cd.dossier.proportion_of_sentries)), d.dossier.proportion_of_sentries);
						d.dossier.proportion_of_sentries := d.dossier.proportion_of_sentries + "%";
						BA.TimestampToString(cd.dossier.date, d.dossier.date);
						BA.TimestampToString(cd.dossier.limit, d.dossier.limit);
						ConvertCerts(cd.dossier.certifs, d.dossier.certifs);
						cCd := d;
					ELSE ASSERT(cd.dossier = NIL, 101);
						NEW(c);
						c.certification.from := cd.certif.from;
						c.certification.to := cd.certif.to;
						BA.TimestampToString(cd.certif.date, c.certification.date);
						BA.TimestampToString(cd.certif.limit, c.certification.limit);
						cCd := c;
					END;
				END ConvertCertOrDoss;
			
			BEGIN (*ConvertFile*)
				IF f = NIL THEN
					cF := NIL;
				ELSE
					NEW(cF, LEN(f));
					FOR i := 0 TO LEN(f) - 1 DO
						ConvertCertOrDoss(f[i], cF[i]);
					END;
				END;
			END ConvertFile;
		
		BEGIN (*ConvertMeta*)
			NEW(cM);
			cM.permutations := m.permutations;
			BA.TimeToString(m.computation_duration, cM.computation_duration);
			cM.certNb := m.certNb;
			cM.dossNb := m.dossNb;
			ConvertFile(m.certifs_dossiers, cM.certifs_dossiers);
		END ConvertMeta;
	
	PROCEDURE ConvertResult (r: Result; OUT cR: CResult);
		
		BEGIN (*ConvertResult*)
			NEW(cR);
			ConvertMeta(r.meta, cR.meta);
			cR.dates := r.dates;
			cR.names := r.names;
			cR.block := r.block;
			cR.now := r.now;
		END ConvertResult;
	
	(* Extract now and build the permutations oD, sorted by dates, and oN, sorted by names, from j *)
	PROCEDURE BuildResult (j: J.Json; OUT res: CResult);
		
		BEGIN (*BuildResult*)
			NEW(globalRes);
			j.ApplyTo(globalRes);
			ConvertResult(globalRes, res);
			globalRes := NIL;
		END BuildResult;
	
	PROCEDURE InitProp (VAR p: Controls.Prop);
		
		BEGIN (*InitProp*)
			NEW(p);
			p.link := ""; p.label := ""; p.guard := ""; p.notifier := "";
			p.level := 0;
			p.opt[0] := FALSE; p.opt[1] := FALSE;
			p.opt[2] := FALSE; p.opt[3] := FALSE;
			p.opt[4] := FALSE;
		END InitProp;
	
	(* Write the text of the View v *)
	PROCEDURE (v: View) WriteText, NEW;
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			r: TextRulers.Ruler;
			nL: INTEGER;
		
		(* Insert into the text the three radio buttons and one or two command buttons *)
		PROCEDURE InsertControls (IN f: TextMappers.Formatter);
			
			VAR
				
				r: TextRulers.Ruler;
				prop: Controls.Prop;
				c: Controls.Control;
				s: Dialog.String;
				w, h: INTEGER;
			
			BEGIN (*InsertControls*)
				f.WriteLn;
				r := TextRulers.dir.New(NIL);
				TextRulers.AddTab(r, firstCtrlPos);
				TextRulers.MakeCenterTab(r);
				TextRulers.AddTab(r, secondCtrlPos);
				TextRulers.MakeCenterTab(r);
				TextRulers.AddTab(r, thirdCtrlPos);
				TextRulers.MakeCenterTab(r);
				f.WriteView(r);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter1WWViews.dateNameMeta";
				prop.label := "#Duniter1:ByName";
				prop.notifier := "Duniter1WWViews.DateNameMetaNotifier";
				prop.level := 1;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter1WWViews.dateNameMeta";
				prop.label := "#Duniter1:Meta";
				prop.notifier := "Duniter1WWViews.DateNameMetaNotifier";
				prop.level := 2;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter1WWViews.dateNameMeta";
				prop.label := "#Duniter1:ByDate";
				prop.notifier := "Duniter1WWViews.DateNameMetaNotifier";
				prop.level := 0;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteLn;
				IF v.modified THEN
					f.WriteLn;
					f.WriteTab;
					InitProp(prop);
					prop.link := "Duniter1WWViews.Clear";
					prop.label := "#Duniter1:Check";
					Dialog.MapString(prop.label, s);
					c := Controls.dir.NewPushButton(prop);
					f.WriteView(c);
					c.context.GetSize(w, h);
					c.context.SetSize(c.font.StringWidth(s) + buttonOffset, h);
					f.WriteLn;
				END;
			END InsertControls;
		
		BEGIN (*WriteText*)
			t := v.text.ThisModel();
			t.Delete(0, t.Length());
			f.ConnectTo(t);
			r := TextRulers.dir.New(NIL);
			TextRulers.SetCentered(r);
			TextRulers.SetFixedRight(r, width);
			f.WriteView(r);
			f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.normal));
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, titleSize));
			IF v.modified THEN
				f.WriteString("* ");
			END;
			f.WriteString(title);
			IF v.modified THEN
				f.WriteString(" *");
			END;
			f.WriteLn;
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
			f.WriteMsg("#Duniter1:Block");
			f.WriteString(" ");
			f.WriteInt(v.block);
			f.WriteLn;
			f.WriteString(v.nowS);
			f.WriteString(" (UTC+0)");
			f.WriteLn;
			InsertControls(f);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			IF v.dates # NIL THEN
				CASE dateNameMeta OF
					|byDate:
						IF v.names = NIL THEN
							nL := 0;
						ELSE
							nL := LEN(v.names);
						END;
						ByDates(f, nL, v.dates);
					|byName:
						ByNames(f, v.names);
					|meta:
						PrintMeta(f, v.meta);
				END;
			END;
			Views.Update(v, Views.keepFrames);
			SetNotDirty(v);
		END WriteText;
	
	(* When the WotWizard lists have been modified, stores on disk the old results versions in oldEntriesName and oldMetaName files *)
	PROCEDURE OldResults (nL: INTEGER; d: By_dates; meta: J.Json);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			v: Views.View;
			loc: Files.Locator;
		
		PROCEDURE Header (VAR f: TextMappers.Formatter);
			
			VAR
				
				r: TextRulers.Ruler;
				prop: Controls.Prop;
				c: Controls.Control;
				s: Dialog.String;
				w, h: INTEGER;
			
			BEGIN (*Header*)
				r := TextRulers.dir.New(NIL);
				TextRulers.SetCentered(r);
				TextRulers.SetFixedRight(r, width);
				f.WriteView(r);
				f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.normal));
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, titleSize));
				f.WriteString(title);
				f.WriteLn;
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
				f.WriteMsg("#Duniter1:PreviousDisplay");
				f.WriteLn;
				f.WriteLn;
				r := TextRulers.dir.New(NIL);
				TextRulers.AddTab(r, thirdCtrlPos);
				TextRulers.MakeCenterTab(r);
				f.WriteView(r);
				f.WriteTab;
				InitProp(prop);
				prop.link := "DevSearch.Compare";
				prop.label := "#Duniter1:Compare";
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewPushButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + buttonOffset, h);
				f.WriteLn;
			END Header;
		
		BEGIN (*OldResults*)
			loc := Files.dir.This(""); ASSERT(loc.res = 0, 100);
			
			t := TextModels.dir.New();
			f.ConnectTo(t);
			Header(f);
			ByDates(f, nL, d);
			v := TextViews.dir.New(t);
			Views.RegisterView(v, loc, oldEntriesName);
			
			t := TextModels.dir.New();
			f.ConnectTo(t);
			Header(f);
			PrintMeta(f, meta);
			v := TextViews.dir.New(t);
			Views.RegisterView(v, loc, oldMetaName);
		END OldResults;
	
	(* Test whether the WotWizard lists have changed *)
	PROCEDURE (v: View) UpdateText, NEW;
		
		VAR
			
			dates: By_dates;
			meta: J.Json;
			b, oM: BOOLEAN;
			result: CResult;
			nL: INTEGER;
		
		BEGIN (*UpdateText*)
			BuildResult(J.ReadFile(BA.waitDir, wwResult), result);
			BA.Collect;
			globalMeta := result.meta;
			meta := J.BuildJsonFrom(globalMeta);
			globalMeta := NIL;
			dates := result.dates;
			oM := v.modified;
			b := ~OccursEqual(dates, v.dates);
			v.modified := v.modified OR b & (v.dates # NIL);
			IF b & ~oM THEN
				IF v.names = NIL THEN
					nL := 0;
				ELSE
					nL := LEN(v.names);
				END;
				OldResults(nL, v.dates, v.meta);
			END;
			v.block := result.block;
			BA.TimestampToString(result.now, v.nowS);
			v.dates := dates;
			v.names := result.names;
			v.meta := meta;
		END UpdateText;
	
	PROCEDURE (v: View) InstallText, NEW;
		
		BEGIN (*InstallText*)
			v.text := TextViews.dir.New(TextModels.dir.New());
			Stores.Join(v, v.text);
			v.text.ThisController().SetOpts({Containers.noCaret});
		END InstallText;
	
	PROCEDURE (v: View) CopyFromModelView (source: Views.View; model: Models.Model);
		
		BEGIN (*CopyFromModelView*)
			WITH source: View DO
				v.block := source.block;
				v.nowS := source.nowS;
				v.meta := source.meta;
				v.dates := source.dates;
				v.names := source.names;
				IF model = NIL THEN
					v.text := Views.CopyOf(source.text, Views.deep)(TextViews.View);
				ELSE
					v.text := Views.CopyWithNewModel(source.text, model)(TextViews.View);
				END;
				v.modified := source.modified;
			END;
		END CopyFromModelView;
	
	PROCEDURE (v: View) ThisModel (): Models.Model;
		
		BEGIN (*ThisModel*)
			RETURN v.text.ThisModel();
		END ThisModel;
	
	PROCEDURE (v: View) InitContext (context: Models.Context);
		
		BEGIN (*InitContext*)
			v.InitContext^(context);
			v.text.InitContext(context);
		END InitContext;
	
	PROCEDURE (v: View) Neutralize;
		
		BEGIN (*Neutralize*)
			v.text.Neutralize;
		END Neutralize;
	
	PROCEDURE (v: View) Restore (f: Views.Frame; l, t, r, b: INTEGER);
		
		BEGIN (*Restore*)
			Views.InstallFrame(f, v.text, 0, 0, 0, TRUE);
		END Restore;
	
	PROCEDURE (v: View) HandleViewMsg (f: Views.Frame; VAR msg: Views.Message);
		
		BEGIN (*HandleViewMsg*)
			WITH msg: FindMsg DO
				IF msg.v = NIL THEN
					msg.v := v;
				END;
			ELSE
			END;
		END HandleViewMsg;
	
	PROCEDURE (v: View) HandleCtrlMsg (f: Views.Frame; VAR msg: Controllers.Message; VAR focus: Views.View);
		
		BEGIN (*HandleCtrlMsg*)
			WITH
				|msg: Controllers.PollOpsMsg DO
					msg.type := "Duniter1WWViews.View";
					IF v.text.ThisController().HasSelection() THEN
						msg.valid := {Controllers.copy};
					END;
				ELSE
					focus := v.text;
			END;
		END HandleCtrlMsg;
	
	PROCEDURE (v: View) HandlePropMsg (VAR p: Properties.Message);
		
		BEGIN (*HandlePropMsg*)
			WITH 
				|p: Properties.SizePref DO
					IF p.w = Views.undefined THEN
						p.w := width;
					END;
					IF p.h = Views.undefined THEN
						p.h := height;
					END;
				|p: Properties.ResizePref DO
					p.verFitToWin := TRUE;
					p.horFitToWin := TRUE;
				ELSE
					Views.HandlePropMsg(v.text, p);
			END;
		END HandlePropMsg;
	
	PROCEDURE Focus* (): Views.View;
		
		VAR
			
			v: Views.View;
		
		BEGIN (*Focus*)
			v := Controllers.FocusView();
			IF (v # NIL) & (v IS View) THEN
				RETURN v;
			ELSE
				RETURN NIL;
			END;
		END Focus;
	
	PROCEDURE Rewrite;
		
		VAR
			
			v: View;
		
		BEGIN (*Rewrite*)
			v := FindFirst();
			IF v # NIL THEN
				v.WriteText;
			END;
		END Rewrite;
	
	(* Remove the asterik marks and the button "Check"; open the new and old versions of metadata and entries data for comparisons *)
	PROCEDURE Clear*;
		
		VAR
			
			v: View;
			vv: TextViews.View;
			vvo: Views.View;
			loc: Files.Locator;
			dN: INTEGER;
			target: Dialog.String;
		
		PROCEDURE SetCaret (v: TextViews.View; IN target: ARRAY OF CHAR);
			
			VAR
				
				line, pos: INTEGER;
				s: TextMappers.Scanner;
			
			BEGIN (*SetCaret*)
				s.ConnectTo(v.ThisModel());
				line := s.lines; pos := 0;
				s.Scan;
				WHILE ~((s.type = TextMappers.eot) OR (s.type = TextMappers.string) & (s.string$ = target$)) DO
					IF s.lines # line THEN
						line := s.lines;
						pos := s.start;
					END;
					s.Scan;
				END;
				v.ThisController()(TextControllers.Controller).SetCaret(pos);
			END SetCaret;
		
		BEGIN (*Clear*)
			v := FindFirst();
			IF v # NIL THEN
				v.modified := FALSE;
				v.WriteText;
				IF showOldEntries THEN
					loc := Files.dir.This(""); ASSERT(loc.res = 0, 100);
					
					vvo := Views.OldView(loc, oldMetaName);
					IF vvo # NIL THEN
						IF dateNameMeta # meta THEN
							dN := dateNameMeta;
							dateNameMeta := meta;
							Rewrite;
							vv := Stores.CopyOf(v.text)(TextViews.View);
							dateNameMeta := dN;
							Rewrite;
						ELSE
							vv := Stores.CopyOf(v.text)(TextViews.View);
						END;
						Views.OpenView(vv);
						StdCmds.SetEditMode;
						SetNotDirty(vv);
						Views.OpenView(vvo);
						DevSearch.Compare;
					END;
					
					vvo := Views.OldView(loc, oldEntriesName);
					IF vvo # NIL THEN
						Dialog.MapString("#Duniter1:newcomers", target);
						IF dateNameMeta # byDate THEN
							dN := dateNameMeta;
							dateNameMeta := byDate;
							Rewrite;
							vv := Stores.CopyOf(v.text)(TextViews.View);
							dateNameMeta := dN;
							Rewrite;
						ELSE
							vv := Stores.CopyOf(v.text)(TextViews.View);
						END;
						Views.OpenView(vv);
						StdCmds.SetEditMode;
						SetNotDirty(vv);
						SetCaret(vv, target);
						Views.OpenView(vvo);
						SetCaret(vvo(TextViews.View), target);
						DevSearch.Compare;
					END;
					
				END;
			END;
		END Clear;
	
	(* Mark the view as modified *)
	PROCEDURE SetModified*;
		
		VAR
			
			v: View;
		
		BEGIN (*SetModified*)
			v := FindFirst();
			IF v # NIL THEN
				v.modified := TRUE;
				v.WriteText;
			END;
		END SetModified;
	
	PROCEDURE DateNameMetaNotifier* (op, from, to: INTEGER);
		
		BEGIN (*DateNameMetaNotifier*)
			IF op = Dialog.changed THEN
				Rewrite;
			END;
		END DateNameMetaNotifier;
	
	PROCEDURE ShowOldEntries*;
		
		BEGIN (*ShowOldEntries*)
			showOldEntries := TRUE;
		END ShowOldEntries;
	
	PROCEDURE HideOldEntries*;
		
		BEGIN (*HideOldEntries*)
			showOldEntries := FALSE;
		END HideOldEntries;
	
	PROCEDURE (a: Action) End (IN name: ARRAY OF CHAR);
		
		VAR
			
			v: View;
		
		BEGIN (*End*)
			a.v.UpdateText;
			a.v.WriteText;
			v := FindFirst();
			IF v = NIL THEN
				GS.Send("Duniter1Server", "Stop", "", "");
			ELSE
				BA.SwitchOff(BA.waitDir, wwDone);
				a.v := v;
				a.Do(BA.waitDir, wwDone, waitDelay);
			END;
		END End;
	
	PROCEDURE New* (): Views.View;
		
		VAR
			
			v: View;
			a: Action;
		
		BEGIN (*New*)
			NEW(v);
			v.InstallText;
			v.dates := NIL;
			v.modified := FALSE;
			BA.SwitchOff(BA.waitDir, wwDone);
			GS.Send("Duniter1Server", "Start", "", "");
			NEW(a);
			a.v := v;
			a.Do(BA.waitDir, wwDone, waitDelay);
			RETURN v;
		END New;
	
	PROCEDURE Deposit*;
		
		BEGIN (*Deposit*)
			Views.Deposit(New());
		END Deposit;
	
	PROCEDURE Open*;
		
		BEGIN (*Open*)
			Views.OpenAux(New(), title);
		END Open;
	
	PROCEDURE Init;
	
		BEGIN (*Init*)
			dateNameMeta := byName;
			showOldEntries := TRUE;
		END Init;
	
	BEGIN (*Duniter1WWViews*)
		Init;
	END Duniter1WWViews.

"Duniter1WWViews.Deposit;StdCmds.Open"

Duniter1WWViews.Clear;

Duniter1WWViews.SetModified;

Duniter1WWViews.ShowOldEntries;

Duniter1WWViews.HideOldEntries;
