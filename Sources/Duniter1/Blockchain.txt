(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1Blockchain;
	
	
	
	IMPORT
		
		(**
		L := StdLog,
		**)
		
		A := UtilAvlTree, B := UtilBBTree2, BA := Duniter1Basic, Duniter1GQLReceiver, Files, HostMenus, Math, Services, TextMappers, TextModels, TextViews, J := UtilJson, UtilLog, UtilMutex, UtilSort, U := UtilSets;
	
	CONST
		
		(* Directory of the Parameters json file, in the WotWizard directory *)
		dDir* = "Duniter1";
		(* Name of the Parameters json file *)
		dPars* = "DPars.json";
		sBaseName* = "SBase.json";
		dBaseName = "DBase.data";
		(* Path of the WotWizard database, in the WotWizard.exe directory *)
		dBase = dDir + "\" + dBaseName;
		dSyncName = "updated.txt";
		stopName = "Stop.txt";
		updtStatusName = "Status.json";
		
		dispatchDelay = 100; (* ms *)
		
		(* Number of pages used by UtilBTree *)
		pageNb = 2000;
		
		(* Max length of a Pubkey *)
		pubkeyLen* = 44;
		
		(* Max length of a Hash *)
		hashLen* = 64;
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0; (* Index timeT *)
		joinAndLeavePlace = 1; (* Index joinAndLeaveT *)
		idPubPlace = 2; (* Index idPubT *)
		idUidPlace = 3; (* Index idUidT *)
		idHashPlace = 4; (* Index idHashT *)
		idTimePlace = 5; (* Index idTimeT *)
		certFromPlace = 6; (* Index certFromT *)
		certToPlace = 7; (* Index certToT *)
		certTimePlace = 8; (* Index certTimeT *)
		undoListPlace = 9; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 10; (* Last read block *)
		idLenPlace = 11; (* Number of actual members *)
		
		placeNb = 12; (* Number of places *)
	
	TYPE
		
		Action* = POINTER TO ABSTRACT RECORD
			next: Action;
		END;
		
		ActionQueue = RECORD
			end: Action;
		END;
		
		(* Procedure called at every update *)
		UpdateProc* = PROCEDURE;
		
		(* Chained list of procedures called at every update *)
		UpdateList = POINTER TO RECORD
			next: UpdateList;
			update: UpdateProc;
		END;
		
		DispatchAction = POINTER TO RECORD (Services.Action)
		END;
		
		String* = BA.String;
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		Hash* = ARRAY hashLen + 1 OF CHAR;
		
		StringArr* = POINTER TO ARRAY OF String;
		
		(* Duniter Parameters *)
		Parameters* = POINTER TO RECORD
			
			(* The %growth of the UD every [dtReeval] period = 0.0488 /  (6 months) = 4.88% / (6 months) *)
			c*: REAL;
			
			(* Time period between two UD = 86400 s = 1 day *)
			dt*,
			
			(* UD(0), i.e. initial Universal Dividend = 1000 cents = 10 Ğ1 *)
			ud0*,
			
			(* Minimum delay between 2 certifications of a same issuer = 432000 s = 5 days *)
			sigPeriod*,
			
			(* Maximum quantity of active certifications made by member = 100 *)
			sigStock*,
			
			(* Maximum delay a certification can wait before being expired for non-writing = 5259600 s = 2 months *)
			sigWindow*,
			
			(* Maximum age of an active certification = 63115200 s = 2 years *)
			sigValidity*,
			
			(* Minimum delay before replaying a certification = 5259600 s = 2 months *)
			sigReplay*,
			
			(* Minimum quantity of signatures to be part of the WoT = 5 *)
			sigQty*,
			
			(* Maximum delay an identity can wait before being expired for non-writing = 5259600 s = 2 months *)
			idtyWindow*,
			
			(* Maximum delay a membership can wait before being expired for non-writing = 5259600 s = 2 months *)
			msWindow*,
			
			(* Minimum delay between 2 memberships of a same issuer = 5259600 s = 2 months *)
			msPeriod*: INTEGER;
			
			(* Minimum percent of sentries to reach to match the distance rule = 0.8 = 80% *)
			xpercent*: REAL;
			
			(* Maximum age of an active membership = 31557600 s = 1 year *)
			msValidity*,
			
			(* Maximum distance between a newcomer and [xpercent] of sentries = 5 *)
			stepMax*,
			
			(* Number of blocks used for calculating median time = 24 *)
			medianTimeBlocks*,
			
			(* The average time for writing 1 block (wished time) = 300 s = 5 min *)
			avgGenTime*,
			
			(* The number of blocks required to evaluate again PoWMin value = 12 *)
			dtDiffEval*: INTEGER;
			
			(* The percent of previous issuers to reach for personalized difficulty = 0.67 = 67% *)
			percentRot*: REAL;
			
			(* Time of first UD = 1488970800 s = 2017/03/08 11:00:00 UTC+0 *)
			udTime0*,
			
			(* Time of first reevaluation of the UD = 1490094000 s = 2017/03/21 11:00:00 UTC+0 *)
			udReevalTime0*: LONGINT;
			
			(* Time period between two re-evaluation of the UD = 15778800 s = 6 months *)
			dtReeval*,
			
			(* Maximum delay a transaction can wait before being expired for non-writing = 604800 s = 7 days *)
			txWindow*: INTEGER;
			
		END;
	
	CONST
		
		mutexOwner = TRUE;
		
		hasNotLeaved* = -1;
	
	TYPE
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			bnb: INTEGER;
			mTime,
			time: LONGINT;
		END;
		
		(* Factory of Time *)
		TimeFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeaveL = POINTER TO RECORD (B.Data)
			next: B.FilePos;
			joiningBlock, (* Block numbers *)
			leavingBlock: INTEGER;
		END;
		
		(* Factory of JoinAndLeaveL *)
		JoinAndLeaveLFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeave = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			list: B.FilePos; (* JoinAndLeaveL *)
		END;
		
		(* Factory of JoinAndLeave *)
		JoinAndLeaveFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Identity* = POINTER TO RECORD (B.Data)
			pubkey*: Pubkey;
			uid*: String;
			member*: BOOLEAN;
			hash*: Hash;
			block_number*: INTEGER; (* Where the Identity is written *)
			application*, (* Date of last membership application (joiners, actives, leavers) *)
			expires_on*: LONGINT;
			certifiers, (* Index of all certifiers uid, old or present, of this Identity ; B.String -> nothing *)
			certified: B.FilePos; (* Index of all uid, old or present, certified by this Identity ; B.String -> nothing *)
		END;
		
		(* Factory of Identity *)
		IdentityFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Certification* = POINTER TO RECORD (B.Data)
			from*,
			to*: Pubkey;
			block_number*: INTEGER; (* Where the Certification is written *)
			expires_on*: LONGINT;
		END;
		
		(* Factory of Certification *)
		CertificationFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* INTEGER index key *)
		IntKey = POINTER TO RECORD (B.Data)
			ref: INTEGER;
		END;
		
		(* Factory of IntKey *)
		IntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of IntKey *)
		IntKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* LONGINT index key *)
		LIntKey = POINTER TO RECORD (B.Data)
			ref: LONGINT;
		END;
		
		(* Factory of LIntKey *)
		LIntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data) (* # Pubkey! *)
			ref: Pubkey;
		END;
		
		(* Factory of PubKey *)
		PubKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of PubKey *)
		PubKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Hashkey index key *)
		HashKey = POINTER TO RECORD (B.Data)
			ref: Hash;
		END;
		
		(* Factory of HashKey *)
		HashKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of HashKey *)
		HashKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Uid index key manager *)
		UidKeyMan = POINTER TO RECORD (B.StringKeyManager) 
		END;
		
		(* Manager of Identity sorted by expiration dates *)
		IdKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Manager of Certification sorted by expiration dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Current position in a Certification sub-index *)
		CertPos* = RECORD
			posRef: B.FilePos; (* Root of the sub-index *)
			posCur: B.IndexPos; (* Position in the sub-index *)
		END;
		
		(* Member, Members, MembersFind: Distance Rule *)
		Member = RECORD
			p: Pubkey;
			links: U.Set;
		END;
		
		Members = POINTER TO ARRAY OF Member;
		
		MembersFind = RECORD (UtilSort.T)
			len: INTEGER;
			m: Members;
		END;
		
		Pubkeys = POINTER TO ARRAY OF Pubkey;
		
		PoSE = POINTER TO RECORD (A.Elem)
			pubkeys: Pubkeys;
			set_1,
			set_2: U.Set;
			poS: REAL;
		END;
	
	CONST
		
		(* Sizes of keys *)
		timeKeyS = B.INS;
		idTimeKeyS = B.LIS;
		certTimeKeyS = B.LIS;
	
	VAR
		
		lg: UtilLog.Log;
		
		mutex: UtilMutex.Mutex;
		
		updateList: UpdateList; (* Head of general UpdateList *)
		dispatch: DispatchAction;
		inAction,
		firstUpdate,
		startUpdate: BOOLEAN;
		
		actionQ: ActionQueue;
		
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		joinAndLeaveT, (* PubKey -> JoinAndLeave *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		idHashT, (* HashKey -> Identity *)
		certFromT, certToT: B.Index; (* PubKey -> sub-index(PubKey -> Certification) *)
		
		(* Sentries & Distance Rule *)
		members: MembersFind;
		sentriesS: U.Set; (* Set of sentries *)
		sentriesI: U.SetIterator; (* Iterator of sentriesS *)
		poST: A.Tree;
		
		(* Current positions in indexes *)
		jlPubkeyCur,
		idPubkeyCur,
		idUidCur,
		certFromCur,
		certToCur: B.IndexPos;
		sentryCur: INTEGER;
		
		lastBlock: INTEGER; (* Last read & updated block *)
		now, rNow: LONGINT; (* Present medianTime and time *)
		idLenM: INTEGER; (* Number of members *)
		
		(* Factories *)
		timeFac: TimeFac;
		joinAndLeaveLFac: JoinAndLeaveLFac;
		joinAndLeaveFac: JoinAndLeaveFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		hashKeyFac: HashKeyFac;
		
		(* Data managers *)
		timeMan,
		joinAndLeaveLMan,
		joinAndLeaveMan,
		idMan,
		certMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: UidKeyMan;
		hashKeyMan: HashKeyMan;
		intKeyMan: IntKeyMan;
	
	(* Standard managing procedures for ActionQueue *)
	
	PROCEDURE (VAR q: ActionQueue) Init, NEW;
		
		BEGIN (*Init*)
			q.end := NIL;
		END Init;
	
	PROCEDURE (IN q: ActionQueue) IsEmpty (): BOOLEAN, NEW;
		
		BEGIN (*IsEmpty*)
			RETURN q.end = NIL;
		END IsEmpty;
	
	PROCEDURE (VAR q: ActionQueue) Put (a: Action), NEW;
		
		BEGIN (*Put*)
			IF q.end = NIL THEN
				q.end := a;
				a.next := a;
			ELSE
				a.next := q.end.next;
				q.end.next := a;
				q.end := a;
			END;
		END Put;
	
	PROCEDURE (VAR q: ActionQueue) Get (OUT a: Action), NEW;
		
		BEGIN (*Get*)
			ASSERT(q.end # NIL, 100);
			a := q.end.next;
			q.end.next := a.next;
			IF q.end = a THEN
				q.end := NIL;
			END;
		END Get;
	
	PROCEDURE (a: Action) Activate*, NEW, ABSTRACT;
	
	PROCEDURE (p1: PoSE) Compare (p2: A.Elem): BYTE;
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*Compare*)
			WITH p2: PoSE DO
				IF LEN(p1.pubkeys) < LEN(p2.pubkeys) THEN
					RETURN BA.lt;
				END;
				IF LEN(p1.pubkeys) > LEN(p2.pubkeys) THEN
					RETURN BA.gt;
				END;
				FOR i := 0 TO LEN(p1.pubkeys) - 1 DO
					IF p1.pubkeys[i]$ < p2.pubkeys[i]$ THEN
						RETURN BA.lt;
					END;
					IF p1.pubkeys[i]$ > p2.pubkeys[i]$ THEN
						RETURN BA.gt;
					END;
				END;
				RETURN BA.eq;
			END;
		END Compare;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
			t.time := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
			w.OutLInt(t.time);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (jlL: JoinAndLeaveL) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jlL.next := r.InLInt();
			jlL.joiningBlock := r.InInt();
			jlL.leavingBlock := r.InInt();
		END Read;
	
	PROCEDURE (jlL: JoinAndLeaveL) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutLInt(jlL.next);
			w.OutInt(jlL.joiningBlock);
			w.OutInt(jlL.leavingBlock);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveLFac) New (size: INTEGER): JoinAndLeaveL;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*New*)
			NEW(jlL);
			RETURN jlL;
		END New;
	
	PROCEDURE (jl: JoinAndLeave) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(jl.pubkey);
			jl.list := r.InLInt();
		END Read;
	
	PROCEDURE (jl: JoinAndLeave) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(jl.pubkey);
			w.OutLInt(jl.list);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveFac) New (size: INTEGER): JoinAndLeave;
		
		VAR
			
			jl: JoinAndLeave;
		
		BEGIN (*New*)
			NEW(jl);
			RETURN jl;
		END New;
	
	PROCEDURE (id: Identity) Read- (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(id.pubkey);
			NEW(id.uid, r.InCharsLen() + 1); r.InChars(id.uid);
			id.member := r.InBool();
			r.InChars(id.hash);
			id.block_number := r.InInt();
			id.application := r.InLInt();
			id.expires_on := r.InLInt();
			id.certifiers := r.InLInt();
			id.certified := r.InLInt();
		END Read;
	
	PROCEDURE (id: Identity) Write- (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(id.pubkey);
			w.OutChars(id.uid);
			w.OutBool(id.member);
			w.OutChars(id.hash);
			w.OutInt(id.block_number);
			w.OutLInt(id.application);
			w.OutLInt(id.expires_on);
			w.OutLInt(id.certifiers);
			w.OutLInt(id.certified);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read- (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write- (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.INS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (l: LIntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.ref := r.InLInt();
		END Read;
	
	PROCEDURE (l: LIntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutLInt(l.ref);
		END Write;
	
	PROCEDURE (lf: LIntKeyFac) New (size: INTEGER): LIntKey;
		
		VAR
			
			l: LIntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.LIS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (pf: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	PROCEDURE (hash: HashKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(hash.ref);
		END Read;
	
	PROCEDURE (hash: HashKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(hash.ref);
		END Write;
	
	PROCEDURE (hf: HashKeyFac) New (size: INTEGER): HashKey;
		
		VAR
			
			hash: HashKey;
		
		BEGIN (*New*)
			NEW(hash);
			IF size = 0 THEN
				hash.ref := "";
			END;
			RETURN hash;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			ASSERT(PKMCompP(p1, p2) = B.lt, 21);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	PROCEDURE HKMCompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*HKMCompP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					IF h1.ref < h2.ref THEN
						RETURN B.lt;
					END;
					IF h1.ref > h2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END HKMCompP;
	
	PROCEDURE (hm: HashKeyMan) CompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN HKMCompP(h1, h2);
		END CompP;
	
	PROCEDURE (hm: HashKeyMan) PrefP (h1: B.Data; VAR h2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			h: HashKey;
		
		BEGIN (*PrefP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			ASSERT(HKMCompP(h1, h2) = B.lt, 21);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					l2 := LEN(h2.ref$);
					NEW(h);
					l := 0;
					h.ref[l] := 0X;
					WHILE (l <= l2) & ~((HKMCompP(h1, h) = B.lt) & (HKMCompP(h, h2) <= B.eq)) DO
						h.ref[l] := h2.ref[l];
						INC(l);
						h.ref[l] := 0X;
					END;
				END;
			END;
			h2 := h;
		END PrefP;
	
	(* Comparison method of two Strings. Use the lexical order. *)
	PROCEDURE (um: UidKeyMan) CompP (key1, key2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			ASSERT((key1 # NIL) & (key2 # NIL), 20);
			WITH key1: B.String DO
				WITH key2: B.String DO
					IF key1.c = NIL THEN
						IF key2.c = NIL THEN
							RETURN B.eq;
						END;
						RETURN B.lt;
					END;
					IF key2.c = NIL THEN
						RETURN B.gt;
					END;
					RETURN BA.CompP(key1.c, key2.c);
				END;
			END;
		END CompP;
	
	(* Comparison of Identity(s) by expiration dates *)
	PROCEDURE (im: IdKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			id1, id2: Identity;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				id1 := idMan.ReadData(l1.ref)(Identity);
			END;
			WITH l2: LIntKey DO
				id2 := idMan.ReadData(l2.ref)(Identity);
			END;
			IF ABS(id1.expires_on) < ABS(id2.expires_on) THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired identities *)
			END;
			IF ABS(id1.expires_on) > ABS(id2.expires_on) THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ < id2.pubkey$ THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ > id2.pubkey$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* Comparison of Certification(s) by expiration dates *)
	PROCEDURE (im: CertKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				c1 := certMan.ReadData(l1.ref)(Certification);
			END;
			WITH l2: LIntKey DO
				c2 := certMan.ReadData(l2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired certifications *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	PROCEDURE (VAR m: MembersFind) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN m.m[i].p < m.m[j].p;
		END Less;
	
	PROCEDURE FindMemberNum (p: Pubkey; OUT n: INTEGER): BOOLEAN;
		
		BEGIN (*FindMemberNum*)
			n := members.len;
			members.m[n].p := p;
			members.BinSearch(0, n - 1, n);
			RETURN n < members.len;
		END FindMemberNum;
	
	(* Last written block *)
	PROCEDURE LastBlock* (): INTEGER;
		
		BEGIN (*LastBlock*)
			RETURN lastBlock;
		END LastBlock;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* time *)
	PROCEDURE RealNow* (): LONGINT;
		
		BEGIN (*RealNow*)
			RETURN rNow;
		END RealNow;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b, 100);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL, 101);
					database.WritePlace(timePlace, database.CreateIndex(timeKeyS));
					database.WritePlace(joinAndLeavePlace, database.CreateIndex(0));
					database.WritePlace(idPubPlace, database.CreateIndex(0));
					database.WritePlace(idUidPlace, database.CreateIndex(0));
					database.WritePlace(idHashPlace, database.CreateIndex(0));
					database.WritePlace(idTimePlace, database.CreateIndex(idTimeKeyS));
					database.WritePlace(certFromPlace, database.CreateIndex(0));
					database.WritePlace(certToPlace, database.CreateIndex(0));
					database.WritePlace(certTimePlace, database.CreateIndex(certTimeKeyS));
					database.WritePlace(undoListPlace, B.bNil);
					database.WritePlace(lastNPlace, - 1);
					database.WritePlace(idLenPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				joinAndLeaveLMan := database.CreateDataMan(joinAndLeaveLFac);
				joinAndLeaveMan := database.CreateDataMan(joinAndLeaveFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				joinAndLeaveT := database.OpenIndex(database.ReadPlace(joinAndLeavePlace), pubKeyMan, pubKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				idHashT := database.OpenIndex(database.ReadPlace(idHashPlace), hashKeyMan, hashKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf* (bnb: INTEGER; OUT mTime, time: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				time := t.time;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPub* (IN pubkey: Pubkey; OUT list: B.FilePos): BOOLEAN;
		
		VAR
			
			jl: JoinAndLeave;
			jlP: PubKey;
		
		BEGIN (*JLPub*)
			NEW(jlP);
			jlP.ref := pubkey;
			IF joinAndLeaveT.Search(jlP) THEN
				jl := joinAndLeaveMan.ReadData(joinAndLeaveT.ReadValue())(JoinAndLeave);
				list := jl.list;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END JLPub;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPubLNext* (VAR list: B.FilePos; OUT joiningBlock, leavingBlock: INTEGER): BOOLEAN;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*JLPubLNext*)
			IF list = B.bNil THEN
				RETURN FALSE;
			END;
			jlL := joinAndLeaveLMan.ReadData(list)(JoinAndLeaveL);
			list := jlL.next;
			joiningBlock := jlL.joiningBlock;
			leavingBlock := jlL.leavingBlock;
			RETURN TRUE;
		END JLPubLNext;
	
	(* Number of JoinAndLeave *)
	PROCEDURE JLLen* (): INTEGER;
		
		BEGIN (*JLLen*)
			RETURN joinAndLeaveT.NumberOfKeys();
		END JLLen;
	
	(* Browse all JoinAndLeave's pubkeys step by step *)
	PROCEDURE JLNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*JLNextPubkey*)
			IF first THEN
				joinAndLeaveT.ResetPos;
			ELSE
				joinAndLeaveT.SetCurrPos(jlPubkeyCur);
			END;
			joinAndLeaveT.Next;
			jlPubkeyCur := joinAndLeaveT.GetCurrPos();
			IF ~joinAndLeaveT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := joinAndLeaveT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END JLNextPubkey;
	
	(* Pubkey -> uid *)
	PROCEDURE IdPubId* (IN pubkey: Pubkey): Identity;
		
		VAR
			
			idP: PubKey;
		
		BEGIN (*IdPubId*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				RETURN idMan.ReadData(idPubT.ReadValue())(Identity);
			END;
			RETURN NIL;
		END IdPubId;
	
	(* Pubkey -> uid *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdPub*)
			id := IdPubId(pubkey);
			IF id # NIL THEN
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* Pubkey -> uid of member *)
	PROCEDURE IdPubM* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdPubM*)
			id := IdPubId(pubkey);
			IF (id # NIL) & id.member THEN
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubM;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPubComplete* (IN pubkey: Pubkey; OUT uid: String; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT application, expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdPubComplete*)
			id := IdPubId(pubkey);
			IF id # NIL THEN
				uid := id.uid;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				application := id.application;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubComplete;
	
	(* uid -> Pubkey *)
	PROCEDURE IdUidId* (IN uid: ARRAY OF CHAR): Identity;
		
		VAR
			
			idU: B.String;
		
		BEGIN (*IdUidId*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				RETURN idMan.ReadData(idUidT.ReadValue())(Identity);
			END;
			RETURN NIL;
		END IdUidId;
	
	(* uid -> Pubkey *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdUid*)
			id := IdUidId(uid);
			IF id # NIL THEN
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* uid -> Pubkey of member *)
	PROCEDURE IdUidM* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdUidM*)
			id := IdUidId(uid);
			IF (id # NIL) & id.member THEN
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUidM;
	
	(* uid -> Identity *)
	PROCEDURE IdUidComplete* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT application, expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdUidComplete*)
			id := IdUidId(uid);
			IF id # NIL THEN
				pubkey := id.pubkey;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				application := id.application;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUidComplete;
	
	(* Hash -> pubkey *)
	PROCEDURE IdHashId* (IN hash: Hash): Identity;
		
		VAR
			
			idH: HashKey;
		
		BEGIN (*IdHashId*)
			NEW(idH);
			idH.ref := hash;
			IF idHashT.Search(idH) THEN
				RETURN idMan.ReadData(idHashT.ReadValue())(Identity);
			END;
			RETURN NIL;
		END IdHashId;
	
	(* Hash -> pubkey *)
	PROCEDURE IdHash* (IN hash: Hash; OUT pub: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdHash*)
			id := IdHashId(hash);
			IF id # NIL THEN
				pub := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdHash;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idUidT.NumberOfKeys();
		END IdLen;
	
	(* Number of members *)
	PROCEDURE IdLenM* (): INTEGER;
		
		BEGIN (*IdLenM*)
			RETURN idLenM;
		END IdLenM;
	
	(* Position next Identity's pubkey for IdNextPubkey *)
	PROCEDURE IdPosPubkey* (IN pubkey: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
		
		BEGIN (*IdPosPubkey*)
			NEW(idP);
			idP.ref := pubkey;
			b := idPubT.Search(idP);
			idPubT.Previous;
			idPubkeyCur := idPubT.GetCurrPos();
		END IdPosPubkey;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			idPubT.Next;
			idPubkeyCur := idPubT.GetCurrPos();
			IF ~idPubT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := idPubT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Browse all members' pubkeys step by step *)
	PROCEDURE IdNextPubkeyM* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextPubkeyM*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			REPEAT
				idPubT.Next;
				IF ~idPubT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
			UNTIL id.member;
			idPubkeyCur := idPubT.GetCurrPos();
			pubkey := id.pubkey;
			RETURN TRUE;
		END IdNextPubkeyM;
	
	(* Position next Identity's uid for IdNextUid *)
	PROCEDURE IdPosUid* (IN uid: ARRAY OF CHAR);
		
		VAR
			
			idU: B.String;
			b: BOOLEAN;
		
		BEGIN (*IdPosUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			b := idUidT.Search(idU);
			idUidT.Previous;
			idUidCur := idUidT.GetCurrPos();
		END IdPosUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			idUidT.Next;
			idUidCur := idUidT.GetCurrPos();
			IF ~idUidT.PosSet() THEN
				RETURN FALSE;
			END;
			uid := idUidT.CurrentKey()(B.String).c;
			RETURN TRUE;
		END IdNextUid;
	
	(* Browse all members' uid(s) lexicographically step by step *)
	PROCEDURE IdNextUidM* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextUidM*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			REPEAT
				idUidT.Next;
				IF ~idUidT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
			UNTIL id.member;
			idUidCur := idUidT.GetCurrPos();
			uid := id.uid;
			RETURN TRUE;
		END IdNextUidM;
	
	(* (Pubkey, Pubkey) -> Certification *)
	PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertFrom*)
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				pos.posRef := certFromT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertFrom;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertTo* (IN to: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertTo*)
			NEW(p);
			p.ref := to;
			IF certToT.Search(p) THEN
				pos.posRef := certToT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertTo;
	
	(* Number of keys in sub-index *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		VAR
			
			ind: B.Index;
			n: INTEGER;
		
		BEGIN (*CertPosLen*)
			IF pos.posRef < 0 THEN
				RETURN 0;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			n := ind.NumberOfKeys();
			ind.Close;
			RETURN n;
		END CertPosLen;
	
	(* Browse all Certification's pairs of Pubkey in a sub-index step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from, to: Pubkey): BOOLEAN, NEW;
		
		VAR
			
			ind: B.Index;
			ok: BOOLEAN;
			c: Certification;
		
		BEGIN (*CertNextPos*)
			IF pos.posRef < 0 THEN
				RETURN FALSE;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.SetCurrPos(pos.posCur);
			ind.Next;
			pos.posCur := ind.GetCurrPos();
			ok := ind.PosSet();
			IF ok THEN
				c := certMan.ReadData(ind.ReadValue())(Certification);
				from := c.from;
				to := c.to;
			END;
			ind.Close;
			RETURN ok;
		END CertNextPos;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the from Pubkey *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromT.ResetPos;
			ELSE
				certFromT.SetCurrPos(certFromCur);
			END;
			certFromT.Next;
			certFromCur := certFromT.GetCurrPos();
			IF ~certFromT.PosSet() THEN
				pos.posRef := - 1;
				RETURN FALSE;
			END;
			pos.posRef := certFromT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the to Pubkey *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextTo*)
			IF first THEN
				certToT.ResetPos;
			ELSE
				certToT.SetCurrPos(certToCur);
			END;
			certToT.Next;
			certToCur := certToT.GetCurrPos();
			IF ~certToT.PosSet() THEN
				pos.posRef := - 1;
				RETURN FALSE;
			END;
			pos.posRef := certToT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextTo;
	
	PROCEDURE AllCertifiers* (IN to: ARRAY OF CHAR; OUT from: StringArr);
		
		VAR
			
			idU: B.String;
			id: Identity;
			ind: B.Index;
			i: INTEGER;
		
		BEGIN (*AllCertifiers*)
			NEW(idU);
			NEW(idU.c, LEN(to$) + 1); idU.c^ := to$;
			IF ~idUidT.Search(idU) THEN
				from := NIL;
				RETURN;
			END;
			id := idMan.ReadData(idUidT.ReadValue())(Identity);
			IF id.certifiers = B.bNil THEN
				from := NIL;
				RETURN;
			END;
			ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
			NEW(from, ind.NumberOfKeys());
			ind.Next; i := 0;
			WHILE ind.PosSet() DO
				idU := ind.CurrentKey()(B.String);
				from[i] := idU.c;
				INC(i);
				ind.Next;
			END;
			ind.Close;
			ASSERT(i = LEN(from), 60);
		END AllCertifiers;
	
	PROCEDURE AllCertified* (IN from: ARRAY OF CHAR; OUT to: StringArr);
		
		VAR
			
			idU: B.String;
			id: Identity;
			ind: B.Index;
			i: INTEGER;
		
		BEGIN (*AllCertified*)
			NEW(idU);
			NEW(idU.c, LEN(from$) + 1); idU.c^ := from$;
			IF ~idUidT.Search(idU) THEN
				to := NIL;
				RETURN;
			END;
			id := idMan.ReadData(idUidT.ReadValue())(Identity);
			IF id.certified = B.bNil THEN
				to := NIL;
				RETURN;
			END;
			ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
			NEW(to, ind.NumberOfKeys());
			ind.Next; i := 0;
			WHILE ind.PosSet() DO
				idU := ind.CurrentKey()(B.String);
				to[i] := idU.c;
				INC(i);
				ind.Next;
			END;
			ind.Close;
			ASSERT(i = LEN(to), 60);
		END AllCertified;
	
	PROCEDURE IsSentry* (IN pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			e: INTEGER;
		
		BEGIN (*IsSentry*)
			RETURN FindMemberNum(pubkey, e) & sentriesS.In(e);
		END IsSentry;
	
	(* Return in pubkey the next sentry's pubkey if ~first or the first one if first; return FALSE if there is no more sentry *)
	PROCEDURE NextSentry* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*NextSentry*)
			IF first THEN
				b := sentriesI.FirstE(sentryCur);
			ELSE
				b := sentriesI.NextE(sentryCur);
			END;
			IF ~b THEN
				RETURN FALSE;
			END;
			pubkey := members.m[sentryCur].p;
			RETURN TRUE;
		END NextSentry;
	
	(* Return the number of sentries *)
	PROCEDURE SentriesLen* (): INTEGER;
		
		BEGIN (*SentriesLen*)
			RETURN sentriesS.nbElems;
		END SentriesLen;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentriesS* (IN pubkeys: ARRAY OF Pubkey; OUT set_1, set_2: U.Set): REAL;
		
		VAR
			
			set, frontier, newFrontier: U.Set;
			frontierI: U.SetIterator;
			e, i: INTEGER;
			ok: BOOLEAN;
			poS: REAL;
			poSE: PoSE;
		
		PROCEDURE Sort (pubkeys: ARRAY OF Pubkey);
			
			VAR
				
				i, j: INTEGER;
				p: Pubkey;
			
			BEGIN (*Sort*)
				FOR i := 1 TO LEN(pubkeys) - 1 DO
					p := pubkeys[i];
					j := i;
					WHILE (j > 0) & (p < pubkeys[j - 1]) DO
						pubkeys[j] := pubkeys[j - 1];
						DEC(j);
					END;
					pubkeys[j] := p;
				END;
			END Sort;
		
		PROCEDURE Find (poSE: PoSE; OUT set_1, set_2: U.Set; OUT poS: REAL): BOOLEAN;
			
			VAR
				
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Find*)
				e := poSE;
				IF ~poST.Search(e, n) THEN
					RETURN FALSE;
				END;
				WITH e: PoSE DO
					set_1 := e.set_1;
					set_2 := e.set_2;
					poS := e.poS;
				END;
				RETURN TRUE;
			END Find;
		
		PROCEDURE Store (poSE: PoSE; set_1, set_2: U.Set; poS: REAL);
			
			VAR
				
				b: BOOLEAN;
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Store*)
				poSE.set_1 := set_1;
				poSE.set_2 := set_2;
				poSE.poS := poS;
				e := poSE;
				b := poST.SearchIns(e, n); ASSERT(~b, 100);
			END Store;
		
		BEGIN (*PercentOfSentriesS*)
			Sort(pubkeys);
			NEW(poSE);
			NEW(poSE.pubkeys, LEN(pubkeys));
			FOR i := 0 TO LEN(pubkeys) - 1 DO
				poSE.pubkeys[i] := pubkeys[i];
			END;
			IF ~Find(poSE, set_1, set_2, poS) THEN
				set := U.NewSet();
				frontier := U.NewSet();
				FOR i := 0 TO LEN(pubkeys) - 1 DO
					IF FindMemberNum(pubkeys[i], e) THEN
						set.Incl(e);
						frontier.Incl(e);
					END;
				END;
				FOR i := 1 TO pars.stepMax - 1 DO
					newFrontier := U.NewSet();
					frontierI.Attach(frontier);
					ok := frontierI.FirstE(e);
					WHILE ok DO
						newFrontier.Add(members.m[e].links);
						ok := frontierI.NextE(e);
					END;
					frontier := newFrontier;
					set.Add(frontier);
					IF i = pars.stepMax - 2 THEN
						set_2 := set.Inter(sentriesS);
					END;
				END;
				set_1 := set.Inter(sentriesS);
				IF sentriesS.nbElems = 0 THEN
					poS := 0;
				ELSE
					poS := set_1.nbElems / sentriesS.nbElems;
				END;
				Store(poSE, set_1, set_2, poS);
			END;
			RETURN poS;
		END PercentOfSentriesS;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentries* (IN pubkeys: ARRAY OF Pubkey): REAL;
		
		VAR
			
			set: U.Set;
		
		BEGIN (*PercentOfSentries*)
			RETURN PercentOfSentriesS(pubkeys, set, set);
		END PercentOfSentries;
	
	(* Verify the distance rule for a set of certifiers' pubkeys *)
	PROCEDURE DistanceRuleOk* (IN pubkeys: ARRAY OF Pubkey): BOOLEAN;
		
		BEGIN (*DistanceRuleOk*)
			RETURN PercentOfSentries(pubkeys) >= pars.xpercent;
		END DistanceRuleOk;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params;
		
		VAR
			
			j: J.Json;
		
		BEGIN (*Params*)
			NEW(pars);
			j := J.ReadFile(dDir, dPars); ASSERT(j # NIL, 100);
			j.ApplyTo(pars);
		END Params;
	
	(* Initialize members and sentriesS / sentriesI *)
	PROCEDURE CalculateSentries;
		
		VAR
			
			ok, b: BOOLEAN;
			pos: CertPos;
			p, to: Pubkey;
			i, e, n: INTEGER;
		
		BEGIN (*CalculateSentries*)
			members.len := IdLen();
			NEW(members.m, members.len + 1);
			i := 0;
			ok := IdNextPubkey(TRUE, p);
			WHILE ok DO
				ASSERT((i = 0) OR (p > members.m[i - 1].p), 100);
				members.m[i].p := p;
				members.m[i].links := U.NewSet();
				INC(i);
				ok := IdNextPubkey(FALSE, p);
			END;
			ASSERT(i = members.len, 101);
			FOR i := 0 TO members.len - 1 DO
				ok := CertTo(members.m[i].p, pos) & pos.CertNextPos(p, to);
				WHILE ok DO
					b := FindMemberNum(p, e); ASSERT(b, 102);
					members.m[i].links.Incl(e);
					ok := pos.CertNextPos(p, to);
				END;
			END;
			
			sentriesS := U.NewSet(); sentriesI.Attach(sentriesS);
			n := IdLenM();
			IF n = 0 THEN RETURN END;
			n := SHORT(ENTIER(Math.Ceiling(Math.Power(n, 1 / pars.stepMax))));
			ok := IdNextPubkeyM(TRUE, p);
			WHILE ok DO
				IF CertFrom(p, pos) & (pos.CertPosLen() >= n) & CertTo(p, pos) & (pos.CertPosLen() >= n) THEN
					b := FindMemberNum(p, e); ASSERT(b, 103);
					sentriesS.Incl(e);
				END;
				ok := IdNextPubkeyM(FALSE, p);
			END;
			
			A.New(poST);
		END CalculateSentries;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*ScanBlocks*)
			idLenM := SHORT(database.ReadPlace(idLenPlace));
			lastBlock := SHORT(database.ReadPlace(lastNPlace));
			b := TimeOf(lastBlock, now, rNow); ASSERT(b, 100);
			CalculateSentries; (* Change to lazy call ? *)
		END ScanBlocks;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			IF l = NIL THEN
				NEW(l);
				l.next := NIL;
				l.update := updateProc;
				IF m = NIL THEN
					updateList := l;
				ELSE
					m.next := l;
				END;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			IF l # NIL THEN
				IF m = NIL THEN
					updateList := l.next;
				ELSE
					m.next := l.next;
				END;
			END;
		END RemoveUpdateProc;
	
	PROCEDURE UpdateReady (): BOOLEAN;
		
		BEGIN (*UpdateReady*)
			IF BA.Check(dDir, dSyncName) THEN
				BA.SwitchOff(dDir, dSyncName);
				RETURN TRUE;
			END;
			RETURN FALSE;
		END UpdateReady;
	
	PROCEDURE UpdateAll;
		
		VAR
			
			l: UpdateList;
		
		BEGIN (*UpdateAll*)
			OpenB;
			l := updateList;
			WHILE l # NIL DO
				l.update;
				l := l.next;
			END;
			CloseB;
			BA.Collect;
		END UpdateAll;
	
	PROCEDURE ShowUpdated;
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			l: Files.Locator;
		
		BEGIN (*ShowUpdated*)
			J.StartObject;
			J.PushInteger(LastBlock());
			J.BuildField("last_block");
			J.BuildObject;
			t := TextModels.dir.New();
			f.ConnectTo(t);
			J.GetJson().Write(f);
			l := Files.dir.This(dDir); ASSERT(l.res = 0, 100);
			BA.VRegister(TextViews.dir.New(t), l, updtStatusName, 101, "Blockchain.ShowUpdated");
		END ShowUpdated;
	
	PROCEDURE AddAction* (a: Action);
		
		BEGIN (*AddAction*)
			lg.Msg("Adding action into queue");
			actionQ.Put(a);
		END AddAction;
	
	PROCEDURE ActionDone (data: ANYPTR; done: BOOLEAN);
		
		BEGIN (*ActionDone*)
			IF done THEN
				inAction := FALSE;
			END;
		END ActionDone;
	
	PROCEDURE EndUpdate (datas: ANYPTR; done: BOOLEAN);
		
		BEGIN (*EndUpdate*)
			IF done THEN
				IF firstUpdate THEN
					Params;
					firstUpdate := FALSE;
				END;
				UpdateAll;
				mutex.Unlock(ActionDone, NIL);
				ShowUpdated;
				lg.Msg("Update done"); lg.Msg("");
			END;
		END EndUpdate;
	
	PROCEDURE EndInit (data: ANYPTR; done: BOOLEAN);
		
		BEGIN (*EndInit*)
			IF done THEN
				startUpdate := FALSE;
				Params;
				UpdateAll;
				mutex.Unlock(ActionDone, NIL);
				lg.Msg("First update done"); lg.Msg("");
			END;
		END EndInit;
	
	PROCEDURE EndActivate (data: ANYPTR; done: BOOLEAN);
		
		BEGIN (*EndActivate*)
			IF done THEN
				OpenB;
				data(Action).Activate;
				CloseB;
				mutex.Unlock(ActionDone, NIL);
				lg.Msg("Action done"); lg.Msg("");
			END;
		END EndActivate;
	
	PROCEDURE (d: DispatchAction) Do;
		
		VAR
			
			a: Action;
		
		BEGIN (*Do*)
			IF BA.Check("", stopName) THEN
				BA.SwitchOff("", stopName);
				Services.RemoveAction(dispatch);
				mutex.Stop;
				CloseB;
				lg.Msg("Halting");
				HostMenus.Exit; 
			END;
			IF ~inAction THEN
				IF UpdateReady() THEN
					lg.Msg("Starting update");
					inAction := TRUE;
					mutex.Lock(EndUpdate, NIL);
				ELSIF startUpdate THEN
					lg.Msg("Starting first update");
					inAction := TRUE;
					mutex.Lock(EndInit, NIL);
				ELSIF ~actionQ.IsEmpty() & ~firstUpdate THEN
					lg.Msg("Starting action");
					inAction := TRUE;
					actionQ.Get(a);
					mutex.Lock(EndActivate, a);
				END;
			END;
			Services.DoLater(d, Services.Ticks() + dispatchDelay);
		END Do;
	
	PROCEDURE Virgin (): BOOLEAN;
		
		BEGIN (*Virgin*)
			IF BA.Check(dDir, dPars) & BA.Check(dDir, dBaseName) & BA.Check(dDir, sBaseName) THEN
				RETURN FALSE;
			END;
			RETURN TRUE;
		END Virgin;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			lg := BA.lg;
			actionQ.Init;
			inAction := FALSE;
			firstUpdate := Virgin();
			startUpdate := ~firstUpdate;
			updateList := NIL;
			AddUpdateProc(ScanBlocks);
			NEW(timeFac); NEW(joinAndLeaveLFac); NEW(joinAndLeaveFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan);
			NEW(hashKeyFac); NEW(hashKeyMan);
			NEW(intKeyMan);
			mutex := UtilMutex.NewMutex(mutexOwner);
			BA.SwitchOff(dDir, dSyncName);
			NEW(dispatch);
			Services.DoLater(dispatch, Services.Ticks() + dispatchDelay);
			Duniter1GQLReceiver.Start;
		END Init;
	
	BEGIN (*Duniter1Blockchain*)
		Init;
	CLOSE
		Services.RemoveAction(dispatch);
		mutex.Stop;
		CloseB;
	END Duniter1Blockchain.
