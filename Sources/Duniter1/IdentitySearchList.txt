(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1IdentitySearchList;
	
	

	IMPORT
		
		(**
		L := StdLog,
		**)
		
		A := UtilAvlTree, B := Duniter1Blockchain, S := Duniter1Sandbox, BA := Duniter1Basic, C := Duniter1CentralitiesStressD, Strings, TextMappers, TextModels, TextViews, J := UtilJson, UtilSort;
	
	CONST
		
		findA = 0;
		fixA = 1;
	
	TYPE
		
		Action = POINTER TO RECORD (B.Action)
			what: INTEGER;
			output: BA.String;
			hash: B.Hash;
			str: B.String;
			b1, b2, b3: BOOLEAN;
		END;
		
		IdE = POINTER TO RECORD (A.Elem)
			uid: BA.String;
			hash: B.Hash;
			limit: LONGINT;
			future,
			active: BOOLEAN;
		END;
		
		Certifiers = POINTER TO ARRAY OF B.Pubkey;
		
		ExpSort = RECORD (UtilSort.T)
			exp: POINTER TO ARRAY OF LONGINT;
		END;
	
	PROCEDURE (VAR e: ExpSort) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN e.exp[i] < e.exp[j];
		END Less;
	
	PROCEDURE (VAR e: ExpSort) Swap (i, j: INTEGER);
		
		VAR
			
			exp: LONGINT;
		
		BEGIN (*Swap*)
			exp := e.exp[i]; e.exp[i] := e.exp[j]; e.exp[j] := exp;
		END Swap;
	
	PROCEDURE (i1: IdE) Compare (i2: A.Elem): BYTE;
		
		VAR
			
			b: BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdE DO
				b := BA.CompP(i1.uid, i2.uid);
				IF b # A.eq THEN
					RETURN b;
				END;
				IF i1.future & ~i2.future THEN
					RETURN A.lt;
				END;
				IF ~i1.future & i2.future THEN
					RETURN A.gt;
				END;
				IF i1.hash < i2.hash THEN
					RETURN A.lt;
				END;
				IF i1.hash > i2.hash THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE DoFind (IN hint: ARRAY OF CHAR; old, mem, fut: BOOLEAN): J.Json;
		
		VAR
			
			t, set: A.Tree;
			idE: IdE;
			e: A.Elem;
			b, ok, active: BOOLEAN;
			uid: BA.String;
			pub, p: B.Pubkey;
			hash: S.Hash;
			exp, app: LONGINT;
			pos, bloc, n, nO, nA, nF: INTEGER;
			hintD: BA.String;
		
		BEGIN (*DoFind*)
			A.New(t); A.New(set);
			hintD := BA.ToDown(hint);
			B.IdPosUid(hintD);
			nO := 0; nA := 0;
			ok := B.IdNextUid(FALSE, uid);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok & B.IdUidComplete(uid, p, active, hash, bloc, app, exp) THEN
					NEW(idE);
					idE.uid := uid; idE.hash := hash;
					e := idE;
					b := set.SearchIns(e, n); ASSERT(~b, 100);
					IF active THEN
						INC(nA);
					ELSE
						INC(nO);
					END;
					IF (old & ~active) OR (mem & active) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := FALSE; idE.active := active;
						e := idE;
						b := t.SearchIns(e, n); ASSERT(~b, 101);
					END;
					ok := B.IdNextUid(FALSE, uid);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				pub := hint$;
				B.IdPosPubkey(pub);
				ok := B.IdNextPubkey(FALSE, p);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok & B.IdPubComplete(p, uid, active, hash, bloc, app, exp) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := FALSE; idE.active := active;
						e := idE;
						IF ~set.Search(e, n) THEN
							IF active THEN
								INC(nA);
							ELSE
								INC(nO);
							END;
						END;
						e := idE;
						b := ((old & ~active) OR (mem & active)) & t.SearchIns(e, n);
						ok := B.IdNextPubkey(FALSE, p);
					END;
				END;
			END;
			nF := 0;
			S.IdPosUid(hintD);
			ok := S.IdNextUid(FALSE, uid, hash);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok THEN
					NEW(idE);
					idE.uid := uid; idE.hash := hash;
					e := idE;
					b := set.SearchIns(e, n); (* ASSERT(~b, 102);*)
					INC(nF);
					IF fut THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := TRUE; idE.active := FALSE;
						e := idE;
						b := t.SearchIns(e, n); ASSERT(~b, 103);
					END;
					ok := S.IdNextUid(FALSE, uid, hash);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				S.IdPosPubkey(pub);
				ok := S.IdNextPubkey(FALSE, p, hash);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok & S.IdHash(hash, b, p, uid, exp) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := TRUE; idE.active := FALSE;
						e := idE;
						IF ~set.Search(e, n) THEN
							INC(nF);
						END;
						e := idE;
						b := fut & t.SearchIns(e, n);
						ok := S.IdNextPubkey(FALSE, p, hash);
					END;
				END;
			END;
			J.StartObject;
			J.PushInteger(nO);
			J.BuildField("nb_old");
			J.PushInteger(nA);
			J.BuildField("nb_member");
			J.PushInteger(nF);
			J.BuildField("nb_future");
			J.StartArray;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					J.StartObject;
					J.PushString(e.uid);
					J.BuildField("uid");
					J.PushString(e.hash);
					J.BuildField("hash");
					J.PushBoolean(e.future);
					J.BuildField("future");
					J.PushBoolean(e.active);
					J.BuildField("active");
					J.BuildObject;
				END;
				e := t.Next(e);
			END;
			J.BuildArray;
			J.BuildField("ids");
			J.BuildObject;
			RETURN J.GetJson();
		END DoFind;
	
	PROCEDURE Certs (IN h: S.Hash; IN pubkey: B.Pubkey; inBC: BOOLEAN; OUT certifiers: Certifiers);
		
		VAR
			
			okB, okS, b, bb, m: BOOLEAN;
			posB: B.CertPos;
			posS: S.CertPos;
			from, to: B.Pubkey;
			i, bnb, n, sentNb, sentFNb, recNb, recFNb: INTEGER;
			exp, app, rCertsLimit: LONGINT;
			uid: BA.String;
			toH: S.Hash;
			p: B.Pubkey;
			t: A.Tree;
			idE: IdE;
			e: A.Elem;
			cert: B.StringArr;
			es: ExpSort;
		
		BEGIN (*Certs*)
			J.StartObject;
			J.StartObject;
			A.New(t);
			IF inBC THEN
				okB := B.CertFrom(pubkey, posB);
				IF okB THEN
					sentNb := posB.CertPosLen();
				ELSE
					sentNb := 0;
				END;
				okS := S.CertFrom(pubkey, posS);
				IF okS THEN
					sentFNb := posS.CertPosLen();
				ELSE
					sentFNb := 0;
				END;
				okB := okB & posB.CertNextPos(from, to);
				WHILE okB DO
					NEW(idE);
					b := B.IdPubComplete(to, idE.uid, m, idE.hash, bnb, app, exp); ASSERT(b, 100);
					idE.future := FALSE;
					b := B.Cert(from, to, bnb, idE.limit); ASSERT(b, 101);
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b, 102);
					okB := posB.CertNextPos(from, to);
				END;
				okS := okS & posS.CertNextPos(from, toH);
				WHILE okS DO
					NEW(idE);
					idE.hash := toH;
					b := S.Cert(from, toH, to, idE.limit) & (B.IdPub(to, idE.uid) OR S.IdHash(toH, bb, p, idE.uid, exp)); ASSERT(b, 103);
					idE.future := TRUE;
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b, 104);
					okS := posS.CertNextPos(from, toH);
				END;
			ELSE
				sentNb := 0;
				sentFNb := 0;
			END;
			J.PushInteger(sentNb);
			J.BuildField("nb_member");
			J.PushInteger(sentFNb);
			J.BuildField("nb_future");
			J.StartArray;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					J.StartObject;
					J.PushString(e.uid);
					J.BuildField("uid");
					J.PushInteger(e.limit);
					J.BuildField("limit");
					J.PushBoolean(e.future);
					J.BuildField("future");
					J.BuildObject;
				END;
				e := t.Next(e);
			END;
			J.BuildArray;
			J.BuildField("partners");
			J.StartArray;
			IF inBC THEN
				b := B.IdPub(pubkey, uid); ASSERT(b, 105);
				B.AllCertified(uid, cert);
				IF cert # NIL THEN
					FOR i := 0 TO LEN(cert) - 1 DO
						J.StartObject;
						J.PushString(cert[i]);
						J.BuildField("cert");
						J.BuildObject;
					END;
				END;
			END;
			J.BuildArray;
			J.BuildField("all_partners");
			J.BuildObject;
			J.BuildField("sent_certs");
			
			J.StartObject;
			A.New(t);
			okB := inBC & B.CertTo(pubkey, posB);
			IF okB THEN
				recNb := posB.CertPosLen();
			ELSE
				recNb := 0;
			END;
			IF inBC THEN
				okS := B.IdPubComplete(pubkey, uid, m, toH, bnb, app, exp) & S.CertTo(toH, posS);
			ELSE
				okS := S.CertTo(h, posS);
			END;
			IF okS THEN
				recFNb := posS.CertPosLen();
			ELSE
				recFNb := 0;
			END;
			IF recNb + recFNb > 0 THEN
				NEW(certifiers, recNb + recFNb);
			END;
			IF recNb >= B.pars.sigQty THEN
				NEW(es.exp, recNb);
			ELSE
				es.exp := NIL;
			END;
			i := 0;
			okB := okB & posB.CertNextPos(from, to);
			WHILE okB DO
				certifiers[i] := from;
				NEW(idE);
				b := B.IdPubComplete(from, idE.uid, m, idE.hash, bnb, app, exp); ASSERT(b, 106);
				idE.future := FALSE;
				b := B.Cert(from, to, bnb, idE.limit); ASSERT(b, 107);
				IF es.exp # NIL THEN
					es.exp[i] := idE.limit;
					INC(i);
				END;
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b, 108);
				okB := posB.CertNextPos(from, to);
			END;
			okS := okS & posS.CertNextPos(from, toH);
			WHILE okS DO
				certifiers[i] := from;
				INC(i);
				NEW(idE);
				b := B.IdPub(from, idE.uid); ASSERT(b, 109);
				idE.hash := toH;
				idE.future := TRUE;
				b := S.Cert(from, toH, p, idE.limit); ASSERT(b, 110);
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b, 111);
				okS := posS.CertNextPos(from, toH);
			END;
			J.PushInteger(recNb);
			J.BuildField("nb_member");
			J.PushInteger(recFNb);
			J.BuildField("nb_future");
			J.StartArray;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					J.StartObject;
					J.PushString(e.uid);
					J.BuildField("uid");
					J.PushInteger(e.limit);
					J.BuildField("limit");
					J.PushBoolean(e.future);
					J.BuildField("future");
					J.BuildObject;
				END;
				e := t.Next(e);
			END;
			J.BuildArray;
			J.BuildField("partners");
			J.StartArray;
			IF inBC THEN
				b := B.IdPub(pubkey, uid); ASSERT(b, 112);
				B.AllCertifiers(uid, cert);
				IF cert # NIL THEN
					FOR i := 0 TO LEN(cert) - 1 DO
						J.StartObject;
						J.PushString(cert[i]);
						J.BuildField("cert");
						J.BuildObject;
					END;
				END;
			END;
			J.BuildArray;
			J.BuildField("all_partners");
			J.BuildObject;
			J.BuildField("received_certs");
			IF es.exp # NIL THEN
				es.QuickSort(0, recNb - 1);
				rCertsLimit := es.exp[recNb - B.pars.sigQty];
			ELSE
				rCertsLimit := - 1;
			END;
			J.PushInteger(rCertsLimit);
			J.BuildField("received_certs_limit");
			J.BuildObject;
		END Certs;
	
	PROCEDURE Get (IN hash: S.Hash; OUT uid: B.String; OUT pubkey: B.Pubkey; OUT block: INTEGER; OUT blockDate, limitDate: LONGINT; OUT inBC, member: BOOLEAN): BOOLEAN;
		
		VAR
			
			app, t: LONGINT;
			h: S.Hash;
			b, bb: BOOLEAN;
		
		BEGIN (*Get*)
			inBC := B.IdHash(hash, pubkey);
			IF inBC THEN
				b := B.IdPubComplete(pubkey, uid, member, h, block, app, limitDate); ASSERT(b, 100);
				b := B.TimeOf(block, blockDate, t); ASSERT(b, 101);
			ELSIF S.IdHash(hash, bb, pubkey, uid, limitDate) THEN
				member := FALSE;
				block := - 1;
				blockDate := - 1;
			ELSE
				RETURN FALSE;
			END;
			RETURN TRUE;
		END Get;
	
	PROCEDURE NotTooFar (IN p: B.Pubkey; member: BOOLEAN; certifiers: POINTER TO ARRAY OF B.Pubkey; OUT proportionOfSentries: REAL): BOOLEAN;
		
		VAR
			
			certs: POINTER TO ARRAY OF B.Pubkey;
			i, j, n: INTEGER;
		
		BEGIN (*NotTooFar*)
			IF certifiers = NIL THEN
				n := 0;
			ELSE
				n := LEN(certifiers);
			END;
			IF member THEN
				INC(n);
				i := 1;
			ELSE
				i := 0;
			END;
			IF n = 0 THEN
				proportionOfSentries := 0.;
				RETURN FALSE;
			END;
			NEW(certs, n);
			IF member THEN
				certs[0] := p;
			END;
			IF certifiers # NIL THEN
				FOR j := 0 TO LEN(certifiers) - 1 DO
					certs[i] := certifiers[j];
					INC(i);
				END;
			END;
			proportionOfSentries := B.PercentOfSentries(certs);
			RETURN proportionOfSentries >= B.pars.xpercent;
		END NotTooFar;
	
	PROCEDURE FixCertNextDate (member: BOOLEAN; IN p: B.Pubkey; OUT date: LONGINT; OUT passed: BOOLEAN);
		
		VAR
			
			pos: B.CertPos;
			ok, b: BOOLEAN;
			from, to: B.Pubkey;
			block_number: INTEGER;
			tm, t, exp: LONGINT;
		
		BEGIN (*FixCertNextDate*)
			passed := member;
			IF member THEN
				date := 0;
				IF B.CertFrom(p, pos) THEN
					ok := pos.CertNextPos(from, to);
					WHILE ok DO
						b := B.Cert(from, to, block_number, exp); ASSERT(b, 100);
						b := B.TimeOf(block_number, tm, t); ASSERT(b, 101);
						date := MAX(date, tm);
						ok := pos.CertNextPos(from, to);
					END;
					INC(date, B.pars.sigPeriod);
					passed := date <= B.Now();
				END;
			ELSE
				date := - 1;
			END;
		END FixCertNextDate;
	
	PROCEDURE CalcQuality (IN p: B.Pubkey; OUT quality: REAL);
		
		VAR
			
			pubs: ARRAY 1 OF B.Pubkey;
		
		BEGIN (*CalcQuality*)
			pubs[0] := p;
			quality := B.PercentOfSentries(pubs);
		END CalcQuality;
	
	PROCEDURE CalcCentrality (IN p: B.Pubkey; inBC: BOOLEAN; OUT centrality: REAL);
		
		BEGIN (*CalcCentrality*)
			IF inBC THEN
				centrality := C.CountOne(p);
			ELSE
				centrality := 0
			END;
		END CalcCentrality;
	
	PROCEDURE DoFix (IN hash: S.Hash; calcDist, calcQual, calcCentr: BOOLEAN): J.Json;
		
		VAR
			
			uid: B.String;
			block: INTEGER;
			inBC, member, sentry, passed, distanceOK: BOOLEAN;
			pubkey: B.Pubkey;
			blockDate, limitDate, availability: LONGINT;
			certifiers: Certifiers;
			distance, quality, centrality: REAL;
		
		BEGIN (*DoFix*)
			J.StartObject;
			IF Get(hash, uid, pubkey, block, blockDate, limitDate, inBC, member) THEN
				J.StartObject;
				J.PushString(hash);
				J.BuildField("hash");
				J.PushString(uid);
				J.BuildField("uid");
				J.PushString(pubkey);
				J.BuildField("pubkey");
				J.PushInteger(block);
				J.BuildField("block");
				J.PushInteger(blockDate);
				J.BuildField("blockDate");
				J.PushInteger(limitDate);
				J.BuildField("limitDate");
				J.PushBoolean(member);
				J.BuildField("member");
				sentry := member & B.IsSentry(pubkey);
				J.PushBoolean(sentry);
				J.BuildField("sentry");
				FixCertNextDate(member, pubkey, availability, passed);
				J.PushInteger(availability);
				J.BuildField("availability");
				J.PushBoolean(passed);
				J.BuildField("passed");
				Certs(hash, pubkey, inBC, certifiers);
				J.BuildField("certifications");
				IF calcDist THEN
					distanceOK := NotTooFar(pubkey, member, certifiers, distance);
					J.PushReal(distance);
					J.PushBoolean(distanceOK);
				ELSE
					J.PushReal(0);
					J.PushBoolean(FALSE);
				END;
				J.Swap;
				J.BuildField("distance");
				J.Swap;
				J.BuildField("distance_ok");
				IF calcQual THEN
					CalcQuality(pubkey, quality);
					J.PushReal(quality);
				ELSE
					J.PushReal(0);
				END;
				J.BuildField("quality");
				IF calcCentr THEN
					CalcCentrality(pubkey, inBC, centrality);
					J.PushReal(centrality);
				ELSE
					J.PushReal(0);
				END;
				J.BuildField("centrality");
				J.BuildObject;
			ELSE
				J.PushNull;
			END;
			J.BuildField("res");
			J.BuildObject;
			RETURN J.GetJson();
		END DoFix;
	
	PROCEDURE Json (j: J.Json; IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Json*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			j.Write(f);
			BA.VRegister(TextViews.dir.New(t), BA.waitLoc, name$, 100, "IdentitySearchList.Json");
		END Json;
	
	PROCEDURE (a: Action) Activate;
		
		BEGIN (*Activate*)
			CASE a.what OF
				|findA:
					Json(DoFind(a.str, a.b1, a.b2, a.b3), a.output);
				|fixA:
					Json(DoFix(a.hash, a.b1, a.b2, a.b3), a.output);
			END;
		END Activate;
	
	PROCEDURE Find* (IN output, hint, old, mem, fut: ARRAY OF CHAR);
		
		VAR
			
			a: Action;
		
		BEGIN (*Find*)
			NEW(a);
			a.what := findA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			NEW(a.str, LEN(hint$) + 1);
			a.str^ := hint$;
			a.b1 := old = "TRUE";
			a.b2 := mem = "TRUE";
			a.b3 := fut = "TRUE";
			B.AddAction(a);
		END Find;
	
	PROCEDURE Fix* (IN output, hash, calcDist, calcQual, calcCentr: ARRAY OF CHAR);
		
		VAR
			
			a: Action;
		
		BEGIN (*Fix*)
			NEW(a);
			a.what := fixA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			a.hash := hash$;
			a.b1 := calcDist = "TRUE";
			a.b2 := calcQual = "TRUE";
			a.b3 := calcCentr = "TRUE";
			B.AddAction(a);
		END Fix;
	
	END Duniter1IdentitySearchList.
