(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1GQLSender;
	
	

	IMPORT
		
		BA := Duniter1BasicPrint, Files, Services, TextMappers, TextModels, TextViews;
	
	CONST
		
		queryDir = "Query";
		queryName = "Query.txt";
		
		waitDelay = 100;
	
	TYPE
		
		ToSend = POINTER TO RECORD
			next: ToSend;
			module,
			procedure,
			params,
			return: BA.String;
		END;
		
		Queue = RECORD
			end: ToSend;
		END;
		
		Action = POINTER TO RECORD (Services.Action)
		END;
		
		WaitFor = POINTER TO RECORD (BA.WaitFor)
		END;
	
	VAR
		
		queue: Queue;
		action: Action;
	
	PROCEDURE (VAR q: Queue) Init, NEW;
		
		BEGIN (*Init*)
			q.end := NIL;
		END Init;
	
	PROCEDURE (IN q: Queue) IsEmpty (): BOOLEAN, NEW;
		
		BEGIN (*IsEmpty*)
			RETURN q.end = NIL;
		END IsEmpty;
	
	PROCEDURE (VAR q: Queue) Put (ts: ToSend), NEW;
		
		BEGIN (*Put*)
			IF q.end = NIL THEN
				q.end := ts;
				ts.next := ts;
			ELSE
				ts.next := q.end.next;
				q.end.next := ts;
				q.end := ts;
			END;
		END Put;
	
	PROCEDURE (VAR q: Queue) Get (OUT ts: ToSend), NEW;
		
		BEGIN (*Get*)
			ASSERT(q.end # NIL, 100);
			ts := q.end.next;
			q.end.next := ts.next;
			IF q.end = ts THEN
				q.end := NIL;
			END;
		END Get;
	
	PROCEDURE (w: WaitFor) End (IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			l: Files.Locator;
			ts: ToSend;
		
		BEGIN (*End*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			queue.Get(ts);
			IF ts.return$ = "" THEN
				f.WriteString("{" + ts.module + "{" + ts.procedure);
			ELSE
				f.WriteString("{" + ts.return + ":" + ts.module + "{" + ts.procedure);
			END;
			IF ts.params$ # "" THEN
				f.WriteString("(" + ts.params + ")");
			END;
			f.WriteString("}}");
			l := Files.dir.This(queryDir); ASSERT(l.res = 0, 101);
			BA.VRegister(TextViews.dir.New(t), l, name$, 102, "GQLSender.WaitFor.End");
			(**)
			l := Files.dir.This(""); ASSERT(l.res = 0, 103);
			BA.VRegister(TextViews.dir.New(t), l, name$, 104, "GQLSender.WaitFor.End");
			(**)
			Services.DoLater(action, Services.Ticks() + waitDelay);
		END End;
	
	PROCEDURE (a: Action) Do;
		
		VAR
			
			w: WaitFor;
		
		BEGIN (*Do*)
			IF ~queue.IsEmpty() THEN
				NEW(w);
				w.Dont(queryDir, queryName, waitDelay);
			ELSE
				Services.DoLater(action, Services.Ticks() + waitDelay);
			END;
		END Do;
	
	PROCEDURE Send* (IN module, procedure, params, return: ARRAY OF CHAR);
		
		VAR
			
			ts: ToSend;
		
		BEGIN (*Send*)
			NEW(ts);
			NEW(ts.module, LEN(module$) + 1); ts.module^ := module$;
			NEW(ts.procedure, LEN(procedure$) + 1); ts.procedure^ := procedure$;
			NEW(ts.params, LEN(params$) + 1); ts.params^ := params$;
			NEW(ts.return, LEN(return$) + 1); ts.return^ := return$;
			queue.Put(ts);
		END Send;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			queue.Init;
			NEW(action);
			Services.DoLater(action, Services.now);
		END Init;
	
	BEGIN (*Duniter1GQLSender*)
		Init;
	END Duniter1GQLSender.
