(*
Util: Utility tools.

Copyright (C) 2001…2006 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE UtilMutex;
	
	

	IMPORT
		
		Files, Services;
	
	CONST
		
		mutDir = "Util/Mutex";
		mutNameF = "MutexF.odc";
		mutNameT = "MutexT.odc";
		mutNameTurn = "MutexTurn.odc";
		
		delayF = 13;
		delayT = 17;
		
		interestOff = 0;
		interestOn = 1;
		setTurn = 2;
		locked = 3;
		
		ok = 0;
		notFound = 2;
	
	TYPE
		
		Interest = ARRAY 2 OF Files.Name;
		
		Action = POINTER TO RECORD (Services.Action)
			next: Action;
			type: INTEGER;
			m: Mutex;
		END;
		
		FollowProc* = PROCEDURE (data: ANYPTR; done: BOOLEAN);
		
		Mutex* = POINTER TO LIMITED RECORD
			user: BOOLEAN;
			interested: Interest;
			action: Action;
			delay: LONGINT;
			fProc: FollowProc;
			fData: ANYPTR;
		END;
	
	VAR
		
		loc: Files.Locator;
	
	PROCEDURE (m: Mutex) SetInterest (on: BOOLEAN): BOOLEAN, NEW;
		
		VAR
			
			f: Files.File;
			res: INTEGER;
		
		BEGIN (*SetInterest*)
			IF on THEN
				f := Files.dir.New(loc, Files.dontAsk); ASSERT(f # NIL, 100);
				f.Register(m.interested[0], "", Files.dontAsk, res);
				f.Close;
				RETURN res = ok;
			ELSE
				Files.dir.Delete(loc, m.interested[0]);
				RETURN loc.res IN {ok, notFound};
			END;
		END SetInterest;
	
	PROCEDURE (m: Mutex) OtherInterested (): BOOLEAN, NEW;
		
		VAR
			
			fi: Files.FileInfo;
		
		BEGIN (*OtherInterested*)
			fi := Files.dir.FileList(loc);
			WHILE (fi # NIL) & (fi.name # m.interested[1]) DO
				fi := fi.next;
			END;
			RETURN fi # NIL;
		END OtherInterested;
	
	PROCEDURE (m: Mutex) SetOtherTurn (): BOOLEAN, NEW;
		
		VAR
			
			f: Files.File;
			res: INTEGER;
		
		BEGIN (*SetOtherTurn*)
			IF m.user THEN
				Files.dir.Delete(loc, mutNameTurn);
				RETURN loc.res IN {ok, notFound};
			ELSE
				f := Files.dir.New(loc, Files.dontAsk); ASSERT(f # NIL, 101);
				f.Register(mutNameTurn, "", Files.dontAsk, res);
				f.Close;
				RETURN res = 0;
			END;
		END SetOtherTurn;
	
	PROCEDURE (m: Mutex) Turn (): BOOLEAN, NEW;
		
		VAR
			
			fi: Files.FileInfo;
		
		BEGIN (*Turn*)
			fi := Files.dir.FileList(loc);
			WHILE (fi # NIL) & (fi.name # mutNameTurn) DO
				fi := fi.next;
			END;
			RETURN (fi # NIL) = m.user;
		END Turn;
	
	PROCEDURE (m: Mutex) Call (done: BOOLEAN), NEW;
		
		BEGIN (*Call*)
			IF m.fProc # NIL THEN
				m.fProc(m.fData, done);
			END;
		END Call;
	
	PROCEDURE (a: Action) Do;
		
		VAR
			
			t: LONGINT;
			done: BOOLEAN;
		
		BEGIN (*Do*)
			t := Services.Ticks();
			CASE a.type OF
				|interestOff:
					done := a.m.SetInterest(FALSE);
				|interestOn:
					done := a.m.SetInterest(TRUE);
				|setTurn:
					done := a.m.SetOtherTurn();
				|locked:
					done := ~a.m.OtherInterested() OR a.m.Turn();
			END;
			IF ~done THEN
				a.m.Call(FALSE);
				Services.DoLater(a, t + a.m.delay);
			ELSIF a.next # NIL THEN
				a.m.Call(FALSE);
				a := a.next;
				a.m.action := a;
				Services.DoLater(a, Services.immediately);
			ELSE
				a.m.Call(TRUE);
			END;
		END Do;
	
	PROCEDURE Push (VAR actions: Action; type: INTEGER; m: Mutex);
		
		VAR
			
			a: Action;
		
		BEGIN (*Push*)
			NEW(a);
			a.next := actions;
			a.type := type;
			a.m := m;
			actions := a;
		END Push;
	
	PROCEDURE (m: Mutex) Lock* (followProc: FollowProc; followData: ANYPTR), NEW;
		
		VAR
			
			a: Action;
		
		BEGIN (*Lock*)
			m.fProc := followProc;
			m.fData := followData;
			a := NIL;
			Push(a, locked, m);
			Push(a, setTurn, m);
			Push(a, interestOn, m);
			m.action := a;
			Services.DoLater(a, Services.now);
		END Lock;
	
	PROCEDURE (m: Mutex) Unlock* (followProc: FollowProc; followData: ANYPTR), NEW;
		
		VAR
			
			a: Action;
		
		BEGIN (*Unlock*)
			m.fProc := followProc;
			m.fData := followData;
			a := NIL;
			Push(a, interestOff, m);
			m.action := a;
			Services.DoLater(a, Services.now);
		END Unlock;
	
	PROCEDURE NewMutex* (user: BOOLEAN): Mutex;
		
		VAR
			
				m: Mutex;
		
		BEGIN (*NewMutex*)
			NEW(m);
			m.user := user;
			m.action := NIL;
			IF user THEN
				m.interested[0] := mutNameT;
				m.interested[1] := mutNameF;
				m.delay := delayT ;
			ELSE
				m.interested[0] := mutNameF;
				m.interested[1] := mutNameT;
				m.delay := delayF ;
			END;
			REPEAT
			UNTIL m.SetInterest(FALSE);
			RETURN m;
		END NewMutex;
	
	PROCEDURE (m: Mutex) Stop*, NEW;
		
		BEGIN (*Stop*)
			IF m.action # NIL THEN
				Services.RemoveAction(m.action);
			END;
			REPEAT
			UNTIL m.SetInterest(FALSE);
		END Stop;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			loc := Files.dir.This(mutDir); ASSERT(loc.res = 0, 100);
		END Init;
	
	BEGIN (*UtilMutex*)
		Init;
	END UtilMutex.
