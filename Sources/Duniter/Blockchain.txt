(* 
Duniter: WotWizard.

Copyright (C) 2017 Gérard Meunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterBlockchain;
	
	
	
	(* Version with the blockchain's data in a UtilBTree file on disk *)
	
	IMPORT
		
		(*
		StdLog,
		*)
		
		A := UtilAvlTree, B := UtilBBTree, Dates, Dialog, Files, HostFiles, Kernel, Math, Services, S := SqlDB, Strings, TextMappers, TextModels, TextViews, Views;
	
	CONST
		
		driver* = "SQLiteDriver";
		
		(* Directory & name of the file where the path to the Duniter database is written *)
		initDir = "Duniter/Rsrc";
		initName = "Init.odc";
		
		pageNb = 2000; (* Number of pages used by UtilBTree *)
		
		year0 = 1970; month0 = 1; day0 = 1; (* Start date of computing history *)
		
		pubkeyLen* = 44; (* Max length of a Pubkey *)
		
		secureGap = 6; (* Number of last blocks to be read again at every update, since they could have changed *)
		
		dBase = "DBase.data"; (* Name of the WotWizard database, in the WotWizard.exe directory *)
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0;
		joinAndLeavePlace = 1;
		idPubPlace = 2;
		idUidPlace = 3;
		certFromPlace = 4;
		certToPlace = 5;
		certTimePlace = 6;
		
		listPlace = 7; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 8; (* Last read block *)
		
		placeNb = 9; (* Number of places *)
	
	TYPE
		
		UpdateProc* = PROCEDURE; (* Procedure called at every update *)
		
		UpdateList = POINTER TO RECORD (* Chained list of procedures called at every update *)
			next: UpdateList;
			update: UpdateProc;
		END;
	
		UpdateAction = POINTER TO RECORD (Services.Action)
		END;
		
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		String* = POINTER TO ARRAY OF CHAR;
		DateTime* = ARRAY 20 OF CHAR;
		
		Parameters* = RECORD
			c-: REAL;
			dt-,
			ud0-,
			sigPeriod-,
			sigStock-,
			sigWindow-,
			sigValidity-,
			sigQty-,
			idtyWindow-,
			msWindow-,
			msPeriod-: INTEGER;
			xpercent-: REAL;
			msValidity-,
			stepMax-,
			medianTimeBlocks-,
			avgGenTime-,
			dtDiffEval-: INTEGER;
			percentRot-: REAL;
			udTime0-,
			udReevalTime0-,
			dtReeval-,
			txWindow-: INTEGER;
		END;
	
	CONST
		
		timeList = 0;
		joinList = 1;
		leaveList = 2;
		certAddList = 3;
		certRemoveList = 4;
		
		hasNotLeaved* = -1;
	
	TYPE
		
		(* Chained list of the operations to be undone before every update *)
		List = POINTER TO RECORD (B.Data)
			next: INTEGER;
			type: BYTE;
			(* timeList -> Time; joinList, leaveList -> Identity; certAddList, certRemoveList -> Certification *)
			ref: INTEGER;
		END;
		
		ListFac = POINTER TO RECORD (B.DataFac) (* Factory of List *)
		END;
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			bnb: INTEGER;
			mTime,
			time: LONGINT;
		END;
		
		TimeFac = POINTER TO RECORD (B.DataFac) (* Factory of Time *)
		END;
		
		JoinAndLeave = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			joiningBlock, (* Block numbers *)
			leavingBlock: INTEGER;
		END;
		
		JoinAndLeaveFac = POINTER TO RECORD (B.DataFac) (* Factory of JoinAndLeave *)
		END;
		
		Identity = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			uid: String;
			block_number: INTEGER; (* Where the identity is written *)
		END;
		
		IdentityFac = POINTER TO RECORD (B.DataFac) (* Factory of Identity *)
		END;
		
		Certification = POINTER TO RECORD (B.Data)
			from,
			to: Pubkey;
			block_number: INTEGER; (* Where the identity is written *)
			expires_on: LONGINT;
		END;
		
		CertificationFac = POINTER TO RECORD (B.DataFac) (* Factory of Certification *)
		END;
		
		(* Integer index key *)
		IntKey = POINTER TO RECORD (B.Data)
			ref: INTEGER;
		END;
		
		IntKeyFac = POINTER TO RECORD (B.DataFac) (* Factory of IntKey *)
		END;
		
		IntKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data)
			ref: Pubkey;
		END;
		
		PubKeyFac = POINTER TO RECORD (B.DataFac) (* Factory of PubKey *)
		END;
		
		PubKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Manager of Certification sorted by dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Current position in a Certification sub-index *)
		CertPos* = RECORD
			posRef: INTEGER; (* Root of the sub-index *)
			posCur: B.IndexPos; (* Position in the sub-index *)
		END;
		
		(* Element of sentriesT *)
		SentriesE = POINTER TO RECORD (A.Elem)
			pubkey: Pubkey;
		END;
	
	CONST
		
		minDelay = 2 * 60 * Services.resolution; (* Minimum delay between two updates *)
		
		(* Sizes of B.Data *)
		listS = 2 * B.INS + B.BYS;
		timeS = B.INS + 2 * B.LIS;
		pubKeyS = (pubkeyLen + 1) * B.CHS;
		joinAndLeaveS = pubKeyS + 2 * B.INS;
		minIdentityS = pubKeyS + 2 * B.INS; (* Minimal size *)
		certificationS = 2 * pubKeyS + B.INS + B.LIS;
	
	VAR
		
		duniBase-: Files.Name; (* Path to the Duniter database *)
		
		t0: INTEGER; (* Origin of dates *)
		
		updateList: UpdateList; (* Head of UpdateList *)
		update: UpdateAction;
		
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		joinAndLeaveT, (* PubKey -> JoinAndLeave *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		certFromT, certToT, (* PubKey -> sub-index(PubKey -> Certification) *)
		certTimeT: B.Index; (* IntKey -> nothing; addresses of Certification sorted by dates *)
		
		sentriesT: A.Tree; (* AVL tree of sentries *)
		
		list: INTEGER; (* Head of List *)
		
		(* Current positions in indexes *)
		jlPubkeyCur,
		idPubkeyCur,
		idUidCur,
		certFromCur,
		certToCur: B.IndexPos;
		sentryCur: A.Elem;
		
		delay, (* Wished delay between two updates *)
		now, rNow: LONGINT; (* Present medianTime and time *)
		
		(* Factories *)
		listFac: ListFac;
		timeFac: TimeFac;
		joinAndLeaveFac: JoinAndLeaveFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		
		(* Data managers *)
		timeMan,
		joinAndLeaveMan,
		idMan,
		certMan,
		listMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: B.StringKeyManager;
		intKeyMan: IntKeyMan;
		certKTimeMan: CertKTimeMan;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
			t.time := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
			w.OutLInt(t.time);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			ASSERT(size = timeS);
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (jl: JoinAndLeave) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(jl.pubkey);
			jl.joiningBlock := r.InInt();
			jl.leavingBlock := r.InInt();
		END Read;
	
	PROCEDURE (jl: JoinAndLeave) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(jl.pubkey);
			w.OutInt(jl.joiningBlock);
			w.OutInt(jl.leavingBlock);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveFac) New (size: INTEGER): JoinAndLeave;
		
		VAR
			
			jl: JoinAndLeave;
		
		BEGIN (*New*)
			NEW(jl);
			RETURN jl;
		END New;
	
	PROCEDURE (id: Identity) Read (VAR r: B.Reader);
		
		VAR
			
			n: INTEGER;
		
		BEGIN (*Read*)
			r.InChars(id.pubkey);
			n := r.InInt();
			NEW(id.uid, n + 1);
			r.InChars(id.uid);
			id.block_number := r.InInt();
		END Read;
	
	PROCEDURE (id: Identity) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(id.pubkey);
			w.OutInt(LEN(id.uid$));
			w.OutChars(id.uid);
			w.OutInt(id.block_number);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (l: List) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.next := r.InInt();
			l.type := r.InByte();
			l.ref := r.InInt();
		END Read;
	
	PROCEDURE (l: List) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(l.next);
			w.OutByte(l.type);
			w.OutInt(l.ref);
		END Write;
	
	PROCEDURE (lf: ListFac) New (size: INTEGER): List;
		
		VAR
			
			l: List;
		
		BEGIN (*New*)
			ASSERT(size = listS);
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.INS));
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (if: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			ASSERT((size >= 0) & (size <= pubKeyS) & (size MOD B.CHS = 0));
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL));
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL));
			ASSERT(PKMCompP(p1, p2) = B.lt);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	PROCEDURE (im: CertKTimeMan) CompP (i1, i2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH i1: IntKey DO
				c1 := certMan.ReadData(i1.ref)(Certification);
			END;
			WITH i2: IntKey DO
				c2 := certMan.ReadData(i2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* SentriesE comparison procedure *)
	PROCEDURE (s1: SentriesE) Compare (s2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH s2: SentriesE DO
				IF s1.pubkey$ < s2.pubkey$ THEN
					RETURN A.lt;
				END;
				IF s1.pubkey$ > s2.pubkey$ THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* time *)
	PROCEDURE RealNow* (): LONGINT;
		
		BEGIN (*RealNow*)
			RETURN rNow;
		END RealNow;
	
	PROCEDURE TimestampToDate* (t: LONGINT; OUT date: Dates.Date; OUT time: Dates.Time);
		
		BEGIN (*TimestampToDate*)
			time.second := SHORT(t MOD 60); t := t DIV 60;
			time.minute := SHORT(t MOD 60); t := t DIV 60;
			time.hour := SHORT(t MOD 24);
			Dates.DayToDate(SHORT(t DIV 24 + t0), date);
		END TimestampToDate;
	
	PROCEDURE TimestampToString* (t: LONGINT; OUT dt: DateTime);
		
		VAR
			
			ti, da: ARRAY 11 OF CHAR;
			date: Dates.Date;
			time: Dates.Time;
		
		BEGIN (*TimestampToString*)
			TimestampToDate(t, date, time);
			Dates.DateToString(date, Dates.short, da);
			Dates.TimeToString(time, ti);
			dt := da + " " + ti;
		END TimestampToString;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
			n: INTEGER;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL);
					n := database.CreateIndex(B.INS); database.WritePlace(timePlace, n);
					n := database.CreateIndex(0); database.WritePlace(joinAndLeavePlace, n);
					n := database.CreateIndex(0); database.WritePlace(idPubPlace, n);
					n := database.CreateIndex(0); database.WritePlace(idUidPlace, n);
					n := database.CreateIndex(0); database.WritePlace(certFromPlace, n);
					n := database.CreateIndex(0); database.WritePlace(certToPlace, n);
					n := database.CreateIndex(B.INS); database.WritePlace(certTimePlace, n);
					database.WritePlace(listPlace, B.bNil);
					database.WritePlace(lastNPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				joinAndLeaveMan := database.CreateDataMan(joinAndLeaveFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				listMan := database.CreateDataMan(listFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				joinAndLeaveT := database.OpenIndex(database.ReadPlace(joinAndLeavePlace), pubKeyMan, pubKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
				certTimeT := database.OpenIndex(database.ReadPlace(certTimePlace), certKTimeMan, intKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf* (bnb: INTEGER; OUT mTime, time: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				time := t.time;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPub* (IN pubkey: Pubkey; OUT joiningBlock, leavingBlock: INTEGER): BOOLEAN;
		
		VAR
			
			jl: JoinAndLeave;
			jlP: PubKey;
		
		BEGIN (*JLPub*)
			NEW(jlP);
			jlP.ref := pubkey;
			IF joinAndLeaveT.Search(jlP) THEN
				jl := joinAndLeaveMan.ReadData(joinAndLeaveT.ReadValue())(JoinAndLeave);
				joiningBlock := jl.joiningBlock;
				leavingBlock := jl.leavingBlock;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END JLPub;
	
	(* Number of JoinAndLeave *)
	PROCEDURE JLLen* (): INTEGER;
		
		BEGIN (*JLLen*)
			RETURN joinAndLeaveT.NumberOfKeys();
		END JLLen;
	
	(* Browse all JoinAndLeave's pubkeys step by step *)
	PROCEDURE JLNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*JLNextPubkey*)
			IF first THEN
				joinAndLeaveT.ResetPos;
			ELSE
				joinAndLeaveT.SetCurrPos(jlPubkeyCur);
			END;
			joinAndLeaveT.Next;
			jlPubkeyCur := joinAndLeaveT.GetCurrPos();
			IF ~joinAndLeaveT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := joinAndLeaveT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END JLNextPubkey;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String; OUT block_number: INTEGER): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPub*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				block_number := id.block_number;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* uid -> Identity *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey; OUT block_number: INTEGER): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				block_number := id.block_number;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idUidT.NumberOfKeys();
		END IdLen;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			idPubT.Next;
			idPubkeyCur := idPubT.GetCurrPos();
			IF ~idPubT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := idPubT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			idUidT.Next;
			idUidCur := idUidT.GetCurrPos();
			IF ~idUidT.PosSet() THEN
				RETURN FALSE;
			END;
			uid := idUidT.CurrentKey()(B.String).c;
			RETURN TRUE;
		END IdNextUid;
	
	(* (Pubkey, Pubkey) -> Certification *)
	PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertFrom*)
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				pos.posRef := certFromT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END CertFrom;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertTo* (IN to: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertTo*)
			NEW(p);
			p.ref := to;
			IF certToT.Search(p) THEN
				pos.posRef := certToT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END CertTo;
	
	(* Number of keys in sub-index *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		VAR
			
			ind: B.Index;
			n: INTEGER;
		
		BEGIN (*CertPosLen*)
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			n := ind.NumberOfKeys();
			ind.Close;
			RETURN n;
		END CertPosLen;
	
	(* Browse all Certification's pairs of Pubkey in a sub-index step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from, to: Pubkey): BOOLEAN, NEW;
		
		VAR
			
			ind: B.Index;
			ok: BOOLEAN;
			c: Certification;
		
		BEGIN (*CertNextPos*)
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.SetCurrPos(pos.posCur);
			ind.Next;
			pos.posCur := ind.GetCurrPos();
			ok := ind.PosSet();
			IF ok THEN
				c := certMan.ReadData(ind.ReadValue())(Certification);
				from := c.from;
				to := c.to;
			END;
			ind.Close;
			RETURN ok;
		END CertNextPos;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the from Pubkey *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromT.ResetPos;
			ELSE
				certFromT.SetCurrPos(certFromCur);
			END;
			certFromT.Next;
			certFromCur := certFromT.GetCurrPos();
			IF ~certFromT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certFromT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the to Pubkey *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certToT.ResetPos;
			ELSE
				certToT.SetCurrPos(certToCur);
			END;
			certToT.Next;
			certToCur := certToT.GetCurrPos();
			IF ~certToT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certToT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextTo;
	
	PROCEDURE IsSentry* (pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			sE: SentriesE;
			e: A.Elem;
			m: INTEGER;
		
		BEGIN (*IsSentry*)
			NEW(sE);
			sE.pubkey := pubkey;
			e := sE;
			RETURN sentriesT.Search(e, m);
		END IsSentry;
	
	PROCEDURE NextSentry* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*NextSentry*)
			IF first THEN
				sentryCur := NIL;
			END;
			sentryCur := sentriesT.Next(sentryCur);
			IF sentryCur = NIL THEN
				RETURN FALSE;
			END;
			WITH sentryCur: SentriesE DO
				pubkey := sentryCur.pubkey$;
			END;
			RETURN TRUE;
		END NextSentry;
	
	PROCEDURE SentriesLen* (): INTEGER;
		
		BEGIN (*SentriesLen*)
			RETURN sentriesT.NumberOfElems();
		END SentriesLen;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentries* (IN pubkeys: ARRAY OF Pubkey): REAL;
		
		VAR
			
			set, newSet: A.Tree;
			sE: SentriesE;
			e, ee: A.Elem;
			i, j, n: INTEGER;
			b: BOOLEAN;
			pos: CertPos;
			from, to: Pubkey;
		
		BEGIN (*PercentOfSentries*)
			A.New(set);
			FOR i := 0 TO LEN(pubkeys) - 1 DO
				NEW(sE);
				sE.pubkey := pubkeys[i];
				e := sE;
				b := set.SearchIns(e, n); ASSERT(~b);
			END;
			FOR i := 1 TO pars.stepMax - 1 DO
				A.New(newSet);
				FOR j := 0 TO LEN(pubkeys) - 1 DO
					NEW(sE);
					sE.pubkey := pubkeys[j];
					e := sE;
					b := newSet.SearchIns(e, n); ASSERT(~b);
				END;
				e := set.Next(NIL);
				WHILE e # NIL DO
					WITH e: SentriesE DO
						b := CertTo(e.pubkey, pos); ASSERT(b);
						WHILE pos.CertNextPos(from, to) DO
							NEW(sE);
							sE.pubkey := from;
							ee := sE;
							b := newSet.SearchIns(ee, n);
						END;
					END;
					e := set.Next(e);
				END;
				set := newSet;
			END;
			n := 0;
			e := set.Next(NIL);
			WHILE e # NIL DO
				WITH e: SentriesE DO
					IF IsSentry(e.pubkey) THEN
						INC(n);
					END;
				END;
				e := set.Next(e);
			END;
			RETURN n / SentriesLen();
		END PercentOfSentries;
	
	(* Verify the distance rule for a set of certifiers' pubkeys *)
	PROCEDURE DistanceRuleOk* (IN pubkeys: ARRAY OF Pubkey): BOOLEAN;
		
		BEGIN (*DistanceRuleOk*)
			RETURN PercentOfSentries(pubkeys) >= pars.xpercent;
		END DistanceRuleOk;
	
	(* Scan the string s from position i to the position of stop excluded; update i and return the scanned string in sub *)
	PROCEDURE ScanS (IN s: ARRAY OF CHAR; stop: CHAR; OUT sub: ARRAY OF CHAR; VAR i: INTEGER);
		
		VAR
			
			j: INTEGER;
		
		BEGIN (*ScanS*)
			j := 0;
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				sub[j] := s[i];
				INC(i); INC(j);
			END;
			sub[j] := 0X;
			INC(i);
		END ScanS;
	
	(* Skip the string s from position i to the position of stop excluded; update i *)
	PROCEDURE SkipS (IN s: ARRAY OF CHAR; stop: CHAR; VAR i: INTEGER);
		
		BEGIN (*SkipS*)
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				INC(i);
			END;
			INC(i);
		END SkipS;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params (d: S.Database);
		
		CONST
			
			txWindow = 60 * 60 * 24 * 7;
		
		VAR
			
			res: INTEGER;
			cur: S.Row;
			ss: POINTER TO ARRAY OF CHAR;
			s: ARRAY 20 OF CHAR;
			t: S.Table;
			i: INTEGER;
		
		BEGIN (*Params*)
			t := d.NewTable(); ASSERT(t # NIL, 101);
			REPEAT
				t.Exec("SELECT parameters FROM block WHERE number = 0 AND NOT fork");
				ASSERT(t.res IN {0, 6}, 100);
			UNTIL t.res = 0;
			ASSERT(t.columns = 1, 103); ASSERT(t.rows = 1, 104);
			 t.Read(0, cur);
			ss := cur.fields[0];
			ss[LEN(ss$)] := ':';
			i := 0;
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.c, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dt, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.ud0, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigPeriod, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigStock, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigWindow, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigValidity, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigQty, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.idtyWindow, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msWindow, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.xpercent, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msValidity, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.stepMax, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.medianTimeBlocks, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.avgGenTime, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtDiffEval, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.percentRot, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.udTime0, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.udReevalTime0, res); ASSERT(res = 0, 106);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtReeval, res); ASSERT(res = 0, 106);
			pars.txWindow := txWindow;
			pars.msPeriod := pars.msWindow;
		END Params;
	
	(* Add a block in timeT *)
	PROCEDURE Times (withList: BOOLEAN; IN s1, s2, s3: ARRAY OF CHAR);
		
		VAR
			
			t: Time;
			i: IntKey;
			res, n, tRef: INTEGER;
			b: BOOLEAN;
			tL: List; (* timeList *)
		
		BEGIN (*Times*)
			NEW(t);
			Strings.StringToInt(s1, t.bnb, res); ASSERT(res = 0);
			Strings.StringToLInt(s2, t.mTime, res); ASSERT(res = 0);
			Strings.StringToLInt(s3, t.time, res); ASSERT(res = 0);
			tRef := timeMan.AllocateData(timeS);
			timeMan.WriteData(tRef, t);
			NEW(i); i.ref := t.bnb;
			b := timeT.SearchIns(i); ASSERT(~b);
			timeT.WriteValue(tRef);
			IF withList THEN
				n := listMan.AllocateData(listS);
				NEW(tL); tL.ref := tRef; tL.type := timeList;
				tL.next := list; list := n;
				listMan.WriteData(n, tL);
			END;
			now := MAX(now, t.mTime);
			rNow := MAX(rNow, t.time);
		END Times;
	
	(* For one block, add joining & leaving identities in joinAndLeaveT and updade identities in idPubT and idUidT; update certFromT & certToT too *)
	PROCEDURE Identities (withList: BOOLEAN; IN ssJ, ssL, nb: ARRAY OF CHAR);
		
		VAR
			
			i, n, idRef, jlRef, cRef, indRef, ind2Ref, res: INTEGER;
			s: ARRAY 101 OF CHAR;
			b: BOOLEAN;
			id: Identity;
			idP, idP2: PubKey;
			idU: B.String;
			idL: List;
			cL: List; (* certRemoveList *)
			ind, ind2: B.Index;
			jl: JoinAndLeave;
		
		BEGIN (*Identities*)
			i := 1;
			WHILE ssJ[i] # ']' DO (* joiners : Insert id *)
				INC(i);
				NEW(id);
				ScanS(ssJ, ':', id.pubkey, i);
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '"', s, i); NEW(id.uid, LEN(s$) + 1); id.uid^ := s$;
				IF ssJ[i] # ']' THEN
					INC(i);
				END;
				Strings.StringToInt(nb, id.block_number, res); ASSERT(res = 0);
				idRef := idMan.AllocateData(minIdentityS + LEN(id.uid) * B.CHS);
				idMan.WriteData(idRef, id);
				NEW(idP); idP.ref := id.pubkey;
				b := idPubT.SearchIns(idP); ASSERT(~b);
				idPubT.WriteValue(idRef);
				NEW(idU); NEW(idU.c, LEN(id.uid$) + 1); idU.c^ := id.uid$;
				b := idUidT.SearchIns(idU); ASSERT(~b);
				idUidT.WriteValue(idRef);
				NEW(jl);
				jl.pubkey := id.pubkey;
				jl.joiningBlock := id.block_number;
				jl.leavingBlock := hasNotLeaved;
				jlRef := joinAndLeaveMan.AllocateData(joinAndLeaveS);
				joinAndLeaveMan.WriteData(jlRef, jl);
				b := joinAndLeaveT.SearchIns(idP); ASSERT(~b);
				joinAndLeaveT.WriteValue(jlRef);
				IF withList THEN
					n := listMan.AllocateData(listS);
					NEW(idL); idL.ref := idRef; idL.type := joinList;
					idL.next := list; list := n;
					listMan.WriteData(n, idL);
				END;
			END;
			i := 1;
			WHILE ssL[i] # ']' DO (* leavers : Remove id *)
				INC(i);
				NEW(idP);
				ScanS(ssL, ':', idP.ref, i);
				SkipS(ssL, '"', i);
				IF ssL[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					n := listMan.AllocateData(listS);
					NEW(idL); idL.ref := idRef; idL.type := leaveList;
					idL.next := list; list := n;
					listMan.WriteData(n, idL);
				ELSE
					idMan.EraseData(idRef);
				END;
				idPubT.Erase(idP);
				NEW(idU); idU.c := id.uid;
				idUidT.Erase(idU);
				b := joinAndLeaveT.Search(idP); ASSERT(b);
				jlRef := joinAndLeaveT.ReadValue();
				jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				Strings.StringToInt(nb, jl.leavingBlock, res); ASSERT(res = 0);
				joinAndLeaveMan.WriteData(jlRef, jl);
				
				(* Remove certifications from and to suppressed identities *)
				IF certFromT.Search(idP) THEN
					indRef := certFromT.ReadValue();
					ind := database.OpenIndex(indRef, pubKeyMan, pubKeyFac);
					ind.ResetPos;
					ind.Next;
					WHILE ind.PosSet() DO
						cRef := ind.ReadValue();
						IF withList THEN
							NEW(cL); cL.ref := cRef; cL.type := certRemoveList;
							n := listMan.AllocateData(listS);
							cL.next := list; list := n;
							listMan.WriteData(n, cL);
						ELSE
							certMan.EraseData(cRef);
						END;
						idP2 := ind.CurrentKey()(PubKey);
						b := certToT.Search(idP2); ASSERT(b);
						ind2Ref := certToT.ReadValue();
						ind2 := database.OpenIndex(ind2Ref, pubKeyMan, pubKeyFac);
						ind2.Erase(idP);
						b := ind2.NumberOfKeys() = 0;
						ind2.Close;
						IF b THEN
							database.DeleteIndex(ind2Ref);
							certToT.Erase(idP2);
						END;
						ind.Next;
					END;
					ind.Close;
					database.DeleteIndex(indRef);
					certFromT.Erase(idP);
				END;
				IF certToT.Search(idP) THEN
					indRef := certToT.ReadValue();
					ind := database.OpenIndex(indRef, pubKeyMan, pubKeyFac);
					ind.ResetPos;
					ind.Next;
					WHILE ind.PosSet() DO
						idP2 := ind.CurrentKey()(PubKey);
						b := certFromT.Search(idP2); ASSERT(b);
						ind2Ref := certFromT.ReadValue();
						ind2 := database.OpenIndex(ind2Ref, pubKeyMan, pubKeyFac);
						ind2.Erase(idP);
						b := ind2.NumberOfKeys() = 0;
						ind2.Close;
						IF b THEN
							database.DeleteIndex(ind2Ref);
							certFromT.Erase(idP2);
						END;
						ind.Next;
					END;
					ind.Close;
					database.DeleteIndex(indRef);
					certToT.Erase(idP);
				END;
			END;
		END Identities;
	
	(* Add certificatoins of one block in certFromT, certToT and certTimeT *)
	PROCEDURE Certifications (withList: BOOLEAN; IN ss, nb, time: ARRAY OF CHAR);
		
		VAR
			
			i, n, res, bnb, pC: INTEGER;
			b: BOOLEAN;
			c: Certification;
			idP: PubKey;
			cL: List; (*certAddList *)
			uid: String;
			ind: B.Index;
			iK: IntKey;
		
		BEGIN (*Certifications*)
			i := 1;
			WHILE ss[i] # ']' DO
				INC(i);
				NEW(c);
				ScanS(ss, ':', c.from, i);
				ScanS(ss, ':', c.to, i);
				SkipS(ss, '"', i);
				IF ss[i] # ']' THEN
					INC(i);
				END;
				IF IdPub(c.from, uid, bnb) & IdPub(c.to, uid, bnb) THEN
					Strings.StringToInt(nb, c.block_number, res); ASSERT(res = 0);
					Strings.StringToLInt(time, c.expires_on, res); ASSERT(res = 0);
					INC(c.expires_on, pars.sigValidity);
					pC := certMan.AllocateData(certificationS);
					certMan.WriteData(pC, c);
					NEW(idP);
					idP.ref := c.from;
					IF certFromT.SearchIns(idP) THEN
						n := certFromT.ReadValue();
					ELSE
						n := database.CreateIndex(pubKeyS);
						certFromT.WriteValue(n);
					END;
					idP.ref := c.to;
					ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
					b := ind.SearchIns(idP); ASSERT(~b);
					ind.WriteValue(pC);
					ind.Close;
					IF certToT.SearchIns(idP) THEN
						n := certToT.ReadValue();
					ELSE
						n := database.CreateIndex(pubKeyS);
						certToT.WriteValue(n);
					END;
					idP.ref := c.from;
					ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
					b := ind.SearchIns(idP); ASSERT(~b);
					ind.WriteValue(pC);
					ind.Close;
					NEW(iK); iK.ref := pC;
					b := certTimeT.SearchIns(iK); ASSERT(~b);
					IF withList THEN
						NEW(cL); cL.ref := pC; cL.type := certAddList;
						n := listMan.AllocateData(listS);
						cL.next := list; list := n;
						listMan.WriteData(n, cL);
					END;
				END;
			END;
		END Certifications;
	
	(* Remove a certification from certFromT and certToT *)
	PROCEDURE RemoveCert (c: Certification);
		
		VAR
			
			pKFrom, pKTo: PubKey;
			b: BOOLEAN;
			n: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveCert*)
			NEW(pKFrom); NEW(pKTo);
			pKFrom.ref := c.from; pKTo.ref := c.to;
			
			b := certFromT.Search(pKFrom); ASSERT(b);
			n := certFromT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			ind.Erase(pKTo);
			b := ind.NumberOfKeys() = 0;
			ind.Close;
			IF b THEN
				database.DeleteIndex(n);
				certFromT.Erase(pKFrom);
			END;
			
			b := certToT.Search(pKTo); ASSERT(b);
			n := certToT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			ind.Erase(pKFrom);
			b := ind.NumberOfKeys() = 0;
			ind.Close;
			IF b THEN
				database.DeleteIndex(n);
				certToT.Erase(pKTo);
			END;
		END RemoveCert;
	
	(* Remove expired certifications from certFromT and certToT *)
	PROCEDURE RemoveExpiredCerts (now, secureNow: LONGINT);
		
		VAR
			
			c: Certification;
			cTi: IntKey;
			b: BOOLEAN;
			n, pC: INTEGER;
			cL: List; (* certRemoveList *)
		
		BEGIN (*RemoveExpiredCerts*)
			NEW(c); c.expires_on := now; c.from := "";
			pC := certMan.AllocateData(certificationS);
			certMan.WriteData(pC, c);
			NEW(cTi); cTi.ref := pC;
			b := certTimeT.Search(cTi);
			certMan.EraseData(pC);
			WHILE certTimeT.PosSet() DO
				pC := certTimeT.CurrentKey()(IntKey).ref;
				c := certMan.ReadData(pC)(Certification);
				RemoveCert(c);
				IF c.expires_on > secureNow THEN
					NEW(cL); cL.ref := pC; cL.type := certRemoveList;
					n := listMan.AllocateData(listS);
					cL.next := list; list := n;
					listMan.WriteData(n, cL);
				ELSE
					certMan.EraseData(pC);
				END;
				certTimeT.Next;
			END;
		END RemoveExpiredCerts;
	
	(* Undo the last operations done from the secureGap last blocks *)
	PROCEDURE RemoveSecureGap;
		
		VAR
			
			b: BOOLEAN;
			i: IntKey;
			p: PubKey;
			u: B.String;
			t: Time;
			jl: JoinAndLeave;
			id: Identity;
			c: Certification;
			l: List;
			n: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveSecureGap*)
			WHILE list # B.bNil DO
				l := listMan.ReadData(list)(List);
				CASE l.type OF
					|timeList:
						t := timeMan.ReadData(l.ref)(Time);
						NEW(i); i.ref := t.bnb;
						timeT.Erase(i);
						timeMan.EraseData(l.ref);
					|joinList:
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						idPubT.Erase(p);
						NEW(u); u.c := id.uid;
						idUidT.Erase(u);
						idMan.EraseData(l.ref);
						b := joinAndLeaveT.Search(p); ASSERT(b);
						joinAndLeaveMan.EraseData(joinAndLeaveT.ReadValue());
						joinAndLeaveT.Erase(p);
					|leaveList:
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.SearchIns(p); ASSERT(~b);
						idPubT.WriteValue(l.ref);
						NEW(u); u.c := id.uid;
						b := idUidT.SearchIns(u); ASSERT(~b);
						idUidT.WriteValue(l.ref);
						b := joinAndLeaveT.Search(p); ASSERT(b);
						n := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(n)(JoinAndLeave);
						jl.leavingBlock := hasNotLeaved;
						joinAndLeaveMan.WriteData(n, jl);
					|certAddList:
						c := certMan.ReadData(l.ref)(Certification);
						RemoveCert(c);
						NEW(i); i.ref := l.ref;
						certTimeT.Erase(i);
						certMan.EraseData(l.ref);
					|certRemoveList:
						c := certMan.ReadData(l.ref)(Certification);
						NEW(p);
						p.ref := c.from;
						IF certFromT.SearchIns(p) THEN
							n := certFromT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certFromT.WriteValue(n);
						END;
						p.ref := c.to;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b);
						ind.WriteValue(l.ref);
						ind.Close;
						IF certToT.SearchIns(p) THEN
							n := certToT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certToT.WriteValue(n);
						END;
						p.ref := c.from;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b);
						ind.WriteValue(l.ref);
						ind.Close;
				END;
				listMan.EraseData(list);
				list := l.next;
			END;
		END RemoveSecureGap;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks (d: S.Database);
		
		VAR
			
			cur: S.Row;
			t: S.Table;
			i, res, lastN: INTEGER;
			s: ARRAY 13 OF CHAR;
			withList: BOOLEAN;
			now, secureNow: LONGINT;
		
		BEGIN (*ScanBlocks*)
			list := database.ReadPlace(listPlace);
			RemoveSecureGap;
			lastN := database.ReadPlace(lastNPlace);
			Strings.IntToString(lastN - secureGap, s);
			t := d.NewTable(); ASSERT(t # NIL, 101);
			REPEAT
				t.Exec("SELECT number, medianTime, time, joiners, leavers, revoked, certifications FROM block WHERE NOT fork AND number >= " + s + " ORDER BY number ASC");
				ASSERT(t.res IN {0, 6}, 100);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 7), 103);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, cur);
				Dialog.ShowStatus(cur.fields[0]);
				withList := i >= t.rows - secureGap;
				Times(withList , cur.fields[0], cur.fields[1], cur.fields[2]);
				IF cur.fields[5]$ = "[]" THEN
					Identities(withList, cur.fields[3], cur.fields[4], cur.fields[0]);
				ELSE
					Identities(withList, cur.fields[3], cur.fields[5], cur.fields[0]);
				END;
				Certifications(withList, cur.fields[6], cur.fields[0], cur.fields[1]);
			END;
			IF t.rows > 0 THEN
				t.Read(t.rows - 1, cur);
				Strings.StringToLInt(cur.fields[1], now, res); ASSERT(res = 0);
				IF t.rows >= secureGap THEN
					t.Read(t.rows - secureGap, cur);
				ELSE
					t.Read(0, cur);
				END;
				Strings.StringToLInt(cur.fields[1], secureNow, res); ASSERT(res = 0);
			END;
			RemoveExpiredCerts(now, secureNow); (* Élimine toutes les certifications expirées avec réversibilité dans secureGap *)
			database.WritePlace(listPlace, list);
			IF lastN <= secureGap THEN
				lastN := t.rows;
			ELSE
				INC(lastN, t.rows - secureGap);
			END;
			database.WritePlace(lastNPlace, lastN);
			database.UpdateBase;
		END ScanBlocks;
	
	(* Initialize sentriesT *)
	PROCEDURE CalculateSentries;
		
		VAR
			
			ok, b: BOOLEAN;
			pos: CertPos;
			n, m: INTEGER;
			pubkey: Pubkey;
			sE: SentriesE;
			e: A.Elem;
		
		BEGIN (*CalculateSentries*)
			A.New(sentriesT);
			n := IdLen();
			IF n = 0 THEN RETURN END;
			n := SHORT(ENTIER(Math.Ceiling(Math.Power(n, 1 / pars.stepMax))));
			ok := IdNextPubkey(TRUE, pubkey);
			WHILE ok DO
				IF CertFrom(pubkey, pos) & (pos.CertPosLen() >= n) & CertTo(pubkey, pos) & (pos.CertPosLen() >= n) THEN
					NEW(sE);
					sE.pubkey := pubkey;
					e := sE;
					b := sentriesT.SearchIns(e, m); ASSERT(~b);
				END;
				ok := IdNextPubkey(FALSE, pubkey);
			END
		END CalculateSentries;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList; m := NIL;
			WHILE l # NIL DO
				m := l;
				l := l.next;
			END;
			NEW(l);
			l.next := NIL;
			l.update := updateProc;
			IF m = NIL THEN
				updateList := l;
			ELSE
				m.next := l;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList; m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			ASSERT(l # NIL, 20);
			IF m = NIL THEN
				updateList := l.next;
			ELSE
				m.next := l.next;
			END;
		END RemoveUpdateProc;
	
	(* Help emptying the memory *)
	PROCEDURE Collect;
		
		BEGIN (*Collect*)
			IF Kernel.WouldFinalize() THEN
				Kernel.Collect;
			ELSE
				Kernel.FastCollect;
			END;
		END Collect;
	
	(* Scan the Duniter database *)
	PROCEDURE Scan;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			ScanBlocks(d);
			CalculateSentries;
		END Scan;
	
	(* Scan the Duniter parameters in block 0 *)
	PROCEDURE Scan1;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan1*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			Params(d);
		END Scan1;
	
	PROCEDURE UpdateAll*;
		
		VAR
			
			l: UpdateList;
			t0, t1, rest: LONGINT;
		
		BEGIN (*UpdateAll*)
			Services.RemoveAction(update);
			t0 := Services.Ticks();
			l := updateList;
			WHILE l # NIL DO
				l.update;
				l := l.next;
			END;
			Collect;
			t1 := Services.Ticks();
			rest := delay - (t1 - t0);
			Services.DoLater(update, t1 + MAX(rest, minDelay));
		END UpdateAll;
	
	PROCEDURE (update: UpdateAction) Do;
		
		BEGIN (*Do*)
			UpdateAll;
		END Do;
	
	PROCEDURE ChooseDuniterDataBase*;
		
		VAR
			
			loc, l: Files.Locator;
			path, name: Files.Name;
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		PROCEDURE SplitFullName (full: ARRAY OF CHAR; OUT path, name: ARRAY OF CHAR): BOOLEAN;
			
			VAR
				
				res, drive, p: INTEGER;
				ok: BOOLEAN;
			
			BEGIN (*SplitFullName*)
				res := 0;
				LOOP
					Strings.Find(full, '\', res, res);
					IF res = - 1 THEN
						EXIT;
					END;
					full[res] := '/';
				END;
				Strings.Find(full, ':', 0, res);
				ok := (res = - 1) OR (res = 1);
				IF ok THEN
					drive := res;
					Strings.Find(full, '/', res + 1, p);
					WHILE p >= 0 DO
						res := p;
						Strings.Find(full, '/', res + 1, p);
					END;
					IF res < 0 THEN
						path := "";
						name := full$;
					ELSE
						IF res <= drive + 1 THEN
							Strings.Extract(full, 0, res + 1, path);
						ELSE
							Strings.Extract(full, 0, res, path);
						END;
						Strings.Extract(full, res + 1, LEN(full), name);
					END;
					ok := LEN(name$) > 0;
				END;
				RETURN ok;
			END SplitFullName;
		
		BEGIN (*ChooseDuniterDataBase*)
			IF ~SplitFullName(duniBase, path, name) THEN
				path := ''; name := '';
			END;
			loc := Files.dir.This(path); ASSERT(loc.res = 0);
			Dialog.GetIntSpec("*", loc, name);
			IF loc # NIL THEN
				duniBase := loc(HostFiles.Locator).path + "/" + name;
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString('"' + duniBase + '"');
				l := Files.dir.This(initDir); ASSERT(l.res = 0);
				Views.RegisterView(TextViews.dir.New(t), l, initName);
			END;
		END ChooseDuniterDataBase;
	
	PROCEDURE ResetDataBase*;
		
		VAR
			
			l: Files.Locator;
			res: INTEGER;
		
		BEGIN (*ResetDataBase*)
			Dialog.GetOK("#Duniter:ResetBase", "", "", "", {Dialog.ok, Dialog.cancel}, res);
			IF res = Dialog.ok THEN
				CloseB;
				l := Files.dir.This(''); ASSERT(l.res = 0);
				Files.dir.Delete(l, dBase); ASSERT(l.res = 0);
				OpenB;
			END;
		END ResetDataBase;
	
	PROCEDURE Init;
		
		VAR
			
			loc, l: Files.Locator;
			v: Views.View;
			s: TextMappers.Scanner;
			date: Dates.Date;
			res: INTEGER;
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Init*)
			duniBase := '';
			l := Files.dir.This(initDir); ASSERT(l.res = 0);
			REPEAT
				v := Views.OldView(l, initName);
				IF v = NIL THEN
					Dialog.GetOK("#Duniter:DuniterDataBase", "", "", "", {Dialog.ok}, res);
					loc := Files.dir.This(''); ASSERT(loc.res = 0);
					Dialog.GetIntSpec("*", loc, duniBase);
					IF loc = NIL THEN
						HALT(128);
					ELSE
						t := TextModels.dir.New();
						f.ConnectTo(t);
						duniBase := loc(HostFiles.Locator).path + "/" + duniBase;
						f.WriteString('"' + duniBase + '"');
						Views.RegisterView(TextViews.dir.New(t), l, initName);
					END;
				ELSE
					ASSERT(v IS TextViews.View);
					s.ConnectTo(v(TextViews.View).ThisModel());
					s.Scan;
					IF s.type = TextMappers.string THEN
						duniBase := s.string$;
					END;
				END;
			UNTIL duniBase # '';
			date.year := year0; date.month := month0; date.day := day0;
			t0 := Dates.Day(date);
			now := 0; rNow := 0;
			Scan1;
			delay := pars.avgGenTime * Services.resolution;
			updateList := NIL;
			AddUpdateProc(Scan);
			NEW(listFac); NEW(timeFac); NEW(joinAndLeaveFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan); NEW(intKeyMan); NEW(certKTimeMan);
			OpenB;
			NEW(update);
			UpdateAll;
		END Init;
	
	BEGIN (*DuniterBlockchain*)
		Init;
	CLOSE
		CloseB;
		Services.RemoveAction(update);
	END DuniterBlockchain.
