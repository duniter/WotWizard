(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterIdentitySearch;
	
	

	IMPORT
		
		(*
		StdLog,
		*)
		
		A := UtilAvlTree, B := DuniterBlockchain, Dialog, S := DuniterSandbox, BA := DuniterBasic, Strings;
	
	CONST
		
		maxItems = 100;
		
		nonEditableNb = 5;
		
		futureIcon = 'º';
	
	TYPE
		
		IdE = POINTER TO RECORD (A.Elem)
			uid: BA.String;
			future: BOOLEAN;
		END;
		
		NonEditable* = ARRAY 2 * nonEditableNb OF Dialog.String;
	
	VAR
		
		hint*: Dialog.Combo;
		
		identityNb-,
		identityFutNb-: INTEGER;
		identityList*: Dialog.List;
		
		identity*: RECORD
			member-: BOOLEAN;
			fields*: NonEditable; (* uid (0), pubkey (1), date (2) *)
		END;
		
		receivedCertsNb-,
		receivedCertsFutNb-,
		sentCertsNb-,
		sentCertsFutNb-: INTEGER;
		receivedCerts*,
		sentCerts*: Dialog.List;
	
	PROCEDURE (i1: IdE) Compare (i2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdE DO
				RETURN BA.CompP(i1.uid, i2.uid);
			END;
		END Compare;
	
	PROCEDURE UpdateCombo (VAR c: Dialog.Combo; maxItems: INTEGER);
		
		VAR
			
			s: Dialog.String;
			i, j: INTEGER;
			found: BOOLEAN;
		
		BEGIN (*UpdateCombo*)
			IF c.item # "" THEN
				j := - 1; found := FALSE;
				WHILE (j < c.len - 1) & ~found DO
					INC(j);
					c.GetItem(j, s);
					found := s = c.item;
				END;
				IF ~found THEN
					j := MIN(c.len, maxItems - 1);
				END;
				FOR i := j - 1 TO 0 BY - 1 DO
					c.GetItem(i, s);
					c.SetItem(i + 1, s);
				END;
				c.SetItem(0, c.item);
				Dialog.UpdateList(c);
			END;
		END UpdateCombo;
	
	PROCEDURE Find (IN hint: ARRAY OF CHAR; OUT nA, nF: INTEGER): A.Tree;
		
		VAR
			
			t: A.Tree;
			idE: IdE;
			e: A.Elem;
			b, ok: BOOLEAN;
			uid: BA.String;
			pub, p: B.Pubkey;
			hash: S.Hash;
			exp: LONGINT;
			pos, bloc, n: INTEGER;
			hintD: BA.String;
		
		BEGIN (*Find*)
			A.New(t);
			hintD := BA.ToDown(hint);
			B.IdPosUid(hintD);
			ok := B.IdNextUid(FALSE, uid);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok THEN
					NEW(idE); idE.uid := uid; idE.future := FALSE; e := idE;
					b := t.SearchIns(e, n); ASSERT(~b);
					ok := B.IdNextUid(FALSE, uid);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				pub := hint$; (* À revoir *)
				B.IdPosPubkey(pub);
				ok := B.IdNextPubkey(FALSE, p);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok THEN
						b := B.IdPub(p, uid, bloc); ASSERT(b);
						NEW(idE); idE.uid := uid; idE.future := FALSE; e := idE;
						b := t.SearchIns(e, n);
						ok := B.IdNextPubkey(FALSE, p);
					END;
				END;
			END;
			nA := t.NumberOfElems();
			S.IdPosUid(hintD);
			ok := S.IdNextUid(FALSE, uid);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok THEN
					NEW(idE); idE.uid := uid; idE.future := TRUE; e := idE;
					b := t.SearchIns(e, n); ASSERT(~b);
					ok := S.IdNextUid(FALSE, uid);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				S.IdPosPubkey(pub);
				ok := S.IdNextPubkey(FALSE, p);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok THEN
						b := S.IdPub(p, hash) & S.IdHash(hash, p, uid, exp); ASSERT(b);
						NEW(idE); idE.uid := uid; idE.future := TRUE; e := idE;
						b := t.SearchIns(e, n);
						ok := S.IdNextPubkey(FALSE, p);
					END;
				END;
			END;
			nF := t.NumberOfElems() - nA;
			RETURN t;
		END Find;
	
	PROCEDURE GetCDate (IN from, to: ARRAY OF CHAR; OUT date: ARRAY OF CHAR);
		
		VAR
			
			b, member: BOOLEAN;
			fromP, toP, p: B.Pubkey;
			toH: S.Hash;
			bloc: INTEGER;
			exp: LONGINT;
			d: BA.DateTime;
		
		BEGIN (*GetCDate*)
			b := B.IdUid(from, fromP, bloc);
			member := B.IdUid(to, toP, bloc);
			IF member THEN
				b := B.Cert(fromP, toP, bloc, exp) OR S.Cert(fromP, toP, p, exp);
			ELSE
				b := S.IdUid(to, toH) & S.Cert(fromP, toH, p, exp); ASSERT(b);
			END;
			BA.TimestampToString(exp, d);
			date := d$;
		END GetCDate;
	
	PROCEDURE FilterItem (VAR item: ARRAY OF CHAR);
		
		BEGIN (*FilterItem*)
			IF item[0] = futureIcon THEN
				Strings.Replace(item, 0, 2, '');
			END;
		END FilterItem;
	
	PROCEDURE Certs (IN pubkey: B.Pubkey; member: BOOLEAN);
		
		VAR
			
			okB, okS, b: BOOLEAN;
			posB: B.CertPos;
			posS: S.CertPos;
			from, to: B.Pubkey;
			i, bnb, n: INTEGER;
			exp: LONGINT;
			uid: BA.String;
			toH: S.Hash;
			p: B.Pubkey;
			t: A.Tree;
			idE: IdE;
			e: A.Elem;
			s: Dialog.String;
		
		BEGIN (*Certs*)
			IF member THEN
				okB := B.CertFrom(pubkey, posB);
				IF okB THEN
					sentCertsNb := posB.CertPosLen();
				ELSE
					sentCertsNb := 0;
				END;
				okS := S.CertFrom(pubkey, posS);
				IF okS THEN
					sentCertsFutNb := posS.CertPosLen();
				ELSE
					sentCertsFutNb := 0;
				END;
				sentCerts.SetLen(sentCertsNb + sentCertsFutNb);
				A.New(t);
				okB := okB & posB.CertNextPos(from, to);
				WHILE okB DO
					NEW(idE);
					b := B.IdPub(to, idE.uid, bnb); ASSERT(b);
					idE.future := FALSE;
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b);
					okB := posB.CertNextPos(from, to);
				END;
				okS := okS & posS.CertNextPos(from, to, toH, exp);
				WHILE okS DO
					NEW(idE);
					b := B.IdPub(to, idE.uid, bnb) OR S.IdHash(toH, p, idE.uid, exp); ASSERT(b);
					idE.future := TRUE;
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b);
					okS := posS.CertNextPos(from, to, toH, exp);
				END;
				i := 0;
				e := t.Next(NIL);
				WHILE e # NIL DO
					WITH e: IdE DO
						IF e.future THEN
							sentCerts.SetItem(i, futureIcon + ' ' + e.uid$);
						ELSE
							sentCerts.SetItem(i, e.uid$);
						END;
					END;
					INC(i);
					e := t.Next(e);
				END;
			ELSE
				sentCertsNb := 0;
				sentCertsFutNb := 0;
				sentCerts.SetLen(0);
			END;
			sentCerts.index := 0;
			Dialog.UpdateInt(sentCertsNb);
			Dialog.UpdateInt(sentCertsFutNb);
			Dialog.UpdateList(sentCerts);
			IF sentCerts.len = 0 THEN
				identity.fields[8] := "";
			ELSE
				sentCerts.GetItem(sentCerts.index, s);
				FilterItem(s);
				GetCDate(identity.fields[0], s, identity.fields[8]);
			END;
			identity.fields[9] := identity.fields[8];
			
			okB := member & B.CertTo(pubkey, posB);
			IF okB THEN
				receivedCertsNb := posB.CertPosLen();
			ELSE
				receivedCertsNb := 0;
			END;
			IF member THEN
				okS := S.CertTo(pubkey, posS);
			ELSE
				okS := S.IdPub(pubkey, toH) & S.CertTo(toH, posS);
			END;
			IF okS THEN
				receivedCertsFutNb := posS.CertPosLen();
			ELSE
				receivedCertsFutNb := 0;
			END;
			receivedCerts.SetLen(receivedCertsNb + receivedCertsFutNb);
			A.New(t);
			okB := okB & posB.CertNextPos(from, to);
			WHILE okB DO
				NEW(idE);
				b := B.IdPub(from, idE.uid, bnb); ASSERT(b);
				idE.future := FALSE;
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b);
				okB := posB.CertNextPos(from, to);
			END;
			okS := okS & posS.CertNextPos(from, to, toH, exp);
			WHILE okS DO
				NEW(idE);
				b := B.IdPub(from, idE.uid, bnb); ASSERT(b);
				idE.future := TRUE;
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b);
				okS := posS.CertNextPos(from, to, toH, exp);
			END;
			i := 0;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					IF e.future THEN
						receivedCerts.SetItem(i, futureIcon + ' ' + e.uid$);
					ELSE
						receivedCerts.SetItem(i, e.uid$);
					END;
				END;
				INC(i);
				e := t.Next(e);
			END;
			receivedCerts.index := 0;
			Dialog.UpdateInt(receivedCertsNb);
			Dialog.UpdateInt(receivedCertsFutNb);
			Dialog.UpdateList(receivedCerts);
			IF receivedCerts.len = 0 THEN
				identity.fields[6] := "";
			ELSE
				receivedCerts.GetItem(receivedCerts.index, s);
				FilterItem(s);
				GetCDate(s, identity.fields[0], identity.fields[6]);
			END;
			identity.fields[7] := identity.fields[6];
		END Certs;
	
	PROCEDURE Get (IN uid: ARRAY OF CHAR; OUT pubkey, date: ARRAY OF CHAR; OUT member: BOOLEAN);
		
		VAR
			
			bloc: INTEGER;
			mTime, t, exp: LONGINT;
			hash: S.Hash;
			uid2: BA.String;
			p: B.Pubkey;
			d: BA.DateTime;
		
		BEGIN (*Get*)
			member := B.IdUid(uid, p, bloc) & B.TimeOf(bloc, mTime, t);
			IF member THEN
				INC(mTime, B.pars.msValidity);
				BA.TimestampToString(mTime, d);
			ELSE
				ASSERT(S.IdUid(uid, hash) & S.IdHash(hash, p, uid2, exp));
				BA.TimestampToString(exp, d);
			END;
			pubkey := p$;
			date := d$;
		END Get;
	
	PROCEDURE Fix (IN uid: ARRAY OF CHAR);
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*Fix*)
			Get(identity.fields[0], identity.fields[2], identity.fields[4], identity.member);
			FOR i := 0 TO nonEditableNb - 1 DO
				identity.fields[2 * i + 1] := identity.fields[2 * i];
			END;
			Certs(identity.fields[2]$, identity.member);
			Dialog.Update(identity);
		END Fix;
	
	PROCEDURE Search*;
		
		VAR
			
			t: A.Tree;
			e: A.Elem;
			i: INTEGER;
		
		BEGIN (*Search*)
			UpdateCombo(hint, maxItems);
			t := Find(hint.item, identityNb, identityFutNb);
			Dialog.UpdateInt(identityNb);
			Dialog.UpdateInt(identityFutNb);
			identityList.SetLen(identityNb + identityFutNb);
			i := 0;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					IF e.future THEN
						identityList.SetItem(i, futureIcon + ' ' + e.uid$);
					ELSE
						identityList.SetItem(i, e.uid$);
					END;
				END;
				INC(i);
				e := t.Next(e);
			END;
			identityList.index := 0;
			Dialog.UpdateList(identityList);
			IF identityList.len = 0 THEN
				receivedCertsNb := 0;
				receivedCertsFutNb := 0;
				receivedCerts.SetLen(0);
				sentCertsNb := 0;
				sentCertsFutNb := 0;
				sentCerts.SetLen(0);
				identity.member := FALSE;
				FOR i := 0 TO nonEditableNb - 1 DO
					identity.fields[i] := "";
				END;
				Dialog.UpdateInt(identityNb);
				Dialog.UpdateInt(identityFutNb);
				Dialog.UpdateInt(receivedCertsNb);
				Dialog.UpdateInt(receivedCertsFutNb);
				Dialog.UpdateList(receivedCerts);
				Dialog.UpdateInt(sentCertsNb);
				Dialog.UpdateInt(sentCertsFutNb);
				Dialog.UpdateList(sentCerts);
				Dialog.Update(identity);
			ELSE
				identityList.GetItem(identityList.index, identity.fields[0]);
				FilterItem(identity.fields[0]);
				Fix(identity.fields[0]);
			END;
		END Search;
	
	PROCEDURE CopyReceived*;
		
		BEGIN (*CopyReceived*)
			IF receivedCerts.len > 0 THEN
				receivedCerts.GetItem(receivedCerts.index, hint.item);
				FilterItem(hint.item);
				Dialog.UpdateList(hint);
			END;
		END CopyReceived;
	
	PROCEDURE CopySent*;
		
		BEGIN (*CopySent*)
			IF sentCerts.len > 0 THEN
				sentCerts.GetItem(sentCerts.index, hint.item);
				FilterItem(hint.item);
				Dialog.UpdateList(hint);
			END;
		END CopySent;
	
	PROCEDURE CopyReceivedGuard* (VAR par: Dialog.Par);
		
		BEGIN (*CopyReceivedGuard*)
			par.disabled := receivedCerts.len = 0;
		END CopyReceivedGuard;
	
	PROCEDURE CopySentGuard* (VAR par: Dialog.Par);
		
		BEGIN (*CopySentGuard*)
			par.disabled := sentCerts.len = 0;
		END CopySentGuard;
	
	PROCEDURE IdentityListNotifier* (op, from, to: INTEGER);
		
		VAR
			
			uid: Dialog.String;
		
		BEGIN (*IdentityListNotifier*)
			IF (op = Dialog.changed) & (identityList.index >= 0) & (identityList.index < identityList.len) THEN
				identityList.GetItem(identityList.index, identity.fields[0]);
				FilterItem(identity.fields[0]);
				Fix(identity.fields[0]);
			END;
		END IdentityListNotifier;
	
	PROCEDURE NonEditableNotifier* (n, op, from, to: INTEGER);
		
		BEGIN (*NonEditableNotifier*)
			IF op = Dialog.changed THEN
				ASSERT(n IN {0 .. nonEditableNb - 1}, 100);
				identity.fields[2 * n] := identity.fields[2 * n + 1];
			END;
		END NonEditableNotifier;
	
	PROCEDURE CertsNotifier* (n, op, from, to: INTEGER);
		
		VAR
			
			s: Dialog.String;
		
		BEGIN (*CertsNotifier*)
			IF op = Dialog.changed THEN
				CASE n OF
					|3:
						IF receivedCerts.len > 0 THEN
							receivedCerts.GetItem(MIN(MAX(receivedCerts.index, 0), receivedCerts.len - 1), s);
							FilterItem(s);
							GetCDate(s, identity.fields[0], identity.fields[2 * n]);
						ELSE
							identity.fields[2 * n] := ""
						END;
					|4:
						IF sentCerts.len > 0 THEN
							sentCerts.GetItem(MIN(MAX(sentCerts.index, 0), sentCerts.len - 1), s);
							FilterItem(s);
							GetCDate(identity.fields[0], s, identity.fields[2 * n]);
						ELSE
							identity.fields[2 * n] := ""
						END;
				END;
				identity.fields[2 * n + 1] := identity.fields[2 * n];
				Dialog.Update(identity);
			END;
		END CertsNotifier;
	
	END DuniterIdentitySearch.
