(* 
Util: Utility tools.

Copyright (C) 2001…2006 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE UtilNet;
	
	(* Centrality calculation by the use of FloydWarshall algorithm (calculation of shortest distances) *)
	
	(* Le degré de centralité d'un membre est le nombre de couples orientés (membre->membre) pour lesquels il fait partie d'un des plus courts chemins reliant ce couple. *)
	
	

	IMPORT
		
		(*
		L := StdLog,
		*)
		
		S := UtilSets, UtilSort;
	
	CONST
		
		(* Results of comparison. *)
		lt* = -1; (* less than *)
		eq* = 0; (* equal *)
		gt* = + 1; (* greater than *)
		
		infinity = MAX(INTEGER) DIV 2;
	
	TYPE
		
		Net* = POINTER TO ABSTRACT RECORD
			nbNodes-: INTEGER;
			nodes: NodesSort;
			extremities: S.Set;
			linksFT: Links;
			dist: Distance;
		END;
		
		Node* = POINTER TO ABSTRACT RECORD
		END;
		
		Nodes = POINTER TO ARRAY OF Node;
		
		NodesSort = RECORD (UtilSort.T)
			t: Nodes;
			e: POINTER TO ARRAY OF BOOLEAN;
		END;
		
		Links = POINTER TO ARRAY OF S.Set;
		
		SetC = POINTER TO ARRAY OF LONGINT;
		
		Distance = POINTER TO ARRAY OF POINTER TO ARRAY OF INTEGER;
		
		Centrals* = POINTER TO LIMITED RECORD
			nbNodes: INTEGER;
			nodes: Nodes;
			extremities: S.Set;
			extI: S.SetIterator;
			cT: SetC;
			pos: INTEGER;
		END;
	
	PROCEDURE (net: Net) Number- (): INTEGER, NEW, ABSTRACT; 
	
	PROCEDURE (net: Net) Enumerate- (first: BOOLEAN; OUT node: Node; OUT extremity: BOOLEAN): BOOLEAN, NEW, ABSTRACT; 
	
	PROCEDURE (n1: Node) Compare- (n2: Node): BYTE, NEW, ABSTRACT;
	
	PROCEDURE (n: Node) FromTo- (first: BOOLEAN; OUT follow: Node): BOOLEAN, NEW, ABSTRACT;
	
	PROCEDURE (net: Net) ExtremitiesNb* (): INTEGER, NEW;
		
		BEGIN (*ExtremitiesNb*)
			ASSERT(net.extremities # NIL, 20);
			RETURN net.extremities.nbElems;
		END ExtremitiesNb;
	
	PROCEDURE (VAR s: NodesSort) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN s.t[p1].Compare(s.t[p2]) = lt;
		END Less;
	
	PROCEDURE (VAR s: NodesSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			n: Node;
			b: BOOLEAN;
		
		BEGIN (*Swap*)
			n := s.t[p1]; s.t[p1] := s.t[p2]; s.t[p2] := n;
			b := s.e[p1]; s.e[p1] := s.e[p2]; s.e[p2] := b;
		END Swap;
	
	PROCEDURE (ct: Centrals) Walk* (first: BOOLEAN; OUT node: Node; OUT c: LONGINT): BOOLEAN, NEW;
		
		VAR
			
			ok: BOOLEAN;
		
		BEGIN (*Walk*)
			IF first THEN
				ok := ct.extI.FirstE(ct.pos);
			ELSE
				ok := ct.extI.NextE(ct.pos);
			END;
			IF ~ok THEN
				RETURN FALSE;
			END;
			node := ct.nodes[ct.pos];
			c := ct.cT[ct.pos];
			RETURN TRUE;
		END Walk;
	
	PROCEDURE (net: Net) FindNode (node: Node; OUT n: INTEGER): BOOLEAN, NEW;
		
		BEGIN (*FindNode*)
			n := net.nbNodes;
			net.nodes.t[n] := node;
			net.nodes.BinSearch(0, n - 1, n);
			RETURN n < net.nbNodes;
		END FindNode;
	
	PROCEDURE (net: Net) FloydWarshall, NEW;
		
		VAR
			
			i, j, k: INTEGER;
			ok: BOOLEAN;
			iter: S.SetIterator;
		
		BEGIN (*FloydWarshall*)
			NEW(net.dist, net.nbNodes);
			FOR i := 0 TO net.nbNodes - 1 DO
				NEW(net.dist[i], net.nbNodes);
				FOR j := 0 TO net.nbNodes - 1 DO
					net.dist[i, j] := infinity;
				END;
				iter.Attach(net.linksFT[i]);
				ok := iter.FirstE(j);
				WHILE ok DO
					net.dist[i, j] := 1;
					ok := iter.NextE(j);
				END;
				net.dist[i, i] := 0;
			END;
			FOR k := 0 TO net.nbNodes - 1 DO
				FOR i := 0 TO net.nbNodes - 1 DO
					FOR j := 0 TO net.nbNodes - 1 DO
						net.dist[i, j] := MIN(net.dist[i, j], net.dist[i, k] + net.dist[k, j]);
					END;
				END;
			END;
		END FloydWarshall;
	
	PROCEDURE (net: Net) Update*, NEW;
		
		VAR
			
			i, n: INTEGER;
			ok, extremity, b: BOOLEAN;
			node: Node;
		
		BEGIN (*Update*)
			net.nbNodes := net.Number();
			NEW(net.nodes.t, net.nbNodes + 1);
			NEW(net.nodes.e, net.nbNodes);
			i := 0;
			ok := net.Enumerate(TRUE, node, extremity);
			WHILE ok DO
				net.nodes.t[i] := node;
				net.nodes.e[i] := extremity;
				INC(i);
				ok := net.Enumerate(FALSE, node, extremity);
			END;
			ASSERT(i = net.nbNodes);
			net.nodes.QuickSort(0, net.nbNodes - 1);
			net.extremities := S.NewSet();
			FOR i := 0 TO net.nbNodes - 1 DO
				IF net.nodes.e[i] THEN
					net.extremities.Incl(i);
				END;
			END;
			net.nodes.e := NIL;
			
			NEW(net.linksFT, net.nbNodes);
			FOR i := 0 TO net.nbNodes - 1 DO
				net.linksFT[i] := S.NewSet();
			END;
			FOR i := 0 TO net.nbNodes - 1 DO
				ok := net.nodes.t[i].FromTo(TRUE, node);
				WHILE ok DO
					b := net.FindNode(node, n); ASSERT(b);
					net.linksFT[i].Incl(n);
					ok := net.nodes.t[i].FromTo(FALSE, node);
				END;
			END;
			
			net.FloydWarshall;
		END Update;
	
	PROCEDURE (net: Net) Centrality* (node: Node): LONGINT, NEW;
		
		VAR
			
			en, i, j: INTEGER;
			count: LONGINT;
			oki, okj: BOOLEAN;
			iteri, iterj: S.SetIterator;
				
		BEGIN (*Centrality*)
			IF ~net.FindNode(node, en) THEN
				RETURN 0;
			END;
			count := 0;
			iteri.Attach(net.extremities); iterj.Attach(net.extremities);
			oki := iteri.FirstE(i);
			WHILE oki DO
				IF i # en THEN
					okj := iterj.FirstE(j);
					WHILE okj DO
						IF (en # j) & (net.dist[i, en] + net.dist[en, j] = net.dist[i, j]) THEN
							INC(count);
						END;
						okj := iterj.NextE(j);
					END;
				END;
				oki := iteri.NextE(i);
			END;
			RETURN count;
		END Centrality;
	
	PROCEDURE (net: Net) NewC (OUT set: SetC), NEW;
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*NewC*)
			NEW(set, net.nbNodes);
			FOR i := 0 TO net.nbNodes - 1 DO
				set[i] := 0;
			END;
		END NewC;
	
	PROCEDURE (net: Net) Centralities* (): Centrals, NEW;
		
		VAR
			
			setC: SetC;
			ct: Centrals;
			i: INTEGER;
				
		BEGIN (*Centralities*)
			net.NewC(setC);
			FOR i := net.nbNodes - 1 TO 0 BY - 1 DO
				setC[i] := net.Centrality(net.nodes.t[i]);
			END;
			NEW(ct);
			ct.nbNodes := net.nbNodes;
			ct.nodes := net.nodes.t;
			ct.extremities := net.extremities; ct.extI.Attach(ct.extremities);
			ct.cT := setC;
			RETURN ct;
		END Centralities;
	
	END UtilNet.
