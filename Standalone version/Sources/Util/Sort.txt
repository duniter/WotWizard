MODULE UtilSort;
	
	IMPORT
		
		UtilAlea;
	
	TYPE
		
		T* = ABSTRACT RECORD;
		END;
	
	VAR
		
		g: UtilAlea.Generator;
	
	PROCEDURE (VAR t: T) Less- (p1, p2: INTEGER): BOOLEAN, NEW, ABSTRACT;
	
	PROCEDURE (VAR t: T) Swap- (p1, p2: INTEGER), NEW, ABSTRACT;
	
	PROCEDURE (VAR t: T) QuickSort* (len: INTEGER), NEW;
		
		CONST
			
			maxIns = 24;
		
		PROCEDURE Insertion (l, r: INTEGER);
			
			VAR
				
				i, j: INTEGER;
			
			BEGIN (*Insertion*)
				FOR i := l + 1 TO r DO
					j := i;
					WHILE (j > l) & t.Less(j, j - 1) DO
						t.Swap(j, j - 1);
						DEC(j);
					END;
				END;
			END Insertion;
		
		PROCEDURE Sort (l, r: INTEGER);
			
			VAR
				
				n, i, j, p0, p, p2, q: INTEGER;
			
			BEGIN (*Sort*)
				LOOP
					n := r - l + 1;
					IF n <= maxIns THEN
						Insertion (l, r);
						EXIT;
					ELSE
						p0 := l + SHORT(ENTIER(n * g.Random()));
						p := l + SHORT(ENTIER(n * g.Random()));
						p2 := l + SHORT(ENTIER(n * g.Random()));
						IF t.Less(p, p0) THEN
							q := p; p := p0; p0 := q;
						END;
						IF t.Less(p2, p0) THEN
							p := p0;
						ELSIF t.Less(p2, p) THEN
							p := p2;
						END;
						i := l; j := r;
						REPEAT
							WHILE t.Less(i, p) DO
								INC(i);
							END;
							WHILE t.Less(p, j) DO
								DEC(j);
							END;
							IF i <= j THEN
								t.Swap(i, j);
								IF p = i THEN
									p := j;
								ELSIF p = j THEN
									p := i;
								END;
								INC(i); DEC(j);
							END;
						UNTIL i > j;
						IF j - l < r - i THEN
							Sort(l, j);
							l := i;
						ELSE
							Sort(i, r);
							r := j;
						END;
					END;
				END;
			END Sort;
		
		BEGIN (*QuickSort*)
			Sort(0, len - 1);
		END QuickSort;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			g := UtilAlea.New();
		END Init;
	
	BEGIN (*UtilSort*)
		Init;
	END UtilSort.