(* 
Util: Utility tools.

Copyright (C) 2001…2006 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE UtilSort;
	
	
	
	IMPORT
		
		UtilAlea;
	
	TYPE
		
		T* = ABSTRACT RECORD;
		END;
	
	VAR
		
		g: UtilAlea.Generator;
	
	PROCEDURE (VAR t: T) Less- (p1, p2: INTEGER): BOOLEAN, NEW, ABSTRACT;
	
	PROCEDURE (VAR t: T) Swap- (p1, p2: INTEGER), NEW, EMPTY;
	
	PROCEDURE (VAR t: T) BinSearch* (min, max: INTEGER; VAR target: INTEGER), NEW;
		
		VAR
			
			i, j, k: INTEGER;
		
		BEGIN (*BinSearch*)
			i := min; j := max + 1;
			WHILE i < j DO
				k := (i + j) DIV 2;
				IF t.Less(k, target) THEN
					i := k + 1;
				ELSE
					j := k;
				END;
			END;
			IF (j <= max) & ~t.Less(j, target) & ~t.Less(target, j) THEN
				target := j;
			END;
		END BinSearch;
	
	PROCEDURE (VAR t: T) QuickSort* (min, max: INTEGER), NEW;
		
		CONST
			
			maxIns = 24;
		
		PROCEDURE Insertion (l, r: INTEGER);
			
			VAR
				
				i, j: INTEGER;
			
			BEGIN (*Insertion*)
				FOR i := l + 1 TO r DO
					j := i;
					WHILE (j > l) & t.Less(j, j - 1) DO
						t.Swap(j, j - 1);
						DEC(j);
					END;
				END;
			END Insertion;
		
		PROCEDURE Sort (l, r: INTEGER);
			
			VAR
				
				i, j, p0, p, p2, q: INTEGER;
			
			BEGIN (*Sort*)
				LOOP
					IF r - l < maxIns THEN
						Insertion(l, r);
						EXIT;
					ELSE
						p0 := SHORT(g.IntRand(l, r + 1));
						p := SHORT(g.IntRand(l, r + 1));
						p2 := SHORT(g.IntRand(l, r + 1));
						IF t.Less(p, p0) THEN
							q := p; p := p0; p0 := q;
						END;
						IF t.Less(p2, p0) THEN
							p := p0;
						ELSIF t.Less(p2, p) THEN
							p := p2;
						END;
						i := l; j := r;
						REPEAT
							WHILE t.Less(i, p) DO
								INC(i);
							END;
							WHILE t.Less(p, j) DO
								DEC(j);
							END;
							IF i <= j THEN
								t.Swap(i, j);
								IF p = i THEN
									p := j;
								ELSIF p = j THEN
									p := i;
								END;
								INC(i); DEC(j);
							END;
						UNTIL i > j;
						IF j - l < r - i THEN
							Sort(l, j);
							l := i;
						ELSE
							Sort(i, r);
							r := j;
						END;
					END;
				END;
			END Sort;
		
		BEGIN (*QuickSort*)
			Sort(min, max);
		END QuickSort;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			g := UtilAlea.New();
		END Init;
	
	BEGIN (*UtilSort*)
		Init;
	END UtilSort.
