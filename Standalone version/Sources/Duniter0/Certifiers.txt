(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0Certifiers;
	
	

	IMPORT
		
		A := UtilAvlTree, BA := Duniter0Basic, B := Duniter0Blockchain, Math, StdLog, UtilSort;
	
	CONST
		
		month = 365.25 / 12 * 24 * 60 * 60; (* s *)
	
	TYPE
		
		CertRate = POINTER TO RECORD
			id: B.String;
			registration: LONGINT;
			cpt: REAL;
		END;
		
		CertRateSort = EXTENSIBLE RECORD (UtilSort.T)
			c: POINTER TO ARRAY OF CertRate;
		END;
		
		CertRateSortId = RECORD (CertRateSort)
		END;
	
	PROCEDURE (VAR s: CertRateSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			c: CertRate;
		
		BEGIN (*Swap*)
			c := s.c[p1]; s.c[p1] := s.c[p2]; s.c[p2] := c;
		END Swap;
	
	PROCEDURE (VAR s: CertRateSort) Less (c1, c2: INTEGER): BOOLEAN, EXTENSIBLE;
		
		BEGIN (*Less*)
			RETURN (s.c[c1].cpt < s.c[c2].cpt) OR (s.c[c1].cpt = s.c[c2].cpt) & (BA.CompP(s.c[c1].id, s.c[c2].id) = A.lt);
		END Less;
	
	PROCEDURE (VAR s: CertRateSortId) Less (c1, c2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN BA.CompP(s.c[c1].id, s.c[c2].id) = A.lt;
		END Less;
	
	PROCEDURE CertPerTime (p: B.Pubkey; now: LONGINT): REAL;
		
		VAR
			
			pos: B.CertPos;
			b: BOOLEAN;
			from, to: B.Pubkey;
			id: B.String;
			h: B.Hash;
			bnb: INTEGER;
			exp, mt, t, tc, tt: LONGINT;
		
		BEGIN (*CertPerTime*)
			IF B.CertFrom(p, pos) THEN
				b := B.IdPub(p, id, h, bnb, exp) & B.TimeOf(bnb, mt, t); ASSERT(b);
				ASSERT(now >= t);
				tt := now - t;
				WHILE pos.CertNextPos(from, to) DO
					b := B.Cert(from, to, bnb, exp) & B.TimeOf(bnb, mt, tc); ASSERT(b);
					INC(tt, MAX(0, B.pars.sigPeriod - (tc - t)));
				END;
				RETURN pos.CertPosLen() / tt * month;
			END;
			RETURN 0.;
		END CertPerTime;
	
	PROCEDURE MeanCertPerTime (now: LONGINT; OUT m, dev, min, max: REAL);
		
		VAR
			
			ok: BOOLEAN;
			p: B.Pubkey;
			cpt: REAL;
			n: INTEGER;
		
		BEGIN (*MeanCertPerTime*)
			m := 0.; dev := 0.; n := 0;
			min := MAX(REAL); max := 0.;
			ok := B.IdNextPubkey(TRUE, p);
			WHILE ok DO
				cpt := CertPerTime(p, now);
				INC(n);
				m := m + cpt;
				dev := dev + cpt * cpt;
				min := MIN(min, cpt);
				max := MAX(max, cpt);
				ok := B.IdNextPubkey(FALSE, p);
			END;
			m := m / n;
			dev := Math.Sqrt(dev / n - m * m);
		END MeanCertPerTime;
	
	PROCEDURE CertPerMember (): REAL;
		
		VAR
			
			n: INTEGER;
			ok: BOOLEAN;
			pos: B.CertPos;
		
		BEGIN (*CertPerMember*)
			n := 0;
			ok := B.CertNextTo(TRUE, pos);
			WHILE ok DO
				INC(n, pos.CertPosLen());
				ok := B.CertNextTo(FALSE, pos);
			END;
			RETURN n / B.IdLen();
		END CertPerMember;
	
	PROCEDURE Count* (OUT certRates, certRatesId: POINTER TO ARRAY OF CertRate; OUT totCertRates: REAL);
		
		VAR
			
			ok: BOOLEAN;
			p: B.Pubkey;
			i, bnb: INTEGER;
			h: B.Hash;
			exp: LONGINT;
			b: BOOLEAN;
			c: CertRate;
			s: CertRateSort;
			sId: CertRateSortId;
		
		BEGIN (*Count*)
			totCertRates := 0.;
			NEW(certRates, B.IdLen());
			i := 0;
			ok := B.IdNextPubkey(TRUE, p);
			WHILE ok DO
				NEW(c);
				b := B.IdPub(p, c.id, h, bnb, exp) & B.TimeOf(bnb, exp, c.registration); ASSERT(b);
				c.cpt := CertPerTime(p, B.RealNow());
				totCertRates := totCertRates + c.cpt;
				certRates[i] := c;
				INC(i);
				ok := B.IdNextPubkey(FALSE, p);
			END;
			s.c := certRates;
			s.QuickSort(LEN(certRates));
			NEW(certRatesId, LEN(certRates));
			FOR i := 0 TO LEN(certRates) - 1 DO
				certRatesId[i] := certRates[i];
			END;
			sId.c := certRatesId;
			sId.QuickSort(LEN(certRatesId));
		END Count;
	
	PROCEDURE Print*;
		
		VAR
			
			certRates, certRatesId: POINTER TO ARRAY OF CertRate;
			i, m, n50, n90: INTEGER;
			n, totCertRates, mean, dev, min, max, cpm: REAL;
			s: BA.DateTime;
		
		BEGIN (*Print*)
			StdLog.Clear;
			StdLog.Open;
			Count(certRates, certRatesId, totCertRates);
			m := LEN(certRates);
			FOR i := 0 TO m - 1 DO
				StdLog.Tab;
				StdLog.Int(i);
				StdLog.Tab;
				StdLog.Real(certRates[i].cpt);
				StdLog.Tab;
				StdLog.Int(B.RealNow() - certRates[i].registration);
				StdLog.Ln;
			END;
			StdLog.String('~'); StdLog.Ln;
			FOR i := 0 TO m - 1 DO
				StdLog.Tab;
				StdLog.Int(i);
				StdLog.Tab;
				StdLog.Real(certRates[i].cpt);
				StdLog.Tab;
				StdLog.String(certRates[i].id);
				StdLog.Tab;
				BA.TimestampToString(certRates[i].registration, s);
				StdLog.String(s);
				StdLog.Ln;
			END;
			StdLog.Ln;
			FOR i := 0 TO m - 1 DO
				StdLog.Tab;
				StdLog.String(certRatesId[i].id);
				StdLog.Tab;
				StdLog.Real(certRatesId[i].cpt);
				StdLog.Tab;
				BA.TimestampToString(certRatesId[i].registration, s);
				StdLog.String(s);
				StdLog.Ln;
			END;
			StdLog.Ln;
			StdLog.String("Certificateur -> Nombre de certifications / mois");
			StdLog.Ln; StdLog.Ln;
			n := 0.;
			FOR i := 0 TO m - 1 DO
				n := n + certRates[i].cpt;
				IF n < totCertRates * 0.5 THEN
					n50 := i;
				END;
				IF n < totCertRates * 0.1 THEN
					n90 := i;
				END;
			END;
			StdLog.String("Proportion des plus gros certificateurs faisant 50% ou plus des certifications / mois : ");
			StdLog.Real((m - n50) / m); StdLog.Ln;
			StdLog.String("Proportion des plus gros certificateurs faisant 90% ou plus des certifications / mois : ");
			StdLog.Real((m - n90) / m); StdLog.Ln;
			
			StdLog.Ln;
			
			MeanCertPerTime(B.RealNow(), mean, dev, min, max);
			StdLog.String("Certifications par unité de temps :"); StdLog.Ln;
			StdLog.String("Moyenne = "); StdLog.Real(mean); StdLog.String(" certs / month");
			StdLog.Ln;
			StdLog.String("Écart type = "); StdLog.Real(dev); StdLog.String(" certs / month");
			StdLog.Ln;
			StdLog.String("Minimum = "); StdLog.Real(min); StdLog.String(" certs / month");
			StdLog.Ln;
			StdLog.String("Maximum = "); StdLog.Real(max); StdLog.String(" certs / month");
			StdLog.Ln; StdLog.Ln;
			
			cpm := CertPerMember();
			StdLog.String("Certifications par membre :"); StdLog.Ln;
			StdLog.String("CpM = "); StdLog.Real(cpm);
			StdLog.Ln; StdLog.Ln;
			
			StdLog.String("Taux de croissance :"); StdLog.Ln;
			StdLog.String("c = "); StdLog.Real(mean / cpm * 100);
			StdLog.String(" % / month");
			StdLog.Ln; StdLog.Ln;
		END Print;
	
	END Duniter0Certifiers.

Duniter0Certifiers.Print;