(* 
Duniter0: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0Blockchain;
	
	
	
	(* Version with the blockchain's data in a UtilBTree file on disk *)
	
	(* Nouveau protocole : https://forum.duniter.org/t/renouvellement-des-certifications/4757?u=gerard94. Pouvoir renouveler une certification avant sa limite de validité *)
	
	IMPORT
		
		(*
		L := StdLog,
		*)
	
		A := UtilAvlTree, B := UtilBBTree2, Dialog, BA := Duniter0Basic, Files, HostFiles, Math, Services, S := SqlDB, Strings, TextMappers, TextModels, TextViews, UtilSort, U := UtilSets, Views;
	
	CONST
		
		(* Driver SQLite *)
		driver* = "SQLiteDriver";
		
		(* Directory & name of the file where the path to the Duniter database is written *)
		initDir = "Duniter0/Rsrc";
		initName = "Init.odc";
		
		(* Number of pages used by UtilBTree *)
		pageNb = 2000;
		
		(* Max length of a Pubkey *)
		pubkeyLen* = 44;
		
		(* Max length of a Hash *)
		hashLen* = 64;
		
		secureGap = 100; (* Number of last blocks to be read again at every update, since they could have changed *)
		
		dBase = "Duniter0\DBase.data"; (* Name of the WotWizard database, in the WotWizard.exe directory *)
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0; (* Index timeT *)
		joinAndLeavePlace = 1; (* Index joinAndLeaveT *)
		idPubPlace = 2; (* Index idPubT *)
		idUidPlace = 3; (* Index idUidT *)
		idTimePlace = 4; (* Index idTimeT *)
		certFromPlace = 5; (* Index certFromT *)
		certToPlace = 6; (* Index certToT *)
		certTimePlace = 7; (* Index certTimeT *)
		undoListPlace = 8; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 9; (* Last read block *)
		idLenPlace = 10; (* Number of actual members *)
		
		placeNb = 11; (* Number of places *)
	
	TYPE
		
		(* Procedure called at every update *)
		UpdateProc* = PROCEDURE (VAR changed: BOOLEAN);
		
		(* Chained list of procedures called at every update *)
		UpdateList = POINTER TO RECORD
			next: UpdateList;
			update: UpdateProc;
		END;
		
		(* Action for updating DBase.data *)
		UpdateAction = POINTER TO RECORD (Services.Action)
		END;
		
		String* = BA.String;
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		Hash* = ARRAY hashLen + 1 OF CHAR;
		
		StringArr* = POINTER TO ARRAY OF String;
		
		(* Duniter Parameters *)
		Parameters* = RECORD
			
			(* The %growth of the UD every [dtReeval] period = 0.0488 /  (6 months) = 4.88% / (6 months) *)
			c-: REAL;
			
			(* Time period between two UD = 86400 s = 1 day *)
			dt-,
			
			(* UD(0), i.e. initial Universal Dividend = 1000 cents = 10 Ğ1 *)
			ud0-,
			
			(* Minimum delay between 2 certifications of a same issuer = 432000 s = 5 days *)
			sigPeriod-,
			
			(* Maximum quantity of active certifications made by member = 100 *)
			sigStock-,
			
			(* Maximum delay a certification can wait before being expired for non-writing = 5259600 s = 2 months *)
			sigWindow-,
			
			(* Maximum age of an active certification = 63115200 s = 2 years *)
			sigValidity-,
			
			(* Minimum quantity of signatures to be part of the WoT = 5 *)
			sigQty-,
			
			(* Maximum delay an identity can wait before being expired for non-writing = 5259600 s = 2 months *)
			idtyWindow-,
			
			(* Maximum delay a membership can wait before being expired for non-writing = 5259600 s = 2 months *)
			msWindow-,
			
			(* Minimum delay between 2 memberships of a same issuer = 5259600 s = 2 months *)
			msPeriod-: INTEGER;
			
			(* Minimum percent of sentries to reach to match the distance rule = 0.8 = 80% *)
			xpercent-: REAL;
			
			(* Maximum age of an active membership = 31557600 s = 1 year *)
			msValidity-,
			
			(* Maximum distance between a newcomer and [xpercent] of sentries = 5 *)
			stepMax-,
			
			(* Number of blocks used for calculating median time = 24 *)
			medianTimeBlocks-,
			
			(* The average time for writing 1 block (wished time) = 300 s = 5 min *)
			avgGenTime-,
			
			(* The number of blocks required to evaluate again PoWMin value = 12 *)
			dtDiffEval-: INTEGER;
			
			(* The percent of previous issuers to reach for personalized difficulty = 0.67 = 67% *)
			percentRot-: REAL;
			
			(* Time of first UD = 1488970800 s = 2017/03/08 11:00:00 UTC+0 *)
			udTime0-,
			
			(* Time of first reevaluation of the UD = 1490094000 s = 2017/03/21 11:00:00 UTC+0 *)
			udReevalTime0-: LONGINT;
			
			(* Time period between two re-evaluation of the UD = 15778800 s = 6 months *)
			dtReeval-,
			
			(* Maximum delay a transaction can wait before being expired for non-writing = 604800 s = 7 days *)
			txWindow-: INTEGER;
			
		END;
	
	CONST
		
		(* Types of elements in UndoList *) (******************)
		timeList = 0;
		idAddList = 1;
		joinList = 2;
		activeList = 3;
		leaveList = 4;
		idAddTimeList = 5;
		idRemoveTimeList = 6;
		certAddList = 7;
		certRemoveList = 8;
		remCertifiers = 9;
		remCertified = 10;
		
		hasNotLeaved* = -1;
	
	TYPE
		
		(* Chained list of the operations to be undone before every update *)
		UndoList = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			next: LONGINT;
			type: BYTE;
			(* timeList -> Time; joinList, activeList, leaveList -> Identity; certAddList, certRemoveList -> Certification *) (***************)
			ref,
			aux: LONGINT;
		END;
		
		(* Factory of UndoList *)
		UndoListFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			bnb: INTEGER;
			mTime,
			time: LONGINT;
		END;
		
		(* Factory of Time *)
		TimeFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeaveL = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			next: LONGINT;
			joiningBlock, (* Block numbers *)
			leavingBlock: INTEGER;
		END;
		
		(* Factory of JoinAndLeaveL *)
		JoinAndLeaveLFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeave = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			pubkey: Pubkey;
			list: LONGINT; (* JoinAndLeaveL *)
		END;
		
		(* Factory of JoinAndLeave *)
		JoinAndLeaveFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Identity = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			pubkey: Pubkey;
			uid: String;
			member: BOOLEAN;
			hash: Hash;
			block_number: INTEGER; (* Where the Identity is written *)
			expires_on,
			certifiers, (* Index of all certifiers uid, old or present, of this Identity ; B.String -> nothing *)
			certified: LONGINT; (* Index of all uid, old or present, certified by this Identity ; B.String -> nothing *)
		END;
		
		(* Factory of Identity *)
		IdentityFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Certification = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			from,
			to: Pubkey;
			block_number: INTEGER; (* Where the Certification is written *)
			expires_on: LONGINT;
		END;
		
		(* Factory of Certification *)
		CertificationFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* INTEGER index key *)
		IntKey = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			ref: INTEGER;
		END;
		
		(* Factory of IntKey *)
		IntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of IntKey *)
		IntKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* LONGINT index key *)
		LIntKey = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			ref: LONGINT;
		END;
		
		(* Factory of LIntKey *)
		LIntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data) (* # Pubkey! *)
			dataType: BYTE;
			ref: Pubkey;
		END;
		
		(* Factory of PubKey *)
		PubKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of PubKey *)
		PubKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Uid index key manager *)
		UidKeyMan = POINTER TO RECORD (B.StringKeyManager) 
		END;
		
		(* Manager of Identity sorted by expiration dates *)
		IdKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Manager of Certification sorted by expiration dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Current position in a Certification sub-index *)
		CertPos* = RECORD
			posRef: LONGINT; (* Root of the sub-index *)
			posCur: B.IndexPos; (* Position in the sub-index *)
		END;
		
		(* Member, Members, MembersFind: Distance Rule *)
		Member = RECORD
			p: Pubkey;
			links: U.Set;
		END;
		
		Members = POINTER TO ARRAY OF Member;
		
		MembersFind = RECORD (UtilSort.T)
			len: INTEGER;
			m: Members;
		END;
		
		Pubkeys = POINTER TO ARRAY OF Pubkey;
		
		PoSE = POINTER TO RECORD (A.Elem)
			pubkeys: Pubkeys;
			set_1,
			set_2: U.Set;
			poS: REAL;
		END;
	
	CONST
		
		(* Types of Data *)
		undoListType = 1;
		timeType = 2;
		joinAndLeaveLType = 3;
		joinAndLeaveType = 4;
		identityType = 5;
		certificationType = 6;
		intKeyType = 7;
		lIntKeyType = 8;
		pubKeyType = 9;
		
		minDelay = 2 * 60 * Services.resolution; (* Minimum delay between two updates *)
		
		(* Sizes of B.Data *)
		pubKeyS = (pubkeyLen + 1) * B.CHS;
	
	VAR
		
		duniBase-: Files.Name; (* Path to the Duniter database *)
		
		updateList: UpdateList; (* Head of general UpdateList *)
		update: UpdateAction;
		updateChanged: BOOLEAN;
		
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		joinAndLeaveT, (* PubKey -> JoinAndLeave *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		idTimeT, (* LIntKey -> nothing; addresses of Identity sorted by expiration dates *)
		certFromT, certToT, (* PubKey -> sub-index(PubKey -> Certification) *)
		certTimeT: B.Index; (* LIntKey -> nothing; addresses of Certification sorted by expiration dates *)
		
		(* Sentries & Distance Rule *)
		members: MembersFind;
		sentriesS: U.Set; (* Set of sentries *)
		sentriesI: U.SetIterator; (* Iterator of sentriesS *)
		poST: A.Tree;
		
		undoList: LONGINT; (* Head of UndoList *)
		
		(* Current positions in indexes *)
		jlPubkeyCur,
		idPubkeyCur,
		idUidCur,
		certFromCur,
		certToCur: B.IndexPos;
		sentryCur: INTEGER;
		
		delay, (* Wished delay between two updates *)
		lastBlock: INTEGER; (* Last read & updated block *)
		now, rNow: LONGINT; (* Present medianTime and time *)
		idLenM: INTEGER; (* Number of members *)
		
		(* Factories *)
		undoListFac: UndoListFac;
		timeFac: TimeFac;
		joinAndLeaveLFac: JoinAndLeaveLFac;
		joinAndLeaveFac: JoinAndLeaveFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		lIntKeyFac: LIntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		
		(* Data managers *)
		timeMan,
		joinAndLeaveLMan,
		joinAndLeaveMan,
		idMan,
		certMan,
		undoListMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: UidKeyMan;
		intKeyMan: IntKeyMan;
		idKTimeMan: IdKTimeMan;
		certKTimeMan: CertKTimeMan;
	
	PROCEDURE (p1: PoSE) Compare (p2: A.Elem): BYTE;
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*Compare*)
			WITH p2: PoSE DO
				IF LEN(p1.pubkeys) < LEN(p2.pubkeys) THEN
					RETURN BA.lt;
				END;
				IF LEN(p1.pubkeys) > LEN(p2.pubkeys) THEN
					RETURN BA.gt;
				END;
				FOR i := 0 TO LEN(p1.pubkeys) - 1 DO
					IF p1.pubkeys[i]$ < p2.pubkeys[i]$ THEN
						RETURN BA.lt;
					END;
					IF p1.pubkeys[i]$ > p2.pubkeys[i]$ THEN
						RETURN BA.gt;
					END;
				END;
				RETURN BA.eq;
			END;
		END Compare;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.dataType := r.InByte(); ASSERT(t.dataType = timeType, 100);
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
			t.time := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			t.dataType := timeType; w.OutByte(t.dataType);
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
			w.OutLInt(t.time);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (jlL: JoinAndLeaveL) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jlL.dataType := r.InByte(); ASSERT(jlL.dataType = joinAndLeaveLType, 100);
			jlL.next := r.InLInt();
			jlL.joiningBlock := r.InInt();
			jlL.leavingBlock := r.InInt();
		END Read;
	
	PROCEDURE (jlL: JoinAndLeaveL) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			jlL.dataType := joinAndLeaveLType; w.OutByte(jlL.dataType);
			w.OutLInt(jlL.next);
			w.OutInt(jlL.joiningBlock);
			w.OutInt(jlL.leavingBlock);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveLFac) New (size: INTEGER): JoinAndLeaveL;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*New*)
			NEW(jlL);
			RETURN jlL;
		END New;
	
	PROCEDURE (jl: JoinAndLeave) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jl.dataType := r.InByte(); ASSERT(jl.dataType = joinAndLeaveType, 100);
			r.InChars(jl.pubkey);
			jl.list := r.InLInt();
		END Read;
	
	PROCEDURE (jl: JoinAndLeave) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			jl.dataType := joinAndLeaveType; w.OutByte(jl.dataType);
			w.OutChars(jl.pubkey);
			w.OutLInt(jl.list);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveFac) New (size: INTEGER): JoinAndLeave;
		
		VAR
			
			jl: JoinAndLeave;
		
		BEGIN (*New*)
			NEW(jl);
			RETURN jl;
		END New;
	
	PROCEDURE (id: Identity) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			id.dataType := r.InByte(); ASSERT(id.dataType = identityType, 100);
			r.InChars(id.pubkey);
			NEW(id.uid, r.InCharsLen() + 1); r.InChars(id.uid);
			id.member := r.InBool();
			r.InChars(id.hash);
			id.block_number := r.InInt();
			id.expires_on := r.InLInt();
			id.certifiers := r.InLInt();
			id.certified := r.InLInt();
		END Read;
	
	PROCEDURE (id: Identity) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			id.dataType := identityType; w.OutByte(id.dataType);
			w.OutChars(id.pubkey);
			w.OutChars(id.uid);
			w.OutBool(id.member);
			w.OutChars(id.hash);
			w.OutInt(id.block_number);
			w.OutLInt(id.expires_on);
			w.OutLInt(id.certifiers);
			w.OutLInt(id.certified);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			c.dataType := r.InByte(); ASSERT(c.dataType = certificationType, 100);
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			c.dataType := certificationType; w.OutByte(c.dataType);
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (l: UndoList) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.dataType := r.InByte(); ASSERT(l.dataType = undoListType, 100);
			l.next := r.InLInt();
			l.type := r.InByte();
			l.ref := r.InLInt();
			l.aux := r.InLInt();
		END Read;
	
	PROCEDURE (l: UndoList) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			l.dataType := undoListType; w.OutByte(l.dataType);
			w.OutLInt(l.next);
			w.OutByte(l.type);
			w.OutLInt(l.ref);
			w.OutLInt(l.aux);
		END Write;
	
	PROCEDURE (lf: UndoListFac) New (size: INTEGER): UndoList;
		
		VAR
			
			l: UndoList;
		
		BEGIN (*New*)
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.dataType := r.InByte(); ASSERT(i.dataType = intKeyType, 100);
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			i.dataType := intKeyType; w.OutByte(i.dataType);
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.BYS + B.INS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (l: LIntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.dataType := r.InByte(); ASSERT(l.dataType = lIntKeyType, 100);
			l.ref := r.InLInt();
		END Read;
	
	PROCEDURE (l: LIntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			l.dataType := lIntKeyType; w.OutByte(l.dataType);
			w.OutLInt(l.ref);
		END Write;
	
	PROCEDURE (lf: LIntKeyFac) New (size: INTEGER): LIntKey;
		
		VAR
			
			l: LIntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.BYS + B.LIS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			pub.dataType := r.InByte(); ASSERT(pub.dataType = pubKeyType, 100);
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			pub.dataType := pubKeyType; w.OutByte(pub.dataType);
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (pf: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			ASSERT(PKMCompP(p1, p2) = B.lt, 21);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	(* Comparison method of two Strings. Use the lexical order. *)
	PROCEDURE (um: UidKeyMan) CompP (key1, key2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			ASSERT((key1 # NIL) & (key2 # NIL), 20);
			WITH key1: B.String DO
				WITH key2: B.String DO
					IF key1.c = NIL THEN
						IF key2.c = NIL THEN
							RETURN B.eq;
						END;
						RETURN B.lt;
					END;
					IF key2.c = NIL THEN
						RETURN B.gt;
					END;
					RETURN BA.CompP(key1.c, key2.c);
				END;
			END;
		END CompP;
	
	(* Comparison of Identity(s) by expiration dates *)
	PROCEDURE (im: IdKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			id1, id2: Identity;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				id1 := idMan.ReadData(l1.ref)(Identity);
			END;
			WITH l2: LIntKey DO
				id2 := idMan.ReadData(l2.ref)(Identity);
			END;
			IF ABS(id1.expires_on) < ABS(id2.expires_on) THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired identities *)
			END;
			IF ABS(id1.expires_on) > ABS(id2.expires_on) THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ < id2.pubkey$ THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ > id2.pubkey$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* Comparison of Certification(s) by expiration dates *)
	PROCEDURE (im: CertKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				c1 := certMan.ReadData(l1.ref)(Certification);
			END;
			WITH l2: LIntKey DO
				c2 := certMan.ReadData(l2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired certifications *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	PROCEDURE (VAR m: MembersFind) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN m.m[i].p < m.m[j].p;
		END Less;
	
	PROCEDURE FindMemberNum (p: Pubkey; OUT n: INTEGER): BOOLEAN;
		
		BEGIN (*FindMemberNum*)
			n := members.len;
			members.m[n].p := p;
			members.BinSearch(0, n - 1, n);
			RETURN n < members.len;
		END FindMemberNum;
	
	(* Last read & updated block *)
	PROCEDURE LastBlock* (): INTEGER;
		
		BEGIN (*LastBlock*)
			RETURN lastBlock;
		END LastBlock;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* time *)
	PROCEDURE RealNow* (): LONGINT;
		
		BEGIN (*RealNow*)
			RETURN rNow;
		END RealNow;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b, 100);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL, 101);
					database.WritePlace(timePlace, database.CreateIndex(B.BYS + B.INS));
					database.WritePlace(joinAndLeavePlace, database.CreateIndex(0));
					database.WritePlace(idPubPlace, database.CreateIndex(0));
					database.WritePlace(idUidPlace, database.CreateIndex(0));
					database.WritePlace(idTimePlace, database.CreateIndex(B.BYS + B.LIS));
					database.WritePlace(certFromPlace, database.CreateIndex(0));
					database.WritePlace(certToPlace, database.CreateIndex(0));
					database.WritePlace(certTimePlace, database.CreateIndex(B.BYS + B.LIS));
					database.WritePlace(undoListPlace, B.bNil);
					database.WritePlace(lastNPlace, 0);
					database.WritePlace(idLenPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				joinAndLeaveLMan := database.CreateDataMan(joinAndLeaveLFac);
				joinAndLeaveMan := database.CreateDataMan(joinAndLeaveFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				undoListMan := database.CreateDataMan(undoListFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				joinAndLeaveT := database.OpenIndex(database.ReadPlace(joinAndLeavePlace), pubKeyMan, pubKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				idTimeT := database.OpenIndex(database.ReadPlace(idTimePlace), idKTimeMan, lIntKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
				certTimeT := database.OpenIndex(database.ReadPlace(certTimePlace), certKTimeMan, lIntKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf* (bnb: INTEGER; OUT mTime, time: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				time := t.time;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPub* (IN pubkey: Pubkey; OUT list: LONGINT): BOOLEAN;
		
		VAR
			
			jl: JoinAndLeave;
			jlP: PubKey;
		
		BEGIN (*JLPub*)
			NEW(jlP);
			jlP.ref := pubkey;
			IF joinAndLeaveT.Search(jlP) THEN
				jl := joinAndLeaveMan.ReadData(joinAndLeaveT.ReadValue())(JoinAndLeave);
				list := jl.list;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END JLPub;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPubLNext* (VAR list: LONGINT; OUT joiningBlock, leavingBlock: INTEGER): BOOLEAN;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*JLPubLNext*)
			IF list = B.bNil THEN
				RETURN FALSE;
			END;
			jlL := joinAndLeaveLMan.ReadData(list)(JoinAndLeaveL);
			list := jlL.next;
			joiningBlock := jlL.joiningBlock;
			leavingBlock := jlL.leavingBlock;
			RETURN TRUE;
		END JLPubLNext;
	
	(* Number of JoinAndLeave *)
	PROCEDURE JLLen* (): INTEGER;
		
		BEGIN (*JLLen*)
			RETURN joinAndLeaveT.NumberOfKeys();
		END JLLen;
	
	(* Browse all JoinAndLeave's pubkeys step by step *)
	PROCEDURE JLNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*JLNextPubkey*)
			IF first THEN
				joinAndLeaveT.ResetPos;
			ELSE
				joinAndLeaveT.SetCurrPos(jlPubkeyCur);
			END;
			joinAndLeaveT.Next;
			jlPubkeyCur := joinAndLeaveT.GetCurrPos();
			IF ~joinAndLeaveT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := joinAndLeaveT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END JLNextPubkey;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPub*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPubM* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPubM*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				IF ~id.member THEN
					RETURN FALSE;
				END;
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubM;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPubComplete* (IN pubkey: Pubkey; OUT uid: String; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPubComplete*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubComplete;
	
	(* uid -> Identity *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* uid -> Identity *)
	PROCEDURE IdUidM* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUidM*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				IF ~id.member THEN
					RETURN FALSE;
				END;
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUidM;
	
	(* uid -> Identity *)
	PROCEDURE IdUidComplete* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUidComplete*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUidComplete;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idUidT.NumberOfKeys();
		END IdLen;
	
	(* Number of identities *)
	PROCEDURE IdLenM* (): INTEGER;
		
		BEGIN (*IdLenM*)
			RETURN idLenM;
		END IdLenM;
	
	(* Position next Identity's pubkey for IdNextPubkey *)
	PROCEDURE IdPosPubkey* (IN pubkey: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
		
		BEGIN (*IdPosPubkey*)
			NEW(idP);
			idP.ref := pubkey;
			b := idPubT.Search(idP);
			idPubT.Previous;
			idPubkeyCur := idPubT.GetCurrPos();
		END IdPosPubkey;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			idPubT.Next;
			idPubkeyCur := idPubT.GetCurrPos();
			IF ~idPubT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := idPubT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkeyM* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextPubkeyM*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			REPEAT
				idPubT.Next;
				idPubkeyCur := idPubT.GetCurrPos();
				IF ~idPubT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
			UNTIL id.member;
			pubkey := id.pubkey;
			RETURN TRUE;
		END IdNextPubkeyM;
	
	(* Position next Identity's uid for IdNextUid *)
	PROCEDURE IdPosUid* (IN uid: ARRAY OF CHAR);
		
		VAR
			
			idU: B.String;
			b: BOOLEAN;
		
		BEGIN (*IdPosUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			b := idUidT.Search(idU);
			idUidT.Previous;
			idUidCur := idUidT.GetCurrPos();
		END IdPosUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			idUidT.Next;
			idUidCur := idUidT.GetCurrPos();
			IF ~idUidT.PosSet() THEN
				RETURN FALSE;
			END;
			uid := idUidT.CurrentKey()(B.String).c;
			RETURN TRUE;
		END IdNextUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUidM* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextUidM*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			REPEAT
				idUidT.Next;
				idUidCur := idUidT.GetCurrPos();
				IF ~idUidT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
			UNTIL id.member;
			uid := id.uid;
			RETURN TRUE;
		END IdNextUidM;
	
	(* (Pubkey, Pubkey) -> Certification *)
	PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertFrom*)
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				pos.posRef := certFromT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertFrom;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertTo* (IN to: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertTo*)
			NEW(p);
			p.ref := to;
			IF certToT.Search(p) THEN
				pos.posRef := certToT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertTo;
	
	(* Number of keys in sub-index *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		VAR
			
			ind: B.Index;
			n: INTEGER;
		
		BEGIN (*CertPosLen*)
			IF pos.posRef < 0 THEN
				RETURN 0;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			n := ind.NumberOfKeys();
			ind.Close;
			RETURN n;
		END CertPosLen;
	
	(* Browse all Certification's pairs of Pubkey in a sub-index step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from, to: Pubkey): BOOLEAN, NEW;
		
		VAR
			
			ind: B.Index;
			ok: BOOLEAN;
			c: Certification;
		
		BEGIN (*CertNextPos*)
			IF pos.posRef < 0 THEN
				RETURN FALSE;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.SetCurrPos(pos.posCur);
			ind.Next;
			pos.posCur := ind.GetCurrPos();
			ok := ind.PosSet();
			IF ok THEN
				c := certMan.ReadData(ind.ReadValue())(Certification);
				from := c.from;
				to := c.to;
			END;
			ind.Close;
			RETURN ok;
		END CertNextPos;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the from Pubkey *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromT.ResetPos;
			ELSE
				certFromT.SetCurrPos(certFromCur);
			END;
			certFromT.Next;
			certFromCur := certFromT.GetCurrPos();
			IF ~certFromT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certFromT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the to Pubkey *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certToT.ResetPos;
			ELSE
				certToT.SetCurrPos(certToCur);
			END;
			certToT.Next;
			certToCur := certToT.GetCurrPos();
			IF ~certToT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certToT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextTo;
	
	PROCEDURE AllCertifiers* (IN to: ARRAY OF CHAR; OUT from: StringArr);
		
		VAR
			
			idU: B.String;
			id: Identity;
			ind: B.Index;
			i: INTEGER;
		
		BEGIN (*AllCertifiers*)
			NEW(idU);
			NEW(idU.c, LEN(to$) + 1); idU.c^ := to$;
			IF ~idUidT.Search(idU) THEN
				from := NIL;
				RETURN;
			END;
			id := idMan.ReadData(idUidT.ReadValue())(Identity);
			IF id.certifiers = B.bNil THEN
				from := NIL;
				RETURN;
			END;
			ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
			NEW(from, ind.NumberOfKeys());
			ind.Next; i := 0;
			WHILE ind.PosSet() DO
				idU := ind.CurrentKey()(B.String);
				from[i] := idU.c;
				INC(i);
				ind.Next;
			END;
			ind.Close;
			ASSERT(i = LEN(from), 60);
		END AllCertifiers;
	
	PROCEDURE AllCertified* (IN from: ARRAY OF CHAR; OUT to: StringArr);
		
		VAR
			
			idU: B.String;
			id: Identity;
			ind: B.Index;
			i: INTEGER;
		
		BEGIN (*AllCertified*)
			NEW(idU);
			NEW(idU.c, LEN(from$) + 1); idU.c^ := from$;
			IF ~idUidT.Search(idU) THEN
				to := NIL;
				RETURN;
			END;
			id := idMan.ReadData(idUidT.ReadValue())(Identity);
			IF id.certified = B.bNil THEN
				to := NIL;
				RETURN;
			END;
			ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
			NEW(to, ind.NumberOfKeys());
			ind.Next; i := 0;
			WHILE ind.PosSet() DO
				idU := ind.CurrentKey()(B.String);
				to[i] := idU.c;
				INC(i);
				ind.Next;
			END;
			ind.Close;
			ASSERT(i = LEN(to), 60);
		END AllCertified;
	
	PROCEDURE IsSentry* (IN pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			e: INTEGER;
		
		BEGIN (*IsSentry*)
			RETURN FindMemberNum(pubkey, e) & sentriesS.In(e);
		END IsSentry;
	
	(* Return in pubkey the next sentry's pubkey if ~first or the first one if first; return FALSE if there is no more sentry *)
	PROCEDURE NextSentry* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*NextSentry*)
			IF first THEN
				b := sentriesI.FirstE(sentryCur);
			ELSE
				b := sentriesI.NextE(sentryCur);
			END;
			IF ~b THEN
				RETURN FALSE;
			END;
			pubkey := members.m[sentryCur].p;
			RETURN TRUE;
		END NextSentry;
	
	(* Return the number of sentries *)
	PROCEDURE SentriesLen* (): INTEGER;
		
		BEGIN (*SentriesLen*)
			RETURN sentriesS.nbElems;
		END SentriesLen;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentriesS* (IN pubkeys: ARRAY OF Pubkey; OUT set_1, set_2: U.Set): REAL;
		
		VAR
			
			set, frontier, newFrontier: U.Set;
			frontierI: U.SetIterator;
			e, i: INTEGER;
			ok: BOOLEAN;
			poS: REAL;
			poSE: PoSE;
		
		PROCEDURE Sort (pubkeys: ARRAY OF Pubkey);
			
			VAR
				
				i, j: INTEGER;
				p: Pubkey;
			
			BEGIN (*Sort*)
				FOR i := 1 TO LEN(pubkeys) - 1 DO
					p := pubkeys[i];
					j := i;
					WHILE (j > 0) & (p < pubkeys[j - 1]) DO
						pubkeys[j] := pubkeys[j - 1];
						DEC(j);
					END;
					pubkeys[j] := p;
				END;
			END Sort;
		
		PROCEDURE Find (poSE: PoSE; OUT set_1, set_2: U.Set; OUT poS: REAL): BOOLEAN;
			
			VAR
				
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Find*)
				e := poSE;
				IF ~poST.Search(e, n) THEN
					RETURN FALSE;
				END;
				WITH e: PoSE DO
					set_1 := e.set_1;
					set_2 := e.set_2;
					poS := e.poS;
				END;
				RETURN TRUE;
			END Find;
		
		PROCEDURE Store (poSE: PoSE; set_1, set_2: U.Set; poS: REAL);
			
			VAR
				
				b: BOOLEAN;
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Store*)
				poSE.set_1 := set_1;
				poSE.set_2 := set_2;
				poSE.poS := poS;
				e := poSE;
				b := poST.SearchIns(e, n); ASSERT(~b, 100);
			END Store;
		
		BEGIN (*PercentOfSentriesS*)
			Sort(pubkeys);
			NEW(poSE);
			NEW(poSE.pubkeys, LEN(pubkeys));
			FOR i := 0 TO LEN(pubkeys) - 1 DO
				poSE.pubkeys[i] := pubkeys[i];
			END;
			IF ~Find(poSE, set_1, set_2, poS) THEN
				set := U.NewSet();
				frontier := U.NewSet();
				FOR i := 0 TO LEN(pubkeys) - 1 DO
					IF FindMemberNum(pubkeys[i], e) THEN
						set.Incl(e);
						frontier.Incl(e);
					END;
				END;
				FOR i := 1 TO pars.stepMax - 1 DO
					newFrontier := U.NewSet();
					frontierI.Attach(frontier);
					ok := frontierI.FirstE(e);
					WHILE ok DO
						newFrontier := newFrontier.Union(members.m[e].links);
						ok := frontierI.NextE(e);
					END;
					frontier := newFrontier;
					set := set.Union(frontier);
					IF i = pars.stepMax - 2 THEN
						set_2 := set.Inter(sentriesS);
					END;
				END;
				set_1 := set.Inter(sentriesS);
				poS := set_1.nbElems / sentriesS.nbElems;
				Store(poSE, set_1, set_2, poS);
			END;
			RETURN poS;
		END PercentOfSentriesS;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentries* (IN pubkeys: ARRAY OF Pubkey): REAL;
		
		VAR
			
			set: U.Set;
		
		BEGIN (*PercentOfSentries*)
			RETURN PercentOfSentriesS(pubkeys, set, set);
		END PercentOfSentries;
	
	(* Verify the distance rule for a set of certifiers' pubkeys *)
	PROCEDURE DistanceRuleOk* (IN pubkeys: ARRAY OF Pubkey): BOOLEAN;
		
		BEGIN (*DistanceRuleOk*)
			RETURN PercentOfSentries(pubkeys) >= pars.xpercent;
		END DistanceRuleOk;
	
	(* Scan the string s from position i to the position of stop excluded; update i and return the scanned string in sub *)
	PROCEDURE ScanS (IN s: ARRAY OF CHAR; stop: CHAR; OUT sub: ARRAY OF CHAR; VAR i: INTEGER);
		
		VAR
			
			j: INTEGER;
		
		BEGIN (*ScanS*)
			j := 0;
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				sub[j] := s[i];
				INC(i); INC(j);
			END;
			sub[j] := 0X;
			INC(i);
		END ScanS;
	
	(* Skip the string s from position i to the position of stop excluded; update i *)
	PROCEDURE SkipS (IN s: ARRAY OF CHAR; stop: CHAR; VAR i: INTEGER);
		
		BEGIN (*SkipS*)
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				INC(i);
			END;
			INC(i);
		END SkipS;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params (d: S.Database);
		
		CONST
			
			txWindow = 60 * 60 * 24 * 7;
		
		VAR
			
			res: INTEGER;
			cur: S.Row;
			ss: POINTER TO ARRAY OF CHAR;
			s: ARRAY 20 OF CHAR;
			t: S.Table;
			i: INTEGER;
		
		BEGIN (*Params*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT parameters FROM block WHERE number = 0 AND NOT fork");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT(t.columns = 1, 102); ASSERT(t.rows = 1, 103);
			 t.Read(0, cur);
			ss := cur.fields[0];
			ss[LEN(ss$)] := ':';
			i := 0;
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.c, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dt, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.ud0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigPeriod, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigStock, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigQty, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.idtyWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.xpercent, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.stepMax, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.medianTimeBlocks, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.avgGenTime, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtDiffEval, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.percentRot, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udReevalTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtReeval, res); ASSERT(res = 0, 104);
			pars.txWindow := txWindow;
			pars.msPeriod := pars.msWindow;
		END Params;
	
	(* Add a block in timeT *)
	PROCEDURE Times (withList: BOOLEAN; IN s1, s2, s3: ARRAY OF CHAR);
		
		VAR
			
			t: Time;
			i: IntKey;
			res: INTEGER;
			tRef: LONGINT;
			b: BOOLEAN;
			tL: UndoList; (* timeList *)
		
		BEGIN (*Times*)
			NEW(t);
			Strings.StringToInt(s1, t.bnb, res); ASSERT(res = 0, 100);
			Strings.StringToLInt(s2, t.mTime, res); ASSERT(res = 0, 101);
			Strings.StringToLInt(s3, t.time, res); ASSERT(res = 0, 102);
			lastBlock := t.bnb;
			tRef := timeMan.WriteAllocateData(t);
			NEW(i); i.ref := t.bnb;
			b := timeT.SearchIns(i); ASSERT(~b, 103);
			timeT.WriteValue(tRef);
			IF withList THEN
				NEW(tL); tL.next := undoList; tL.type := timeList; tL.ref := tRef; tL.aux := 0;
				undoList := undoListMan.WriteAllocateData(tL);
			END;
			now := MAX(now, t.mTime);
			rNow := MAX(rNow, t.time);
		END Times;
	
	PROCEDURE RemoveCertifiersCertified (withList: BOOLEAN; idRef: LONGINT; id: Identity);
		
		VAR
			
			c1, c2: B.Index;
			idU1, idU2: B.String;
			id2Ref: LONGINT;
			id2: Identity;
			b: BOOLEAN;
			rL: UndoList; (*remCertifiers & remCertified *)
		
		BEGIN (*RemoveCertifiersCertified*)
			NEW(idU1); idU1.c := id.uid;
			
			IF id.certifiers # B.bNil THEN
				c1 := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
				c1.Next;
				WHILE c1.PosSet() DO
					idU2 := c1.CurrentKey()(B.String);
					b := idUidT.Search(idU2); ASSERT(b, 100);
					id2Ref := idUidT.ReadValue();
					id2 := idMan.ReadData(id2Ref)(Identity);
					ASSERT(id2.certified # B.bNil, 101);
					c2 := database.OpenIndex(id2.certified, uidKeyMan, uidKeyFac);
					b := c2.Erase(idU1); ASSERT(b, 102);
					b := c2.IsEmpty();
					c2.Close;
					IF b THEN
						database.DeleteIndex(id2.certified); id2.certified := B.bNil;
						idMan.WriteData(id2Ref, id2);
					END;
					IF withList THEN
						NEW(rL); rL.next := undoList; rL.type := remCertified; rL.ref := id2Ref; rL.aux := idRef;
						undoList := undoListMan.WriteAllocateData(rL);
					END;
					c1.Next;
				END;
				c1.Close;
			END;
			
			IF id.certified # B.bNil THEN
				c1 := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
				c1.Next;
				WHILE c1.PosSet() DO
					idU2 := c1.CurrentKey()(B.String);
					b := idUidT.Search(idU2); ASSERT(b, 103);
					id2Ref := idUidT.ReadValue();
					id2 := idMan.ReadData(id2Ref)(Identity);
					ASSERT(id2.certifiers # B.bNil, 104);
					c2 := database.OpenIndex(id2.certifiers, uidKeyMan, uidKeyFac);
					b := c2.Erase(idU1); ASSERT(b, 105);
					b := c2.IsEmpty();
					c2.Close;
					IF b THEN
						database.DeleteIndex(id2.certifiers); id2.certifiers := B.bNil;
						idMan.WriteData(id2Ref, id2);
					END;
					IF withList THEN
						NEW(rL); rL.next := undoList; rL.type := remCertifiers; rL.ref := id2Ref; rL.aux := idRef;
						undoList := undoListMan.WriteAllocateData(rL);
					END;
					c1.Next;
				END;
				c1.Close;
			END;
		END RemoveCertifiersCertified;
	
	(*
	- Le membre demande à partir ; il passe par les champs leavers et excluded ; ses éléments d'identité (uid et clé publique) peuvent être réutilisés par lui-même mais pas par d'autres.
	- Le membre révoque son identité explicitement ; champs revoked et excluded ; ses éléments d'identité sont bloqués à jamais.
	- Le membre ne renouvelle pas son appartenance dans les temps (ou perd ses sigQty certifications ???) ; champ excluded uniquement ; au bout d'un an, ses éléments d'identité sont bloqués à jamais (mais il n'apparaît dans aucun champ supplémentaire).
	*)
	(*
	La perte de certif ne provoque pas la révocation implicite. C’est bien le défaut de renouvellement qui provoque la révocation, les 2 mécanismes sont indépendants de ce point de vue.
Si les certifications reviennent, ça rend simplement l’adhésion possible à nouveau. C’est bien elle qui gère le cycle de vie du membre, les certifications ne sont qu’un prérequis.
Ainsi un membre qui n’a plus que 4 certifs est non seulement exclu mais ne peut pas se renouveler. Au moment de la perte le membre est exclu, puis si le membre ne se renouvelle pas au moment des 1 an de délai depuis sa dernière adhésion il ne se passe rien (on ne peut pas exclure un membre déjà exclu), puis au bout de 2 ans c’est la révocation implicite.
Faut vraiment voir l’adhésion comme le fil conducteur, et les certifications comme un moyen de prolonger ce fil.
.Ce qui se passe en BDD, 2 choses :
    - Etape 1 (bloc n) : la certification expire, si le membre a moins de 5 certifications valides restants celui-ci est marqué comme “à exclure” (champ kick)
    -Etape 2 (bloc n+1) : le membre doit être inscrit dans le champ Excluded du bloc.
Si le membre retrouve ses cinq certifications, il doit se renouveler pour revenir. Revenir n’est jamais automatique.
	*)
	(* For one block, add joining & leaving identities in joinAndLeaveT and updade identities in idPubT and idUidT; update certFromT & certToT too *)
	PROCEDURE Identities (withList: BOOLEAN; IN ssJ, ssA, ssL, ssR, ssE, nb: ARRAY OF CHAR; t: S.Table);
		
		VAR
			
			i, n, res, bnb: INTEGER;
			idRef, jlRef: LONGINT;
			tt: LONGINT;
			s: ARRAY 101 OF CHAR;
			b: BOOLEAN;
			id, oldId: Identity;
			idP: PubKey;
			idU: B.String;
			idL: UndoList; (* joinList, activeList *)
			jl: JoinAndLeave;
			jlL: JoinAndLeaveL;
			cur: S.Row;
			iK: LIntKey;
		
		BEGIN (*Identities*)
			i := 1;
			WHILE ssJ[i] # ']' DO (* joiners : Insert id *)
				INC(i);
				INC(idLenM);
				NEW(id);
				id.member := TRUE;
				ScanS(ssJ, ':', id.pubkey, i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 100);
				b := TimeOf(n, id.expires_on, tt); ASSERT(b, 101);
				INC(id.expires_on, pars.msValidity);
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '"', s, i); NEW(id.uid, LEN(s$) + 1); id.uid^ := s$;
				IF ssJ[i] # ']' THEN
					INC(i);
				END;
				REPEAT
					t.Exec("SELECT hash FROM i_index WHERE pub = '" + id.pubkey + "' ORDER BY writtenOn ASC");
					ASSERT(t.res IN {0, 6}, 102);
				UNTIL t.res = 0;
				ASSERT((t.rows = 0) OR (t.columns = 1), 103);
				id.hash := "";
				FOR n := 0 TO t.rows - 1 DO
					t.Read(n, cur);
					IF (cur.fields[0] # NIL) & (cur.fields[0]$ # "") THEN
						id.hash := cur.fields[0]$;
					END;
				END;
				ASSERT(id.hash # "", 104);
				Strings.StringToInt(nb, id.block_number, res); ASSERT(res = 0, 105);
				bnb := id.block_number;
				NEW(idU); NEW(idU.c, LEN(id.uid$) + 1); idU.c^ := id.uid$;
				NEW(idP); idP.ref := id.pubkey;
				IF idPubT.SearchIns(idP) THEN
					idRef := idPubT.ReadValue();
					oldId := idMan.ReadData(idRef)(Identity);
					ASSERT(~oldId.member & (oldId.uid$ = id.uid$) & (oldId.hash = id.hash), 106);
					id.block_number := oldId.block_number;
					id.certifiers := oldId.certifiers; id.certified := oldId.certified;
					idMan.WriteData(idRef, id);
					(* Les deux lignes suivantes sont superflues *)
					b := idUidT.SearchIns(idU); ASSERT(b, 107);
					ASSERT(idUidT.ReadValue() = idRef, 108);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := oldId.expires_on;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				ELSE
					id.certifiers := B.bNil; id.certified := B.bNil;
					idRef := idMan.WriteAllocateData(id);
					idPubT.WriteValue(idRef);
					b := idUidT.SearchIns(idU); ASSERT(~b, 109);
					idUidT.WriteValue(idRef);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
				IF joinAndLeaveT.SearchIns(idP) THEN
					jlRef := joinAndLeaveT.ReadValue();
					jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				ELSE
					NEW(jl);
					jl.pubkey := id.pubkey;
					jl.list := B.bNil;
					jlRef := joinAndLeaveMan.AllocateData(jl);
					joinAndLeaveT.WriteValue(jlRef);
				END;
				NEW(jlL);
				jlL.next := jl .list;
				jlL.joiningBlock := bnb;
				jlL.leavingBlock := hasNotLeaved;
				jl.list := joinAndLeaveLMan.WriteAllocateData(jlL);
				joinAndLeaveMan.WriteData(jlRef, jl);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := joinList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
			END;
			
			i := 1;
			WHILE ssA[i] # ']' DO (* actives *)
				INC(i);
				NEW(idP);
				ScanS(ssA, ':', idP.ref, i);
				SkipS(ssA, ':', i);
				ScanS(ssA, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 110);
				SkipS(ssA, '"', i);
				IF ssA[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 111);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 112);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.expires_on, tt); ASSERT(b, 113);
				INC(id.expires_on, pars.msValidity);
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssL[i] # ']' DO (* leavers *)
				INC(i);
				NEW(idP);
				ScanS(ssL, ':', idP.ref, i);
				SkipS(ssL, '"', i);
				IF ssL[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 114);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				id.expires_on := - ABS(id.expires_on);
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssR[i] # ']' DO (* revoked *)
				INC(i);
				NEW(idP);
				ScanS(ssR, ':', idP.ref, i);
				SkipS(ssR, '"', i);
				IF ssR[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 115);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				id.expires_on := BA.revoked;
				RemoveCertifiersCertified(withList, idRef, id);
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssE[i] # ']' DO (* excluded *)
				INC(i);
				DEC(idLenM);
				NEW(idP);
				ScanS(ssE, '"', idP.ref, i);
				IF ssE[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 116);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 117);
				id.member := FALSE;
				idMan.WriteData(idRef, id);
				b := joinAndLeaveT.Search(idP); ASSERT(b, 118);
				jlRef := joinAndLeaveT.ReadValue();
				jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
				ASSERT(jlL.leavingBlock = hasNotLeaved, 119);
				Strings.StringToInt(nb, jlL.leavingBlock, res); ASSERT(res = 0, 120);
				joinAndLeaveMan.WriteData(jl.list, jlL);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := leaveList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				IF id.expires_on >= 0 THEN (* ~missing *)
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
					INC(id.expires_on, pars.msValidity);
					idMan.WriteData(idRef, id);
					NEW(iK); iK.ref := idRef;
					b := idTimeT.SearchIns(iK); ASSERT(~b, 121);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddTimeList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
			END;
		END Identities;
	
	(* Add certifications of one block in certFromT, certToT and certTimeT *)
	PROCEDURE Certifications (withList: BOOLEAN; IN ss, nb: ARRAY OF CHAR);
		
		VAR
			
			i, n, res: INTEGER;
			exp, pC, v: LONGINT;
			b: BOOLEAN;
			c: Certification;
			idP: PubKey;
			idU: B.String;
			idRef: LONGINT;
			id: Identity;
			cL: UndoList; (*certAddList *)
			ind: B.Index;
			iK: LIntKey;
			s: ARRAY 11 OF CHAR;
		
		BEGIN (*Certifications*)
			i := 1;
			WHILE ss[i] # ']' DO
				INC(i);
				NEW(c);
				ScanS(ss, ':', c.from, i);
				ScanS(ss, ':', c.to, i);
				ScanS(ss, ':', s, i);
				SkipS(ss, '"', i);
				IF ss[i] # ']' THEN
					INC(i);
				END;
				Strings.StringToInt(nb, c.block_number, res); ASSERT(res = 0, 100);
				Strings.StringToInt(s, n, res); ASSERT(res = 0, 101);
				b := TimeOf(n, c.expires_on, exp); ASSERT(b, 102);
				INC(c.expires_on, pars.sigValidity);
				pC := certMan.WriteAllocateData(c);
				NEW(idU);
				NEW(idP);
				idP.ref := c.from;
				b := idPubT.Search(idP); ASSERT(b, 103);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				b := IdPub(c.to, idU.c); ASSERT(b, 104);
				IF id.certified = B.bNil THEN
					id.certified := database.CreateIndex(0);
					idMan.WriteData(idRef, id);
				END;
				ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
				b := ind.SearchIns(idU);
				ind.Close;
				IF certFromT.SearchIns(idP) THEN
					v := certFromT.ReadValue();
				ELSE
					v := database.CreateIndex(pubKeyS);
					certFromT.WriteValue(v);
				END;
				idP.ref := c.to;
				ind := database.OpenIndex(v, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP); ASSERT(~b, 105);
				ind.WriteValue(pC);
				ind.Close;
				b := idPubT.Search(idP); ASSERT(b, 106);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				b := IdPub(c.from, idU.c); ASSERT(b, 107);
				IF id.certifiers = B.bNil THEN
					id.certifiers := database.CreateIndex(0);
					idMan.WriteData(idRef, id);
				END;
				ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
				b := ind.SearchIns(idU);
				ind.Close;
				IF certToT.SearchIns(idP) THEN
					v := certToT.ReadValue();
				ELSE
					v := database.CreateIndex(pubKeyS);
					certToT.WriteValue(v);
				END;
				idP.ref := c.from;
				ind := database.OpenIndex(v, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP); ASSERT(~b, 108);
				ind.WriteValue(pC);
				ind.Close;
				NEW(iK); iK.ref := pC;
				b := certTimeT.SearchIns(iK); ASSERT(~b, 109);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certAddList; cL.ref := pC; cL.aux := 0;
					undoList := undoListMan.WriteAllocateData(cL);
				END;
			END;
		END Certifications;
	
	(* Remove c keys from certFromT and certToT *)
	PROCEDURE RemoveCert (c: Certification);
		
		VAR
			
			pKFrom, pKTo: PubKey;
			b, empty: BOOLEAN;
			n: LONGINT;
			ind: B.Index;
		
		BEGIN (*RemoveCert*)
			NEW(pKFrom); NEW(pKTo);
			pKFrom.ref := c.from; pKTo.ref := c.to;
			
			b := certFromT.Search(pKFrom); ASSERT(b, 100);
			n := certFromT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKTo); ASSERT(b, 101);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certFromT.Erase(pKFrom); ASSERT(b, 102);
			END;
			
			b := certToT.Search(pKTo); ASSERT(b, 103);
			n := certToT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKFrom); ASSERT(b, 104);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certToT.Erase(pKTo); ASSERT(b, 105);
			END;
		END RemoveCert;
	
	(* Remove expired certifications from certFromT and certToT *)
	PROCEDURE RemoveExpiredCerts (now, secureNow: LONGINT);
		
		VAR
			
			c: Certification;
			iK: LIntKey;
			b, withList: BOOLEAN;
			pC: LONGINT;
			cL: UndoList; (* certRemoveList *)
		
		BEGIN (*RemoveExpiredCerts*)
			NEW(c); c.expires_on := now; c.from := "";
			pC := certMan.WriteAllocateData(c);
			NEW(iK); iK.ref := pC;
			b := certTimeT.Search(iK);
			certMan.EraseData(pC);
			WHILE certTimeT.PosSet() DO
				pC := certTimeT.CurrentKey()(IntKey).ref;
				certTimeT.Next;
				c := certMan.ReadData(pC)(Certification);
				RemoveCert(c);
				withList := c.expires_on >= secureNow;
				iK.ref := pC;
				b := certTimeT.Erase(iK); ASSERT(b, 100);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certRemoveList; cL.ref := pC; cL.aux := 0;
					undoList := undoListMan.WriteAllocateData(cL);
				ELSE
					certMan.EraseData(pC);
				END;
			END;
		END RemoveExpiredCerts;
	
	PROCEDURE RevokeId (withList: BOOLEAN; p: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
			idRef: LONGINT;
			id: Identity;
			idL: UndoList; (* leaversList *)
		
		BEGIN (*RevokeId*)
			NEW(idP); idP.ref := p;
			b := idPubT.Search(idP); ASSERT(b, 100);
			idRef := idPubT.ReadValue();
			id := idMan.ReadData(idRef)(Identity);
			IF withList THEN
				NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
				undoList := undoListMan.WriteAllocateData(idL);
			END;
			id.expires_on := BA.revoked;
			idMan.WriteData(idRef, id);
		END RevokeId;
	
	PROCEDURE RevokeExpiredIds (now, secureNow: LONGINT);
		
		VAR
			
			id: Identity;
			iK: LIntKey;
			b, withList: BOOLEAN;
			pId: LONGINT;
			idL: UndoList;
		
		BEGIN (*RevokeExpiredIds*)
			NEW(id); id.expires_on := now; id.pubkey := ""; NEW(id.uid, 1); id.uid^ := "";
			pId := idMan.WriteAllocateData(id);
			NEW(iK); iK.ref := pId;
			b := idTimeT.Search(iK);
			idMan.EraseData(pId);
			WHILE idTimeT.PosSet() DO
				pId := idTimeT.CurrentKey()(IntKey).ref;
				idTimeT.Next;
				id := idMan.ReadData(pId)(Identity);
				iK.ref := pId;
				b := idTimeT.Erase(iK); ASSERT(b, 100);
				withList := ABS(id.expires_on) >= secureNow;
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := pId; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				RevokeId(withList, id.pubkey);
			END;
		END RevokeExpiredIds;
	
	(* Undo the last operations done from the secureGap last blocks *)
	PROCEDURE RemoveSecureGap;
		
		VAR
			
			b: BOOLEAN;
			i: IntKey;
			li: LIntKey;
			p: PubKey;
			u: B.String;
			t: Time;
			jlL: JoinAndLeaveL;
			jl: JoinAndLeave;
			idRef: LONGINT;
			id: Identity;
			c: Certification;
			l: UndoList;
			n, jlRef, jlLRef: LONGINT;
			ind: B.Index;
		
		BEGIN (*RemoveSecureGap*)
			WHILE undoList # B.bNil DO
				l := undoListMan.ReadData(undoList)(UndoList);
				CASE l.type OF
					|timeList:
						(* Erase the Time data pointed by l.ref and the corresponding key in timeT *)
						t := timeMan.ReadData(l.ref)(Time);
						NEW(i); i.ref := t.bnb;
						b := timeT.Erase(i); ASSERT(b, 100);
						timeMan.EraseData(l.ref);
					|idAddList:
						(* Erase the Identity data pointed by l.ref and the corresponding keys in idPubT and idUidT *)
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.Erase(p); ASSERT(b, 101);
						NEW(u); u.c := id.uid;
						b := idUidT.Erase(u); ASSERT(b, 102);
						idMan.EraseData(l.ref);
					|joinList:
						(* Erase the last JoinAndLeaveL data corresponding to l.ref; if this is also the first data, erase the corresponding JoinAndLeave data and its key in joinAndLeaveT *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := FALSE;
						idMan.WriteData(l.ref, id);
						DEC(idLenM);
						NEW(p); p.ref := id.pubkey;
						b := joinAndLeaveT.Search(p); ASSERT(b, 103);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlLRef := jl.list;
						jlL := joinAndLeaveLMan.ReadData(jlLRef)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock = hasNotLeaved, 104);
						IF jlL.next = B.bNil THEN
							joinAndLeaveMan.EraseData(jlRef);
							b := joinAndLeaveT.Erase(p); ASSERT(b, 105);
						ELSE
							jl.list := jlL.next;
							joinAndLeaveMan.WriteData(jlRef, jl);
						END;
						joinAndLeaveLMan.EraseData(jlLRef);
					|activeList:
						(* Undo the Identity.expires_on update *)
						id := idMan.ReadData(l.ref)(Identity);
						id.expires_on := l.aux;
						idMan.WriteData(l.ref, id);
					|leaveList:
						(* Update the last JoinAndLeaveL data corresponding to l.ref *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := TRUE;
						idMan.WriteData(l.ref, id);
						INC(idLenM);
						NEW(p); p.ref := id.pubkey;
						b := joinAndLeaveT.Search(p); ASSERT(b, 106);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock # hasNotLeaved, 107);
						jlL.leavingBlock := hasNotLeaved;
						joinAndLeaveLMan.WriteData(jl.list, jlL);
					|idAddTimeList:
						NEW(li); li.ref := l.ref;
						b := idTimeT.Erase(li); ASSERT(b, 108);
					|idRemoveTimeList:
						NEW(li); li.ref := l.ref;
						b := idTimeT.SearchIns(li); ASSERT(~b, 109);
					|certAddList:
						(* Erase the keys corresponding to the certification pointed by l.ref in certFromT and certToT *)
						c := certMan.ReadData(l.ref)(Certification);
						RemoveCert(c);
						NEW(li); li.ref := l.ref;
						b := certTimeT.Erase(li); ASSERT(b, 110);
						NEW(u);
						NEW(p);
						p.ref := c.from;
						b := idPubT.Search(p); ASSERT(b, 111);
						idRef := idPubT.ReadValue();
						id := idMan.ReadData(idRef)(Identity);
						b := IdPub(c.to, u.c); ASSERT(b, 112);
						ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
						b := ind.Erase(u); ASSERT(b, 113);
						b := ind.IsEmpty();
						ind.Close;
						IF b THEN
							database.DeleteIndex(id.certified); id.certified := B.bNil;
							idMan.WriteData(idRef, id);
						END;
						p.ref := c.to;
						b := idPubT.Search(p); ASSERT(b, 114);
						idRef := idPubT.ReadValue();
						id := idMan.ReadData(idRef)(Identity);
						b := IdPub(c.from, u.c); ASSERT(b, 115);
						ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
						b := ind.Erase(u); ASSERT(b, 116);
						b := ind.IsEmpty();
						ind.Close;
						IF b THEN
							database.DeleteIndex(id.certifiers); id.certifiers := B.bNil;
							idMan.WriteData(idRef, id);
						END;
						certMan.EraseData(l.ref);
					|certRemoveList:
						(* Insert the keys corresponding to the Certification pointed by l.ref into certFromT, certToT and certTimeT *)
						c := certMan.ReadData(l.ref)(Certification);
						NEW(p);
						p.ref := c.from;
						IF certFromT.SearchIns(p) THEN
							n := certFromT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certFromT.WriteValue(n);
						END;
						p.ref := c.to;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 117);
						ind.WriteValue(l.ref);
						ind.Close;
						IF certToT.SearchIns(p) THEN
							n := certToT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certToT.WriteValue(n);
						END;
						p.ref := c.from;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 118);
						ind.WriteValue(l.ref);
						ind.Close;
						NEW(li); li.ref := l.ref;
						b := certTimeT.SearchIns(li); ASSERT(~b, 119);
					|remCertifiers:
						id := idMan.ReadData(l.aux)(Identity);
						NEW(u); u.c := id.uid;
						id := idMan.ReadData(l.ref)(Identity);
						IF id.certifiers = B.bNil THEN
							id.certifiers := database.CreateIndex(0);
							idMan.WriteData(l.ref, id);
						END;
						ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
						b := ind.SearchIns(u); ASSERT(~b, 120);
						ind.Close;
					|remCertified:
						id := idMan.ReadData(l.aux)(Identity);
						NEW(u); u.c := id.uid;
						id := idMan.ReadData(l.ref)(Identity);
						IF id.certified = B.bNil THEN
							id.certified := database.CreateIndex(0);
							idMan.WriteData(l.ref, id);
						END;
						ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
						b := ind.SearchIns(u); ASSERT(~b, 121);
						ind.Close;
				END;
				undoListMan.EraseData(undoList);
				undoList := l.next;
			END;
		END RemoveSecureGap;
	
	(* Initialize members and sentriesS/sentriesI *)
	PROCEDURE CalculateSentries;
		
		VAR
			
			ok, b: BOOLEAN;
			pos: CertPos;
			p, to: Pubkey;
			i, e, n: INTEGER;
		
		BEGIN (*CalculateSentries*)
			members.len := IdLen();
			NEW(members.m, members.len + 1);
			i := 0;
			ok := IdNextPubkey(TRUE, p);
			WHILE ok DO
				ASSERT((i = 0) OR (p > members.m[i - 1].p), 100);
				members.m[i].p := p;
				members.m[i].links := U.NewSet();
				INC(i);
				ok := IdNextPubkey(FALSE, p);
			END;
			ASSERT(i = members.len, 101);
			FOR i := 0 TO members.len - 1 DO
				ok := CertTo(members.m[i].p, pos) & pos.CertNextPos(p, to);
				WHILE ok DO
					b := FindMemberNum(p, e); ASSERT(b, 102);
					members.m[i].links.Incl(e);
					ok := pos.CertNextPos(p, to);
				END;
			END;
			
			sentriesS := U.NewSet(); sentriesI.Attach(sentriesS);
			n := IdLenM();
			IF n = 0 THEN RETURN END;
			n := SHORT(ENTIER(Math.Ceiling(Math.Power(n, 1 / pars.stepMax))));
			ok := IdNextPubkeyM(TRUE, p);
			WHILE ok DO
				IF CertFrom(p, pos) & (pos.CertPosLen() >= n) & CertTo(p, pos) & (pos.CertPosLen() >= n) THEN
					b := FindMemberNum(p, e); ASSERT(b, 103);
					sentriesS.Incl(e);
				END;
				ok := IdNextPubkeyM(FALSE, p);
			END;
			
			A.New(poST);
		END CalculateSentries;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks (d: S.Database; VAR changed: BOOLEAN);
		
		VAR
			
			cur: S.Row;
			t, tt: S.Table;
			i, res, lastN: INTEGER;
			s: ARRAY 13 OF CHAR;
			withList: BOOLEAN;
			now, secureNow: LONGINT;
		
		BEGIN (*ScanBlocks*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			lastN := SHORT(database.ReadPlace(lastNPlace));
			IF ~changed THEN
				REPEAT
					t.Exec("SELECT max(number) FROM block WHERE NOT fork");
					ASSERT(t.res IN {0, 6}, 101);
				UNTIL t.res = 0;
				ASSERT((t.rows = 0) OR (t.rows = 1) & (t.columns = 1), 102);
				IF t.rows = 1 THEN
					t.Read(0, cur);
					Strings.StringToInt(cur.fields[0], i, res); ASSERT(res = 0, 103);
					IF i + 1 = lastN THEN
						Dialog.ShowStatus(cur.fields[0]);
						RETURN;
					END;
				END;
			END;
			idLenM := SHORT(database.ReadPlace(idLenPlace));
			undoList := database.ReadPlace(undoListPlace);
			RemoveSecureGap;
			Strings.IntToString(lastN - secureGap, s);
			REPEAT
				t.Exec("SELECT number, medianTime, time, joiners, actives, leavers, revoked, excluded, certifications FROM block WHERE NOT fork AND number >= " + s + " ORDER BY number ASC");
				ASSERT(t.res IN {0, 6}, 104);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 9), 105);
			tt := d.NewTable(); ASSERT(tt # NIL, 106);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, cur);
				Dialog.ShowStatus(cur.fields[0]);
				withList := i >= t.rows - secureGap;
				Times(withList , cur.fields[0], cur.fields[1], cur.fields[2]);
				Identities(withList, cur.fields[3], cur.fields[4], cur.fields[5], cur.fields[6], cur.fields[7], cur.fields[0], tt);
				Certifications(withList, cur.fields[8], cur.fields[0]);
			END;
			IF t.rows > 0 THEN
				t.Read(t.rows - 1, cur);
				Strings.StringToLInt(cur.fields[1], now, res); ASSERT(res = 0, 107);
				IF secureGap = 0 THEN
					secureNow := MAX(LONGINT);
				ELSE
					IF t.rows >= secureGap THEN
						t.Read(t.rows - secureGap, cur);
					ELSE
						t.Read(0, cur);
					END;
					Strings.StringToLInt(cur.fields[1], secureNow, res); ASSERT(res = 0, 108);
				END;
				RevokeExpiredIds(now, secureNow);
				RemoveExpiredCerts(now, secureNow); (* Élimine toutes les certifications expirées avec réversibilité dans secureGap *)
			END;
			database.WritePlace(undoListPlace, undoList);
			IF lastN <= secureGap THEN
				lastN := t.rows;
			ELSE
				INC(lastN, t.rows - secureGap);
			END;
			database.WritePlace(lastNPlace, lastN);
			database.WritePlace(idLenPlace, idLenM);
			database.UpdateBase;
			CalculateSentries;
			changed := TRUE;
		END ScanBlocks;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE l # NIL DO
				m := l;
				l := l.next;
			END;
			NEW(l);
			l.next := NIL;
			l.update := updateProc;
			IF m = NIL THEN
				updateList := l;
			ELSE
				m.next := l;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			ASSERT(l # NIL, 20);
			IF m = NIL THEN
				updateList := l.next;
			ELSE
				m.next := l.next;
			END;
		END RemoveUpdateProc;
	
	(* Scan the Duniter database *)
	PROCEDURE Scan (VAR changed: BOOLEAN);
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			ScanBlocks(d, changed);
		END Scan;
	
	(* Scan the Duniter parameters in block 0 *)
	PROCEDURE Scan1;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan1*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			Params(d);
		END Scan1;
	
	PROCEDURE UpdateAll*;
		
		VAR
			
			l: UpdateList;
			t0, t1, rest: LONGINT;
		
		BEGIN (*UpdateAll*)
			Services.RemoveAction(update);
			t0 := Services.Ticks();
			l := updateList;
			WHILE l # NIL DO
				l.update(updateChanged);
				l := l.next;
			END;
			updateChanged := FALSE;
			BA.Collect;
			t1 := Services.Ticks();
			rest := delay - (t1 - t0);
			Services.DoLater(update, t1 + MAX(rest, minDelay));
		END UpdateAll;
	
	PROCEDURE (update: UpdateAction) Do;
		
		BEGIN (*Do*)
			UpdateAll;
		END Do;
	
	PROCEDURE ChooseDuniterDataBase*;
		
		VAR
			
			loc, l: Files.Locator;
			path, name: Files.Name;
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		PROCEDURE SplitFullName (full: ARRAY OF CHAR; OUT path, name: ARRAY OF CHAR): BOOLEAN;
			
			VAR
				
				res, drive, p: INTEGER;
				ok: BOOLEAN;
			
			BEGIN (*SplitFullName*)
				res := 0;
				LOOP
					Strings.Find(full, '\', res, res);
					IF res = - 1 THEN
						EXIT;
					END;
					full[res] := '/';
				END;
				Strings.Find(full, ':', 0, res);
				ok := (res = - 1) OR (res = 1);
				IF ok THEN
					drive := res;
					Strings.Find(full, '/', res + 1, p);
					WHILE p >= 0 DO
						res := p;
						Strings.Find(full, '/', res + 1, p);
					END;
					IF res < 0 THEN
						path := "";
						name := full$;
					ELSE
						IF res <= drive + 1 THEN
							Strings.Extract(full, 0, res + 1, path);
						ELSE
							Strings.Extract(full, 0, res, path);
						END;
						Strings.Extract(full, res + 1, LEN(full), name);
					END;
					ok := LEN(name$) > 0;
				END;
				RETURN ok;
			END SplitFullName;
		
		BEGIN (*ChooseDuniterDataBase*)
			IF ~SplitFullName(duniBase, path, name) THEN
				path := ''; name := '';
			END;
			loc := Files.dir.This(path); ASSERT(loc.res = 0, 100);
			Dialog.GetIntSpec("*", loc, name);
			IF loc # NIL THEN
				duniBase := loc(HostFiles.Locator).path + "/" + name;
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString('"' + duniBase + '"');
				l := Files.dir.This(initDir); ASSERT(l.res = 0, 101);
				Views.RegisterView(TextViews.dir.New(t), l, initName);
			END;
		END ChooseDuniterDataBase;
	
	PROCEDURE ResetDataBase*;
		
		VAR
			
			l: Files.Locator;
			res: INTEGER;
		
		BEGIN (*ResetDataBase*)
			Dialog.GetOK("#Duniter0:ResetBase", "", "", "", {Dialog.ok, Dialog.cancel}, res);
			IF res = Dialog.ok THEN
				CloseB;
				l := Files.dir.This(''); ASSERT(l.res = 0, 100);
				Files.dir.Delete(l, dBase); ASSERT(l.res = 0, 101);
				Scan1;
				OpenB;
				UpdateAll;
			END;
		END ResetDataBase;
	
	PROCEDURE Init;
		
		VAR
			
			loc, l: Files.Locator;
			v: Views.View;
			s: TextMappers.Scanner;
			res: INTEGER;
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Init*)
			duniBase := '';
			l := Files.dir.This(initDir); ASSERT(l.res = 0, 100);
			REPEAT
				v := Views.OldView(l, initName);
				IF v = NIL THEN
					Dialog.GetOK("#Duniter0:DuniterDataBase", "", "", "", {Dialog.ok}, res);
					loc := Files.dir.This(''); ASSERT(loc.res = 0, 101);
					Dialog.GetIntSpec("*", loc, duniBase);
					IF loc = NIL THEN
						HALT(128);
					ELSE
						t := TextModels.dir.New();
						f.ConnectTo(t);
						duniBase := loc(HostFiles.Locator).path + "/" + duniBase;
						f.WriteString('"' + duniBase + '"');
						Views.RegisterView(TextViews.dir.New(t), l, initName);
					END;
				ELSE
					ASSERT(v IS TextViews.View, 102);
					s.ConnectTo(v(TextViews.View).ThisModel());
					s.Scan;
					IF s.type = TextMappers.string THEN
						duniBase := s.string$;
					END;
				END;
			UNTIL duniBase # '';
			now := 0; rNow := 0;
			Scan1;
			delay := pars.avgGenTime * Services.resolution;
			updateList := NIL;
			AddUpdateProc(Scan);
			NEW(undoListFac); NEW(timeFac); NEW(joinAndLeaveLFac); NEW(joinAndLeaveFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(lIntKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan);
			NEW(intKeyMan); NEW(idKTimeMan); NEW(certKTimeMan);
			OpenB;
			NEW(update);
			updateChanged := TRUE;
			UpdateAll;
		END Init;
	
	BEGIN (*Duniter0Blockchain*)
		Init;
	CLOSE
		CloseB;
		Services.RemoveAction(update);
	END Duniter0Blockchain.
