(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0WWViews;
	
	
	
	(* This module creates views displaying WotWizard forecasts *)
		
	IMPORT
		
		(*
		StdLog,
		*)
		
		A := UtilAvlTree, B := Duniter0Blockchain, BA := Duniter0Basic, Containers, Controllers, Controls, Converters, DevSearch, Dialog, Documents, Files, Fonts, J := UtilJson, Math, Models, Ports, Properties, Sequencers, Services, StdCmds, Stores, Strings, TextMappers, TextModels, TextRulers, TextViews, Views, W := Duniter0WotWizard, WP := Duniter0WotWizardPrint, Windows;
	
	CONST
		
		maxStackLengthDir = "Duniter0/Rsrc";
		maxStackLengthName = "WW_Max_Stack.odc";
		
		rsrcDir = "Duniter/Rsrc"; (* Resources directory *)
		
		textMeta = "WWMeta.json"; (* File containing metadata *)
		textByDate = "WWByDate.json"; (* File containing entries data, sorted by dates *)
		textByName = "WWByName.json"; (* File containing entries data, sorted by names *)
		
		oldEntriesName = "WW_Old_Entries.odc"; (* File containing previous metadata output *)
		oldMetaName = "WW_Old_Meta.odc"; (* File containing previous entries data output *)
		
		title = "WotWizard"; (* Title of the outputs *)
		
		width = 80 * Ports.mm; (* Original window width *)
		height = 150 * Ports.mm; (* Original window height *)
		
		(* Output sorts *)
		byDate = 0; byName = 1; meta = 2;
		
		(* Sizes of fonts *)
		titleSize = 20 * Fonts.point;
		headSize = 14 * Fonts.point;
		corpusSize = 10 * Fonts.point;
		
		(* Indentations widths *)
		indent = 5 * Ports.mm;
		indentM = 2 * Ports.mm;
		
		(* Extra widths of buttons *)
		radioOffset = 5 * Ports.mm;
		buttonOffset = 5 * Ports.mm;
		
		(* Tab stops *)
		firstCtrlPos = width * 1 DIV 6;
		secondCtrlPos = width * 3 DIV 6;
		thirdCtrlPos = width * 5 DIV 6;
	
	TYPE
		
		(* Type of the view which displays the WotWizard lists *)
		View = POINTER TO LIMITED RECORD (Views.View)
			nowS: BA.DateTime; (* Current date *)
			occurD, occurN: A.Tree; (* Sets of permutations, sorted by dates and by names *)
			meta: J.Json; (* Metadata *)
			modified: BOOLEAN; (* The sets of permutations have been modified *)
			text: TextViews.View; (* The displayed text *)
		END;
		
		(* Return the first View *)
		FindMsg = RECORD (Views.Message)
			v: View;
		END;
	
	VAR
		
		dateNameMeta*: INTEGER; (* Sort of the output *)
		
		showOldEntries-: BOOLEAN;
		
		maxStackLength*,
		oldMaxStackLength: LONGINT;
	
	(* Find the first View *)
	PROCEDURE FindFirst (): View;
		
		VAR
			
			w: Windows.Window;
			msg: FindMsg;
		
		BEGIN (*FindFirst*)
			w := Windows.dir.First();
			WHILE w # NIL DO
				IF (w.frame # NIL) & (w.frame.view # NIL) & (w.frame.view IS Documents.Document) & (w.frame.view(Documents.Document).ThisView() IS View) THEN
					RETURN w.frame.view(Documents.Document).ThisView()(View);
				END;
				w := Windows.dir.Next(w);
			END;
			msg.v := NIL;
			Views.Omnicast(msg);
			RETURN msg.v;
		END FindFirst;
	
	PROCEDURE SetNotDirty (v: Views.View);
		
		VAR
			
			d: Stores.Domain;
			any: ANYPTR;
			seq: Sequencers.Sequencer;
		
		BEGIN (*SetNotDirty*)
			ASSERT(v # NIL, 20);
			d := v.Domain();
			IF d # NIL THEN
				any := d.GetSequencer();
				IF (any # NIL) & (any IS Sequencers.Sequencer) THEN
					seq := any(Sequencers.Sequencer);
					seq.SetDirty(FALSE);
				END;
			END;
		END SetNotDirty;
	
	(* Test the equality of the two permutations sorted by dates o1 and o2 *)
	PROCEDURE OccursEqual (o1, o2: A.Tree): BOOLEAN;
		
		VAR
			
			e1, e2: A.Elem;
		
		PROCEDURE Equal (e1, e2: A.Elem): BOOLEAN;
			
			BEGIN (*Equal*)
				WITH e1: W.PropDate DO
					WITH e2: W.PropDate DO
						RETURN (e1.id$ = e2.id$) & (e1.date = e2.date) & (e1.after = e2.after) & (e1.proba = e2.proba);
					END;
				END;
			END Equal;
		
		BEGIN (*OccursEqual*)
			e1 := o1.Next(NIL); e2 := o2.Next(NIL);
			WHILE (e1 # NIL) & (e2 # NIL) & Equal(e1, e2) DO
				e1 := o1.Next(e1); e2 := o2.Next(e2);
			END;
			RETURN (e1 = NIL) & (e2 = NIL);
		END OccursEqual;
	
	(* Print the permutation occurD sorted by dates *)
	PROCEDURE ByDates (IN f: TextMappers.Formatter; occurD: A.Tree);
		
		VAR
			
			r: TextRulers.Ruler;
			s: BA.DateTime;
			e: A.Elem;
			l: INTEGER;
			date: LONGINT;
			after: BOOLEAN;
		
		BEGIN (*ByDates*)
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			l := 0;
			e := occurD.Next(NIL);
			WHILE e # NIL DO
				l := MAX(l, f.rider.attr.font.StringWidth(e(W.PropDate).id$ + '+ '));
				e := occurD.Next(e);
			END;
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, indent);
			TextRulers.SetFixedRight(r, width);
			TextRulers.AddTab(r, indent + l);
			f.WriteView(r);
			date := - 1;
			e := occurD.Next(NIL);
			WHILE e # NIL DO
				WITH e: W.PropDate DO
					IF (e.date # date) OR (e.after # after) THEN
						date := e.date; after := e.after;
						f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
						f.WriteLn; f.WritePara;
						IF e.date = BA.never THEN
							f.WriteMsg("#Duniter0:Never");
						ELSE
							BA.TimestampToString(e.date, s);
							f.WriteString(s);
							IF e.after THEN
								f.WriteString("+");
							END;
						END;
						f.WriteLn;
					END;
					f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
					f.WriteString(e.id);
					f.WriteTab;
					f.WriteString(": "); f.WriteMsg("#Duniter0:Proba"); f.WriteString(" = ");
					f.WriteIntForm(ENTIER(Math.Round(e.proba * 100)), 10, 3, " ", FALSE); (* Digit space *)
					f.WriteString("%");
					f.WriteLn;
				END;
				e := occurD.Next(e);
			END;
		END ByDates;
	
	(* Print the permutation occurN sorted by names *)
	PROCEDURE ByNames (IN f: TextMappers.Formatter; occurN: A.Tree);
		
		VAR
			
			r: TextRulers.Ruler;
			s: BA.DateTime;
			e: A.Elem;
			id: B.String;
			n, pos: INTEGER;
		
		BEGIN (*ByNames*)
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, indent);
			TextRulers.SetFixedRight(r, width);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			BA.TimestampToString(0, s);
			TextRulers.AddTab(r, indent + f.rider.attr.font.StringWidth(s + '+ '));
			f.WriteView(r);
			f.WriteLn; f.WritePara;
			pos := f.Pos();
			f.WriteLn;
			n := 0;
			NEW(id, 1); id^ := 0X;
			e := occurN.Next(NIL);
			WHILE e # NIL DO
				WITH e: W.PropName DO
					IF e.id$ # id$ THEN
						id := e.id;
						INC(n);
						f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
						f.WriteLn; f.WritePara;
						f.WriteString(e.id);
						f.WriteLn;
					END;
					f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
					IF e.date = BA.never THEN
						f.WriteMsg("#Duniter0:Never");
					ELSE
						BA.TimestampToString(e.date, s);
						f.WriteString(s);
						IF e.after THEN
							f.WriteString("+");
						END;
					END;
					f.WriteTab;
					f.WriteString(": "); f.WriteMsg("#Duniter0:Proba"); f.WriteString(" = ");
					f.WriteIntForm(ENTIER(Math.Round(e.proba * 100)), 10, 3, " ", FALSE); (* Digit space *)
					f.WriteString("%");
					f.WriteLn;
				END;
				e := occurN.Next(e);
			END;
			f.SetPos(pos);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
			f.WriteInt(n);
			f.WriteMsg("#Duniter0:newcomers");
		END ByNames;
	
	(* Print the metadata m with the help of f *)
	PROCEDURE Meta (IN f: TextMappers.Formatter; m: J.Json);
		
		CONST
			
			tabNb = 10;
		
		VAR
			
			r: TextRulers.Ruler;
			i: INTEGER;
		
		BEGIN (*Meta*)
			r := TextRulers.dir.New(NIL);
			TextRulers.SetJustified(r);
			TextRulers.SetFirst(r, 0);
			TextRulers.SetLeft(r, 0);
			TextRulers.SetFixedRight(r, width);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			FOR i := 1 TO tabNb DO
				TextRulers.AddTab(r, i * indentM);
			END;
			f.WriteView(r);
			IF m # NIL THEN
				m.Write(f);
			END;
		END Meta;
	
	PROCEDURE InitProp (VAR p: Controls.Prop);
		
		BEGIN (*InitProp*)
			NEW(p);
			p.link := ""; p.label := ""; p.guard := ""; p.notifier := "";
			p.level := 0;
			p.opt[0] := FALSE; p.opt[1] := FALSE;
			p.opt[2] := FALSE; p.opt[3] := FALSE;
			p.opt[4] := FALSE;
		END InitProp;
	
	(* Write the text of the View v *)
	PROCEDURE (v: View) WriteText, NEW;
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			r: TextRulers.Ruler;
		
		(* Insert into the text the three radio buttons and one or two command buttons *)
		PROCEDURE InsertControls (IN f: TextMappers.Formatter);
			
			VAR
				
				r: TextRulers.Ruler;
				prop: Controls.Prop;
				c: Controls.Control;
				s: Dialog.String;
				w, h: INTEGER;
			
			BEGIN (*InsertControls*)
				f.WriteLn;
				r := TextRulers.dir.New(NIL);
				TextRulers.AddTab(r, firstCtrlPos);
				TextRulers.MakeCenterTab(r);
				TextRulers.AddTab(r, secondCtrlPos);
				TextRulers.MakeCenterTab(r);
				TextRulers.AddTab(r, thirdCtrlPos);
				TextRulers.MakeCenterTab(r);
				f.WriteView(r);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter0WWViews.dateNameMeta";
				prop.label := "#Duniter0:ByName";
				prop.notifier := "Duniter0WWViews.DateNameMetaNotifier";
				prop.level := 1;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter0WWViews.dateNameMeta";
				prop.label := "#Duniter0:Meta";
				prop.notifier := "Duniter0WWViews.DateNameMetaNotifier";
				prop.level := 2;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter0WWViews.dateNameMeta";
				prop.label := "#Duniter0:ByDate";
				prop.notifier := "Duniter0WWViews.DateNameMetaNotifier";
				prop.level := 0;
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewRadioButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + radioOffset, h);
				f.WriteLn;
				f.WriteLn;
				f.WriteTab;
				IF v.modified THEN
					InitProp(prop);
					prop.link := "Duniter0WWViews.Clear";
					prop.label := "#Duniter0:Check";
					Dialog.MapString(prop.label, s);
					c := Controls.dir.NewPushButton(prop);
					f.WriteView(c);
					c.context.GetSize(w, h);
					c.context.SetSize(c.font.StringWidth(s) + buttonOffset, h);
				END;
				f.WriteTab; f.WriteTab;
				InitProp(prop);
				prop.link := "Duniter0Blockchain.UpdateAll";
				prop.label := "#Duniter0:Update";
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewPushButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + buttonOffset, h);
				f.WriteLn;
			END InsertControls;
		
		BEGIN (*WriteText*)
			t := v.text.ThisModel();
			t.Delete(0, t.Length());
			f.ConnectTo(t);
			r := TextRulers.dir.New(NIL);
			TextRulers.SetCentered(r);
			TextRulers.SetFixedRight(r, width);
			f.WriteView(r);
			f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.normal));
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, titleSize));
			IF v.modified THEN
				f.WriteString("* ");
			END;
			f.WriteMsg(title);
			IF v.modified THEN
				f.WriteString(" *");
			END;
			f.WriteLn;
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
			f.WriteString(v.nowS);
			f.WriteString(" (UTC+0)");
			f.WriteLn;
			InsertControls(f);
			f.rider.SetAttr(TextModels.NewSize(f.rider.attr, corpusSize));
			IF ~v.occurD.IsEmpty() THEN
				CASE dateNameMeta OF
					|byDate:
						ByDates(f, v.occurD);
					|byName:
						ByNames(f, v.occurN);
					|meta:
						Meta(f, v.meta);
				END;
			END;
			Views.Update(v, Views.keepFrames);
			SetNotDirty(v);
		END WriteText;
	
	(* When the WotWizard lists have been modified, stores on disk the old results versions in oldEntriesName and oldMetaName files *)
	PROCEDURE OldResults (occurD: A.Tree; meta: J.Json);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
			v: Views.View;
			loc: Files.Locator;
		
		PROCEDURE Header (VAR f: TextMappers.Formatter);
			
			VAR
				
				r: TextRulers.Ruler;
				prop: Controls.Prop;
				c: Controls.Control;
				s: Dialog.String;
				w, h: INTEGER;
			
			BEGIN (*Header*)
				r := TextRulers.dir.New(NIL);
				TextRulers.SetCentered(r);
				TextRulers.SetFixedRight(r, width);
				f.WriteView(r);
				f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.normal));
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, titleSize));
				f.WriteMsg(title);
				f.WriteLn;
				f.rider.SetAttr(TextModels.NewSize(f.rider.attr, headSize));
				f.WriteMsg("#Duniter0:PreviousDisplay");
				f.WriteLn;
				f.WriteLn;
				r := TextRulers.dir.New(NIL);
				TextRulers.AddTab(r, thirdCtrlPos);
				TextRulers.MakeCenterTab(r);
				f.WriteView(r);
				f.WriteTab;
				InitProp(prop);
				prop.link := "DevSearch.Compare";
				prop.label := "#Duniter0:Compare";
				Dialog.MapString(prop.label, s);
				c := Controls.dir.NewPushButton(prop);
				f.WriteView(c);
				c.context.GetSize(w, h);
				c.context.SetSize(c.font.StringWidth(s) + buttonOffset, h);
				f.WriteLn;
			END Header;
		
		BEGIN (*OldResults*)
			loc := Files.dir.This(""); ASSERT(loc.res = 0, 100);
			
			t := TextModels.dir.New();
			f.ConnectTo(t);
			Header(f);
			ByDates(f, occurD);
			v := TextViews.dir.New(t);
			Views.RegisterView(v, loc, oldEntriesName);
			
			t := TextModels.dir.New();
			f.ConnectTo(t);
			Header(f);
			Meta(f, meta);
			v := TextViews.dir.New(t);
			Views.RegisterView(v, loc, oldMetaName);
		END OldResults;
	
	(* Write the metadata duration, f, cNb & dNb with the help of fo, in json format; duration is the computation duration, f is the DuniterWotWizard.File structure, cNb and dNb are respectively the numbers of internal certifications and of external dossiers *)
	PROCEDURE BuildMeta (duration: LONGINT; f: W.File; cNb, dNb: INTEGER): J.Json;
		
		VAR
			
			s: BA.DateTime;
			ss: BA.TimeString;
			sss: Dialog.String;
		
		PROCEDURE BuildFile (f: W.File; withTo: BOOLEAN);
			
			VAR
				
				i: INTEGER;
			
			PROCEDURE BuildCertOrDoss (cd: W.CertOrDoss);
				
				PROCEDURE BuildCertOrDossEnd (cd: W.CertOrDoss);
					
					BEGIN (*BuildCertOrDossEnd*)
						IF cd.date = BA.never THEN
							Dialog.MapString("#Duniter0:Never", sss);
							J.PushString(sss);
						ELSE
							BA.TimestampToString(cd.date, s);
							J.PushString(s);
						END;
						J.BuildField("date");
						BA.TimestampToString(cd.limit, s);
						J.PushString(s);
						J.BuildField("limit");
					END BuildCertOrDossEnd;
				
				PROCEDURE BuildCertif (c: W.Certif);
					
					BEGIN (*BuildCertif*)
						J.StartObject;
						J.PushString(c.from);
						J.BuildField("from");
						IF withTo THEN
							J.PushString(c.to);
							J.BuildField("to");
						END;
						BuildCertOrDossEnd(c);
						J.BuildObject;
					END BuildCertif;
				
				PROCEDURE BuildDossier (d: W.Dossier);
					
					VAR
						
						s: ARRAY 7 OF CHAR;
					
					BEGIN (*BuildDossier*)
						J.StartObject;
						J.PushString(d.id);
						J.BuildField("newcomer");
						Strings.RealToStringForm(100 * d.proportionOfSentries, 16, 1, - 2, " ", s);
						J.PushString(s);
						J.BuildField("percent_of_sentries");
						BuildCertOrDossEnd(d);
						BuildFile(d.certifs, FALSE);
						J.BuildField("certifs");
						J.BuildObject;
					END BuildDossier;
				
				BEGIN (*BuildCertOrDoss*)
					WITH
						|cd: W.Certif DO
							IF withTo THEN
								J.StartObject;
							END;
							BuildCertif(cd);
							IF withTo THEN
								J.BuildField("certif");
								J.BuildObject;
							END;
						|cd: W.Dossier DO
							J.StartObject;
							BuildDossier(cd);
							J.BuildField("dossier");
							J.BuildObject;
					END;
				END BuildCertOrDoss;
			
			BEGIN (*BuildFile*)
				J.StartArray;
				IF f # NIL THEN
					FOR i := 0 TO LEN(f) - 1 DO
						BuildCertOrDoss(f[i]);
					END;
				END;
				J.BuildArray;
			END BuildFile;
		
		BEGIN (*BuildMeta*)
			J.StartObject;
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			BA.TimestampToString(B.Now(), s);
			J.PushString(s);
			J.BuildField("now");
			BA.TimeToString(duration, ss);
			J.PushString(ss);
			J.BuildField("computation_duration");
			J.PushInteger(cNb);
			J.BuildField("certNb");
			J.PushInteger(dNb);
			J.BuildField("dossNb");
			BuildFile(f, TRUE);
			J.BuildField("certifs&dossiers");
			J.BuildObject;
			RETURN J.GetJson();
		END BuildMeta;
	
	(* Test whether the WotWizard lists have changed *)
	PROCEDURE (v: View) UpdateText, NEW;
		
		VAR
			
			f: W.File;
			cNb, dNb: INTEGER;
			ti, duration: LONGINT;
			occurD, occurN: A.Tree;
			meta: J.Json;
			b, oM: BOOLEAN;
			nowS: BA.DateTime;
		
		BEGIN (*UpdateText*)
			ti := Services.Ticks();
			IF ~W.BuildEntries(f, cNb, dNb, occurD, occurN) THEN
				A.New(occurD); A.New(occurN);
			END;
			duration := Services.Ticks() - ti;
			meta := BuildMeta(duration, f, cNb, dNb);
			BA.TimestampToString(B.Now(), nowS);
			oM := v.modified;
			b := ~OccursEqual(occurD, v.occurD);
			v.modified := v.modified OR b;
			IF b & ~oM THEN
				OldResults(v.occurD, v.meta);
			END;
			v.nowS := nowS; v.occurD := occurD; v.occurN := occurN; v.meta := meta;
		END UpdateText;
	
	(* Save the WotWizard lists on disk, in files textByName and textByDate, whenever they have changed *)
	PROCEDURE (v: View) StoreText, NEW;
		
		CONST
			
			textByName = "WWByName";
			textByDate = "WWByDate";
			textExt = "txt";
			textConv = "CpcUtf8Conv.ExportUtf8";
		
		VAR
			
			loc: Files.Locator;
			name: Files.Name;
			conv: Converters.Converter;
			res: INTEGER;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			nowS: BA.DateTime;
		
		BEGIN (*StoreText*)
			IF v.modified THEN
				loc := Files.dir.This(""); ASSERT(loc.res = 0);
				conv := Converters.list;
				WHILE (conv # NIL) & (conv.exp # textConv) DO
					conv := conv.next;
				END;
				ASSERT(conv # NIL);
				BA.TimestampToString(B.Now(), nowS);
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString("    ");
				f.WriteString(nowS);
				f.WriteString(" (UTC+0)");
				f.WriteLn;
				WP.ByDates(f, v.occurD);
				name := textByDate + '.' + textExt;
				Views.Register(TextViews.dir.New(t), Views.dontAsk, loc, name, conv, res); ASSERT(res = 0);
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString("    ");
				f.WriteString(nowS);
				f.WriteString(" (UTC+0)");
				f.WriteLn;
				WP.ByNames(f, v.occurN);
				name := textByName + '.' + textExt;
				Views.Register(TextViews.dir.New(t), Views.dontAsk, loc, name, conv, res); ASSERT(res = 0);
			END;
		END StoreText;
	
	PROCEDURE (v: View) InstallText, NEW;
		
		BEGIN (*InstallText*)
			v.text := TextViews.dir.New(TextModels.dir.New());
			Stores.Join(v, v.text);
			v.text.ThisController().SetOpts({Containers.noCaret});
			v.UpdateText;
		END InstallText;
	
	PROCEDURE (v: View) CopyFromModelView (source: Views.View; model: Models.Model);
		
		BEGIN (*CopyFromModelView*)
			WITH source: View DO
				v.occurD := source.occurD.Copy();
				v.occurN := source.occurN.Copy();
				IF model = NIL THEN
					v.text := Views.CopyOf(source.text, Views.deep)(TextViews.View);
				ELSE
					v.text := Views.CopyWithNewModel(source.text, model)(TextViews.View);
				END;
				v.modified := source.modified;
			END;
		END CopyFromModelView;
	
	PROCEDURE (v: View) ThisModel (): Models.Model;
		
		BEGIN (*ThisModel*)
			RETURN v.text.ThisModel();
		END ThisModel;
	
	PROCEDURE (v: View) InitContext (context: Models.Context);
		
		BEGIN (*InitContext*)
			v.InitContext^(context);
			v.text.InitContext(context);
		END InitContext;
	
	PROCEDURE (v: View) Neutralize;
		
		BEGIN (*Neutralize*)
			v.text.Neutralize;
		END Neutralize;
	
	PROCEDURE (v: View) Restore (f: Views.Frame; l, t, r, b: INTEGER);
		
		BEGIN (*Restore*)
			Views.InstallFrame(f, v.text, 0, 0, 0, TRUE);
		END Restore;
	
	PROCEDURE (v: View) HandleViewMsg (f: Views.Frame; VAR msg: Views.Message);
		
		BEGIN (*HandleViewMsg*)
			WITH msg: FindMsg DO
				IF msg.v = NIL THEN
					msg.v := v;
				END;
			ELSE
			END;
		END HandleViewMsg;
	
	PROCEDURE (v: View) HandleCtrlMsg (f: Views.Frame; VAR msg: Controllers.Message; VAR focus: Views.View);
		
		BEGIN (*HandleCtrlMsg*)
			WITH
				|msg: Controllers.PollOpsMsg DO
					msg.type := "Duniter0WWViews.View";
					IF v.text.ThisController().HasSelection() THEN
						msg.valid := {Controllers.copy};
					END;
				ELSE
					focus := v.text;
			END;
		END HandleCtrlMsg;
	
	PROCEDURE (v: View) HandlePropMsg (VAR p: Properties.Message);
		
		BEGIN (*HandlePropMsg*)
			WITH 
				|p: Properties.SizePref DO
					IF p.w = Views.undefined THEN
						p.w := width;
					END;
					IF p.h = Views.undefined THEN
						p.h := height;
					END;
				|p: Properties.ResizePref DO
					p.verFitToWin := TRUE;
					p.horFitToWin := TRUE;
				ELSE
					Views.HandlePropMsg(v.text, p);
			END;
		END HandlePropMsg;
	
	PROCEDURE Focus* (): Views.View;
		
		VAR
			
			v: Views.View;
		
		BEGIN (*Focus*)
			v := Controllers.FocusView();
			IF (v # NIL) & (v IS View) THEN
				RETURN v;
			ELSE
				RETURN NIL;
			END;
		END Focus;
	
	PROCEDURE Rewrite;
		
		VAR
			
			v: View;
		
		BEGIN (*Rewrite*)
			v := FindFirst();
			IF v # NIL THEN
				v.WriteText;
			END;
		END Rewrite;
	
	PROCEDURE Update;
		
		VAR
			
			v: View;
		
		BEGIN (*Update*)
			v := FindFirst();
			IF v # NIL THEN
				v.UpdateText;
				v.WriteText;
			END;
		END Update;
	
	(* Remove the asterik marks and the button "Check"; open the new and old versions of metadata and entries data for comparisons *)
	PROCEDURE Clear*;
		
		VAR
			
			v: View;
			vv: TextViews.View;
			vvo: Views.View;
			loc: Files.Locator;
			dN: INTEGER;
		
		BEGIN (*Clear*)
			v := FindFirst();
			IF v # NIL THEN
				v.modified := FALSE;
				v.WriteText;
				IF showOldEntries THEN
					loc := Files.dir.This(""); ASSERT(loc.res = 0, 100);
					
					vvo := Views.OldView(loc, oldMetaName);
					IF vvo # NIL THEN
						IF dateNameMeta # meta THEN
							dN := dateNameMeta;
							dateNameMeta := meta;
							Rewrite;
							vv := Stores.CopyOf(v.text)(TextViews.View);
							dateNameMeta := dN;
							Rewrite;
						ELSE
							vv := Stores.CopyOf(v.text)(TextViews.View);
						END;
						Views.OpenView(vv);
						StdCmds.SetEditMode;
						SetNotDirty(vv);
						Views.OpenView(vvo);
						DevSearch.Compare;
					END;
					
					vvo := Views.OldView(loc, oldEntriesName);
					IF vvo # NIL THEN
						IF dateNameMeta # byDate THEN
							dN := dateNameMeta;
							dateNameMeta := byDate;
							Rewrite;
							vv := Stores.CopyOf(v.text)(TextViews.View);
							dateNameMeta := dN;
							Rewrite;
						ELSE
							vv := Stores.CopyOf(v.text)(TextViews.View);
						END;
						Views.OpenView(vv);
						StdCmds.SetEditMode;
						SetNotDirty(vv);
						Views.OpenView(vvo);
						DevSearch.Compare;
					END;
					
				END;
			END;
		END Clear;
	
	(* Mark the view as modified *)
	PROCEDURE SetModified*;
		
		VAR
			
			v: View;
		
		BEGIN (*SetModified*)
			v := FindFirst();
			IF v # NIL THEN
				v.modified := TRUE;
				v.WriteText;
			END;
		END SetModified;
	
	PROCEDURE DateNameMetaNotifier* (op, from, to: INTEGER);
		
		BEGIN (*DateNameMetaNotifier*)
			IF op = Dialog.changed THEN
				Rewrite;
			END;
		END DateNameMetaNotifier;
	
	PROCEDURE ShowOldEntries*;
		
		BEGIN (*ShowOldEntries*)
			showOldEntries := TRUE;
		END ShowOldEntries;
	
	PROCEDURE HideOldEntries*;
		
		BEGIN (*HideOldEntries*)
			showOldEntries := FALSE;
		END HideOldEntries;
	
	PROCEDURE StoreMaxStackLength;
		
		VAR
			
			l: Files.Locator;
			f: Files.File;
			wr: Stores.Writer;
			res: INTEGER;
		
		BEGIN (*StoreMaxStackLength*)
			l := Files.dir.This(maxStackLengthDir); ASSERT(l.res = 0);
			f := Files.dir.New(l, Files.dontAsk); ASSERT(f # NIL);
			wr.ConnectTo(f);
			wr.WriteLong(maxStackLength);
			f.Register(maxStackLengthName, '', Files.dontAsk, res); ASSERT(res = 0);
		END StoreMaxStackLength;
	
	PROCEDURE MaxStackLengthOK*;
		
		BEGIN (*MaxStackLengthOK*)
			IF maxStackLength # oldMaxStackLength THEN
				oldMaxStackLength := maxStackLength;
				W.ChangeMaxStackLength(maxStackLength);
				StoreMaxStackLength;
			END;
		END MaxStackLengthOK;
	
	PROCEDURE MaxStackLengthOKGuard* (VAR par: Dialog.Par);
		
		BEGIN (*MaxStackLengthOKGuard*)
			par.disabled := maxStackLength = oldMaxStackLength;
		END MaxStackLengthOKGuard;
	
	PROCEDURE New* (): Views.View;
		
		VAR
			
			v: View;
		
		BEGIN (*New*)
			NEW(v);
			A.New(v.occurD);
			v.InstallText;
			v.modified := FALSE;
			v.WriteText;
			RETURN v;
		END New;
	
	PROCEDURE Deposit*;
		
		BEGIN (*Deposit*)
			Views.Deposit(New());
		END Deposit;
	
	PROCEDURE Open*;
		
		BEGIN (*Open*)
			Views.OpenAux(New(), title);
		END Open;
	
	PROCEDURE Init;
		
		VAR
			
			l: Files.Locator;
			f: Files.File;
			rd: Stores.Reader;
		
		BEGIN (*Init*)
			dateNameMeta := byName;
			showOldEntries := FALSE;
			l := Files.dir.This(maxStackLengthDir);
			f := Files.dir.Old(l, maxStackLengthName, Files.shared);
			IF f = NIL THEN
				maxStackLength := W.maxStackLength;
				StoreMaxStackLength;
			ELSE
				rd.ConnectTo(f);
				rd.ReadLong(maxStackLength);
				W.ChangeMaxStackLength(maxStackLength);
			END;
			oldMaxStackLength := maxStackLength;
			B.AddUpdateProc(Update, FALSE);
		END Init;
	
	BEGIN (*Duniter0WWViews*)
		Init;
	CLOSE
		B.RemoveUpdateProc(Update, FALSE);
	END Duniter0WWViews.

"Duniter0WWViews.Deposit;StdCmds.Open"

Duniter0Blockchain.UpdateAll;

Duniter0WWViews.Clear;

Duniter0WWViews.SetModified;

Duniter0WWViews.ShowOldEntries;

Duniter0WWViews.HideOldEntries;
