(* 
Duniter0: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0CentralitiesStressD;
	
	(* Calculate the stress centrality with Ulrik Brandes' algorithm, slightly modified to deal with the fact that only paths between members have to be considered, and limited to B.pars.stepMax distance *)
	
	

	IMPORT
		
		(*
		L := StdLog,
		*)
		
		BA := Duniter0Basic, B := Duniter0Blockchain, N := UtilNetStressD, Math, UtilSort;
	
	TYPE
		
		Net = POINTER TO RECORD (N.Net)
		END;
		
		Node = POINTER TO RECORD (N.Node)
			p: B.Pubkey;
			pos: B.CertPos;
		END;
		
		One = RECORD
			p: B.Pubkey;
			c: REAL;
		END;
		
		Ones = POINTER TO ARRAY OF One;
		
		OnesSort = RECORD (UtilSort.T)
			ones: Ones;
		END;
	
		Central* = POINTER TO RECORD
			id-: B.String;
			c-: REAL;
		END;
		
		Centrals* = POINTER TO ARRAY OF Central;
		
		CentralSort = EXTENSIBLE RECORD (UtilSort.T)
			c: Centrals
		END;
		
		CentralSortId = RECORD (CentralSort)
		END;
	
	VAR
		
		net: Net;
		allOnes: OnesSort;
	
	PROCEDURE (VAR s: OnesSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			o: One;
		
		BEGIN (*Swap*)
			o := s.ones[p1]; s.ones[p1] := s.ones[p2]; s.ones[p2] := o;
		END Swap;
	
	PROCEDURE (VAR s: OnesSort) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN s.ones[p1].p < s.ones[p2].p;
		END Less;
	
	PROCEDURE (VAR s: CentralSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			c: Central;
		
		BEGIN (*Swap*)
			c := s.c[p1]; s.c[p1] := s.c[p2]; s.c[p2] := c;
		END Swap;
	
	PROCEDURE (VAR s: CentralSort) Less (p1, p2: INTEGER): BOOLEAN, EXTENSIBLE;
		
		BEGIN (*Less*)
			RETURN (s.c[p1].c > s.c[p2].c) OR (s.c[p1].c = s.c[p2].c) & (BA.CompP(s.c[p1].id, s.c[p2].id) = BA.lt);
		END Less;
	
	PROCEDURE (VAR s: CentralSortId) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN BA.CompP(s.c[p1].id, s.c[p2].id) = BA.lt;
		END Less;
	
	PROCEDURE NewNode (IN p: B.Pubkey): Node;
		
		VAR
			
			n: Node;
		
		BEGIN (*NewNode*)
			NEW(n);
			n.p := p;
			RETURN n;
		END NewNode;
	
	PROCEDURE (net: Net) Number (): INTEGER; 
		
		BEGIN (*Number*)
			RETURN B.IdLen();
		END Number;
	
	PROCEDURE (net: Net) Enumerate (first: BOOLEAN; OUT node: N.Node; OUT member: BOOLEAN): BOOLEAN;
		
		VAR
			
			p: B.Pubkey;
			id: B.String;
			b: BOOLEAN;
			h: B.Hash;
			bnb: INTEGER;
			exp: LONGINT;
		
		BEGIN (*Enumerate*)
			IF B.IdNextUid(first, id) THEN
				b := B.IdUidComplete(id, p, member, h, bnb, exp); ASSERT(b);
				node := NewNode(p);
				RETURN TRUE;
			END;
			RETURN FALSE;
		END Enumerate;
	
	PROCEDURE (n1: Node) Compare (n2: N.Node): BYTE;
		
		BEGIN (*Compare*)
			WITH n2: Node DO
				IF n1.p < n2.p THEN
					RETURN BA.lt;
				END;
				IF n1.p > n2.p THEN
					RETURN BA.gt;
				END;
				RETURN BA.eq;
			END;
		END Compare;

	PROCEDURE (n: Node) FromTo (first: BOOLEAN; OUT follow: N.Node): BOOLEAN;
		
		VAR
			
			b: BOOLEAN;
			from, to: B.Pubkey;
		
		BEGIN (*FromTo*)
			(* Counterintuitive : the result doesn't depend on the direction of arrows *)
			IF first THEN
				b := B.CertFrom(n.p, n.pos);
			END;
			IF ~n.pos.CertNextPos(from, to) THEN
				RETURN FALSE;
			END;
			follow := NewNode(to);
			RETURN TRUE;
		END FromTo;
	
	PROCEDURE CountOne* (p: B.Pubkey): REAL;
		
		VAR
			
			len: INTEGER;
		
		BEGIN (*CountOne*)
			len := LEN(allOnes.ones) - 1;
			allOnes.ones[len].p := p;
			allOnes.BinSearch(0, len - 1, len);
			ASSERT(len < LEN(allOnes.ones) - 1, 100);
			RETURN allOnes.ones[len].c;
		END CountOne;
	
	PROCEDURE Count* (OUT centers, centersId: Centrals);
		
		VAR
			
			i, len: INTEGER;
			b: BOOLEAN;
			c: Central;
			s: CentralSort;
			sId: CentralSortId;
		
		BEGIN (*Count*)
			len := LEN(allOnes.ones) - 1;
			NEW(centers, len);
			NEW(centersId, len);
			FOR i := 0 TO len - 1 DO
				NEW(c);
				b := B.IdPub(allOnes.ones[i].p, c.id); ASSERT(b);
				c.c := allOnes.ones[i].c;
				centers[i] := c;
				centersId[i] := c;
			END;
			s.c := centers;
			s.QuickSort(0, len - 1);
			sId.c := centersId;
			sId.QuickSort(0, len - 1);
		END Count;
	
	PROCEDURE CountAllOnes;
		
		VAR
			
			i, len: INTEGER;
			ok: BOOLEAN;
			cV: LONGINT;
			cT: N.Centrals;
			node: N.Node;
			max: REAL;
		
		BEGIN (*CountAllOnes*)
			cT := net.Centralities(B.pars.stepMax);
			len := net.nbNodes;
			max := 0.;
			NEW(allOnes.ones, len + 1);
			i := 0;
			ok := cT.Walk(TRUE, node, cV);
			WHILE ok DO
				WITH node: Node DO
					allOnes.ones[i].p := node.p;
					allOnes.ones[i].c := Math.Ln(1 + cV);
					max := MAX(max, allOnes.ones[i].c);
					INC(i);
				END;
				ok := cT.Walk(FALSE, node, cV);
			END;
			ASSERT(i = len);
			FOR i := 0 TO len - 1 DO
				allOnes.ones[i] .c := allOnes.ones[i].c / max;
			END;
			allOnes.QuickSort(0, len - 1);
		END CountAllOnes;
	
	PROCEDURE Update (VAR changed: BOOLEAN);
		
		BEGIN (*Update*)
			IF changed THEN
				net.Update;
				CountAllOnes;
			END;
		END Update;
	
	PROCEDURE Init;
		
		VAR
			
			changed: BOOLEAN;
		
		BEGIN (*Init*)
			NEW(net);
			B.AddUpdateProc(Update);
			changed := TRUE;
			Update(changed);
		END Init;
	
	BEGIN (*Duniter0CentralitiesStressD*)
		Init;
	CLOSE
		B.RemoveUpdateProc(Update);
	END Duniter0CentralitiesStressD.

DevDebug.UnloadThis Duniter0CentralitiesStressDPrint Duniter0CentralitiesStressD UtilNetStressD 
