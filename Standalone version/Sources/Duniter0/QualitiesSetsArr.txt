(* 
Duniter0: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0QualitiesSetsArr;
	
	
	
	(* Calculate qualities with UtilSets; numbering of members is done by array; fast *)

	IMPORT
		
		A := UtilAvlTree, BA := Duniter0Basic, B := Duniter0Blockchain, UtilSort, S := UtilSets;
	
	TYPE
		
		Members = POINTER TO ARRAY OF B.Pubkey;
		
		MembersFind = RECORD (UtilSort.T)
			len: INTEGER;
			m: Members;
		END;
		
		Links = POINTER TO ARRAY OF S.Set;
	
		PropOfSentries* = POINTER TO RECORD
			id-: B.String;
			prop-: REAL;
		END;
		
		Props* = POINTER TO ARRAY OF PropOfSentries;
		
		PropsSort = EXTENSIBLE RECORD (UtilSort.T)
			t: Props;
		END;
		
		PropsSortId = EXTENSIBLE RECORD (PropsSort)
		END;
	
	VAR
		
		members: MembersFind;
		links: Links;
		sentries: S.Set;
	
	PROCEDURE (VAR m: MembersFind) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN m.m[i] < m.m[j];
		END Less;
	
	PROCEDURE (VAR s: PropsSort) Swap (i, j: INTEGER);
		
		VAR
			
			p: PropOfSentries;
		
		BEGIN (*Swap*)
			p := s.t[i]; s.t[i] := s.t[j]; s.t[j] := p;
		END Swap;
	
	PROCEDURE (VAR s: PropsSort) Less (p1, p2: INTEGER): BOOLEAN, EXTENSIBLE;
		
		BEGIN (*Less*)
			RETURN (s.t[p1].prop > s.t[p2].prop) OR (s.t[p1].prop = s.t[p2].prop) & (BA.CompP(s.t[p1].id, s.t[p2].id) = A.lt);
		END Less;
	
	PROCEDURE (VAR s: PropsSortId) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN BA.CompP(s.t[p1].id, s.t[p2].id) = A.lt;
		END Less;
	
	PROCEDURE Find (p: B.Pubkey; OUT n: INTEGER): BOOLEAN;
		
		BEGIN (*Find*)
			n := members.len;
			members.m[n] := p;
			members.BinSearch(0, n - 1, n);
			IF n = members.len THEN
				RETURN FALSE;
			END;
			RETURN TRUE;
		END Find;
	
	PROCEDURE Update;
		
		VAR
			
			ok: BOOLEAN;
			p, to: B.Pubkey;
			i, e: INTEGER;
			pos: B.CertPos;
		
		BEGIN (*Update*)
			members.len := B.IdLen();
			NEW(members.m, members.len + 1);
			sentries := S.NewSet();
			i := 0;
			ok := B.IdNextPubkey(TRUE, p);
			WHILE ok DO
				ASSERT((i = 0) OR (p > members.m[i - 1]));
				members.m[i] := p;
				IF B.IsSentry(p) THEN
					sentries.Incl(i);
				END;
				INC(i);
				ok := B.IdNextPubkey(FALSE, p);
			END;
			ASSERT(i = members.len);
			
			NEW(links, members.len);
			FOR i := 0 TO members.len - 1 DO
				links[i] := S.NewSet();
			END;
			FOR i := 0 TO members.len - 1 DO
				ok := B.CertTo(members.m[i], pos) & pos.CertNextPos(p, to);
				WHILE ok DO
					IF Find(p, e) THEN
						links[i].Incl(e);
					END;
					ok := pos.CertNextPos(p, to);
				END;
			END;
		END Update;
	
	PROCEDURE PercentOfSentries (IN pubkey: B.Pubkey): REAL;
		
		VAR
			
			set, frontier, newFrontier: S.Set;
			frontierI: S.SetIterator;
			e, i: INTEGER;
			ok: BOOLEAN;
		
		BEGIN (*PercentOfSentries*)
			IF ~Find(pubkey, e) THEN
				RETURN 0.;
			END;
			set := S.NewSet();
			set.Incl(e);
			frontier := S.NewSet();
			frontier.Incl(e);
			FOR i := 1 TO B.pars.stepMax - 1 DO
				newFrontier := S.NewSet();
				frontierI.Attach(frontier);
				ok := frontierI.FirstE(e);
				WHILE ok DO
					newFrontier := newFrontier.Union(links[e]);
					ok := frontierI.NextE(e);
				END;
				frontier := newFrontier;
				set := set.Union(frontier);
			END;
			RETURN set.Inter(sentries).nbElems / sentries.nbElems;
		END PercentOfSentries;
	
	PROCEDURE Count* (OUT props, propsId: Props);
		
		VAR
			
			ok, b: BOOLEAN;
			p: B.Pubkey;
			i, n: INTEGER;
			c: PropOfSentries;
			s: PropsSort;
			sId: PropsSortId;
		
		BEGIN (*Count*)
			n := B.IdLenM();
			NEW(props, n);
			i := 0;
			ok := B.IdNextPubkeyM(TRUE, p);
			WHILE ok DO
				NEW(c);
				b := B.IdPub(p, c.id); ASSERT(b);
				c.prop := PercentOfSentries(p);
				props[i] := c;
				INC(i);
				ok := B.IdNextPubkeyM(FALSE, p);
			END;
			s.t := props;
			s.QuickSort(0, n - 1);
			NEW(propsId, n);
			FOR i := 0 TO n - 1 DO
				propsId[i] := props[i];
			END;
			sId.t := propsId;
			sId.QuickSort(0, n - 1);
		END Count;
	
	PROCEDURE CountOne* (p: B.Pubkey): REAL;
		
		BEGIN (*CountOne*)
			RETURN PercentOfSentries(p);
		END CountOne;
	
	BEGIN (*Duniter0QualitiesSetsArr*)
		B.AddUpdateProc(Update);
		B.UpdateAll;
	CLOSE
		B.RemoveUpdateProc(Update);
	END Duniter0QualitiesSetsArr.
