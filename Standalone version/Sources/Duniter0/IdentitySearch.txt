(* 
Duniter0: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter0IdentitySearch;
	
	

	IMPORT
		
		(**
		L := StdLog,
		**)
		
		A := UtilAvlTree, B := Duniter0Blockchain, Dialog, S := Duniter0Sandbox, BA := Duniter0Basic, C := Duniter0CentralitiesStressD, Fonts, Ports, Strings, TextMappers, TextModels, TextViews, UtilSort, Views;
	
	CONST
		
		maxItems = 100;
		
		nonEditableNb = 12;
		
		oldIcon = '×';
		futureIcon = 'º';
	
	TYPE
		
		IdE = POINTER TO RECORD (A.Elem)
			uid: BA.String;
			hash: B.Hash;
			future,
			active: BOOLEAN;
		END;
		
		NonEditable* = ARRAY 2 * nonEditableNb OF Dialog.String;
		
		Ring = POINTER TO ABSTRACT RECORD
			next, prev: Ring;
			item: B.String;
		END;
		
		RingHd = POINTER TO RECORD (Ring)
			pos: Ring;
		END;
		
		RingEl = POINTER TO RECORD (Ring)
		END;
		
		ExpSort = RECORD (UtilSort.T)
			ids: POINTER TO ARRAY OF Dialog.String;
			dates: POINTER TO ARRAY OF BA.DateTime;
			exps: POINTER TO ARRAY OF LONGINT;
		END;
	
	VAR
		
		hint*: Dialog.Combo;
		
		ring: RingHd;
		
		identityOldNb-,
		identityNb-,
		identityFutNb-: INTEGER;
		identityDispOld*,
		identityDispMem*,
		identityDispFut*: BOOLEAN;
		identityList*: Dialog.List;
		identityHash: POINTER TO ARRAY OF S.Hash;
		
		identity*: RECORD
			member-,
			sentry-,
			calcDist*,
			distanceOK-,
			calcQual*,
			calcCentr*: BOOLEAN;
			fields*: NonEditable; (* uid (0), pubkey (1), limit date (2), limit date of received cert (3), limit date of sent cert (4), hash (5), proportionOfSentries (6), availability (7), inscriptionBlock (8), inscriptionDate (9), quality (10), centrality (11) *)
		END;
		
		receivedCertsNb-,
		receivedCertsFutNb-,
		sentCertsNb-,
		sentCertsFutNb-: INTEGER;
		receivedCerts*,
		sentCerts*: Dialog.List;
		receivedHash,
		sentHash: POINTER TO ARRAY OF S.Hash;
	
	PROCEDURE (i1: IdE) Compare (i2: A.Elem): BYTE;
		
		VAR
			
			b: BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdE DO
				b := BA.CompP(i1.uid, i2.uid);
				IF b # A.eq THEN
					RETURN b;
				END;
				IF i1.future & ~i2.future THEN
					RETURN A.lt;
				END;
				IF ~i1.future & i2.future THEN
					RETURN A.gt;
				END;
				IF i1.hash < i2.hash THEN
					RETURN A.lt;
				END;
				IF i1.hash > i2.hash THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE InitRing (OUT ring: RingHd);
		
		BEGIN (*InitRing*)
			NEW(ring);
			ring.next := ring; ring.prev := ring;
			ring.pos := ring;
			NEW(ring.item, 1); ring.item^ := "";
		END InitRing;
	
	PROCEDURE (ring: RingHd) First (OUT item: POINTER TO ARRAY OF CHAR), NEW;
		
		BEGIN (*First*)
			ring.pos := ring;
			item := ring.item;
		END First;
	
	PROCEDURE (ring: RingHd) BackEmpty (): BOOLEAN, NEW;
		
		BEGIN (*BackEmpty*)
			RETURN ring.pos = ring;
		END BackEmpty;
	
	PROCEDURE (ring: RingHd) ForthEmpty (): BOOLEAN, NEW;
		
		BEGIN (*ForthEmpty*)
			RETURN ring.pos.next = ring;
		END ForthEmpty;
	
	PROCEDURE (ring: RingHd) Push (IN item: ARRAY OF CHAR), NEW;
		
		VAR
			
			r: RingEl;
		
		BEGIN (*Push*)
			IF (ring.pos = ring) OR (ring.pos.item$ # item$) THEN
				NEW(r);
				r.next := ring; r.prev := ring.pos;
				ring.prev := r; ring.pos.next := r;
				ring.pos := r;
				NEW(r.item, LEN(item$) + 1); r.item^ := item$;
			END;
		END Push;
	
	PROCEDURE (ring: RingHd) Change (IN item: ARRAY OF CHAR), NEW;
		
		BEGIN (*Change*)
			NEW(ring.pos.item, LEN(item$) + 1); ring.pos.item^ := item$;
		END Change;
	
	PROCEDURE (ring: RingHd) Back (OUT item: POINTER TO ARRAY OF CHAR): BOOLEAN, NEW;
		
		BEGIN (*Back*)
			IF ring.pos = ring THEN
				RETURN FALSE;
			END;
			ring.pos := ring.pos.prev;
			item := ring.pos.item;
			RETURN TRUE;
		END Back;
	
	PROCEDURE (ring: RingHd) Forth (OUT item: POINTER TO ARRAY OF CHAR): BOOLEAN, NEW;
		
		BEGIN (*Forth*)
			IF ring.pos.next = ring THEN
				RETURN FALSE;
			END;
			ring.pos := ring.pos.next;
			item := ring.pos.item;
			RETURN TRUE;
		END Forth;
	
	PROCEDURE UpdateCombo (VAR c: Dialog.Combo; maxItems: INTEGER);
		
		VAR
			
			s: Dialog.String;
			i, j: INTEGER;
			found: BOOLEAN;
		
		BEGIN (*UpdateCombo*)
			IF c.item # "" THEN
				j := - 1; found := FALSE;
				WHILE (j < c.len - 1) & ~found DO
					INC(j);
					c.GetItem(j, s);
					found := s = c.item;
				END;
				IF ~found THEN
					j := MIN(c.len, maxItems - 1);
				END;
				FOR i := j - 1 TO 0 BY - 1 DO
					c.GetItem(i, s);
					c.SetItem(i + 1, s);
				END;
				c.SetItem(0, c.item);
				Dialog.UpdateList(c);
			END;
		END UpdateCombo;
	
	PROCEDURE Find (IN hint: ARRAY OF CHAR; OUT nO, nA, nF: INTEGER): A.Tree;
		
		VAR
			
			t, set: A.Tree;
			idE: IdE;
			e: A.Elem;
			b, ok, active: BOOLEAN;
			uid: BA.String;
			pub, p: B.Pubkey;
			hash: S.Hash;
			exp, app: LONGINT;
			pos, bloc, n: INTEGER;
			hintD: BA.String;
		
		BEGIN (*Find*)
			A.New(t); A.New(set);
			hintD := BA.ToDown(hint);
			B.IdPosUid(hintD);
			nO := 0; nA := 0;
			ok := B.IdNextUid(FALSE, uid);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok & B.IdUidComplete(uid, p, active, hash, bloc, app, exp) THEN
					NEW(idE);
					idE.uid := uid; idE.hash := hash;
					e := idE;
					b := set.SearchIns(e, n); ASSERT(~b, 100);
					IF active THEN
						INC(nA);
					ELSE
						INC(nO);
					END;
					IF (identityDispOld & ~active) OR (identityDispMem & active) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := FALSE; idE.active := active;
						e := idE;
						b := t.SearchIns(e, n); ASSERT(~b, 101);
					END;
					ok := B.IdNextUid(FALSE, uid);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				pub := hint$;
				B.IdPosPubkey(pub);
				ok := B.IdNextPubkey(FALSE, p);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok & B.IdPubComplete(p, uid, active, hash, bloc, app, exp) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := FALSE; idE.active := active;
						e := idE;
						IF ~set.Search(e, n) THEN
							IF active THEN
								INC(nA);
							ELSE
								INC(nO);
							END;
						END;
						e := idE;
						b := ((identityDispOld & ~active) OR (identityDispMem & active)) & t.SearchIns(e, n);
						ok := B.IdNextPubkey(FALSE, p);
					END;
				END;
			END;
			nF := 0;
			S.IdPosUid(hintD);
			ok := S.IdNextUid(FALSE, uid, hash);
			WHILE ok DO
				ok := BA.Prefix(hintD, uid);
				IF ok THEN
					NEW(idE);
					idE.uid := uid; idE.hash := hash;
					e := idE;
					b := set.SearchIns(e, n); (* ASSERT(~b, 102);*)
					INC(nF);
					IF identityDispFut THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := TRUE; idE.active := FALSE;
						e := idE;
						b := t.SearchIns(e, n); ASSERT(~b, 103);
					END;
					ok := S.IdNextUid(FALSE, uid, hash);
				END;
			END;
			IF LEN(hint$) <= B.pubkeyLen THEN
				S.IdPosPubkey(pub);
				ok := S.IdNextPubkey(FALSE, p, hash);
				WHILE ok DO
					Strings.Find(p, hint, 0, pos);
					ok := pos = 0;
					IF ok & S.IdHash(hash, b, p, uid, exp) THEN
						NEW(idE);
						idE.uid := uid; idE.hash := hash; idE.future := TRUE; idE.active := FALSE;
						e := idE;
						IF ~set.Search(e, n) THEN
							INC(nF);
						END;
						e := idE;
						b := identityDispFut & t.SearchIns(e, n);
						ok := S.IdNextPubkey(FALSE, p, hash);
					END;
				END;
			END;
			RETURN t;
		END Find;
	
	PROCEDURE GetCDate (IN from, to, toH: ARRAY OF CHAR; future: BOOLEAN; OUT exp: LONGINT; OUT date: ARRAY OF CHAR);
		
		VAR
			
			b: BOOLEAN;
			fromP, toP, p: B.Pubkey;
			bloc: INTEGER;
			d: BA.DateTime;
		
		BEGIN (*GetCDate*)
			b := B.IdUid(from, fromP); ASSERT(b, 100);
			IF future THEN
				b := S.Cert(fromP, toH$, p, exp); ASSERT(b, 102);
			ELSE
				b := B.IdUid(to, toP);
				b := B.Cert(fromP, toP, bloc, exp); ASSERT(b, 101);
			END;
			BA.TimestampToString(exp, d);
			date := d$;
		END GetCDate;
	
	PROCEDURE FilterItem (VAR item: ARRAY OF CHAR);
		
		BEGIN (*FilterItem*)
			IF (item[0] = oldIcon) OR (item[0] = futureIcon) THEN
				Strings.Replace(item, 0, 2, '');
			END;
		END FilterItem;
	
	PROCEDURE Certs (IN h: S.Hash; IN pubkey: B.Pubkey; inBC: BOOLEAN);
		
		VAR
			
			okB, okS, b, bb, m: BOOLEAN;
			posB: B.CertPos;
			posS: S.CertPos;
			from, to: B.Pubkey;
			i, bnb, n: INTEGER;
			exp, app: LONGINT;
			uid: BA.String;
			toH: S.Hash;
			p: B.Pubkey;
			t: A.Tree;
			idE: IdE;
			e: A.Elem;
			s: Dialog.String;
		
		BEGIN (*Certs*)
			IF inBC THEN
				okB := B.CertFrom(pubkey, posB);
				IF okB THEN
					sentCertsNb := posB.CertPosLen();
				ELSE
					sentCertsNb := 0;
				END;
				okS := S.CertFrom(pubkey, posS);
				IF okS THEN
					sentCertsFutNb := posS.CertPosLen();
				ELSE
					sentCertsFutNb := 0;
				END;
				sentCerts.SetLen(sentCertsNb + sentCertsFutNb);
				IF sentCerts.len = 0 THEN
					sentHash := NIL;
				ELSE
					NEW(sentHash, sentCerts.len);
				END;
				A.New(t);
				okB := okB & posB.CertNextPos(from, to);
				WHILE okB DO
					NEW(idE);
					b := B.IdPubComplete(to, idE.uid, m, idE.hash, bnb, app, exp); ASSERT(b, 100);
					idE.future := FALSE;
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b, 101);
					okB := posB.CertNextPos(from, to);
				END;
				okS := okS & posS.CertNextPos(from, toH);
				WHILE okS DO
					NEW(idE);
					idE.hash := toH;
					(*
					b := S.Cert(from, toH, to, exp) & (B.IdPubComplete(to, idE.uid, m, hash, bnb, app, exp) OR S.IdHash(toH, bb, p, idE.uid, exp)); ASSERT(b, 102);
					*)
					(**)
					b := S.Cert(from, toH, to, exp) & (B.IdPub(to, idE.uid) OR S.IdHash(toH, bb, p, idE.uid, exp)); ASSERT(b, 102);
					(**)
					idE.future := TRUE;
					e := idE;
					b := t.SearchIns(e, n); ASSERT(~b, 103);
					okS := posS.CertNextPos(from, toH);
				END;
				i := 0;
				e := t.Next(NIL);
				WHILE e # NIL DO
					WITH e: IdE DO
						IF e.future THEN
							sentCerts.SetItem(i, futureIcon + ' ' + e.uid$);
						ELSE
							sentCerts.SetItem(i, e.uid$);
						END;
						sentHash[i] := e.hash;
					END;
					INC(i);
					e := t.Next(e);
				END;
			ELSE
				sentCertsNb := 0;
				sentCertsFutNb := 0;
				sentCerts.SetLen(0);
				sentHash := NIL;
			END;
			sentCerts.index := 0;
			Dialog.UpdateInt(sentCertsNb);
			Dialog.UpdateInt(sentCertsFutNb);
			Dialog.UpdateList(sentCerts);
			IF sentCerts.len = 0 THEN
				identity.fields[8] := "";
			ELSE
				sentCerts.GetItem(sentCerts.index, s);
				b := s[0] = futureIcon;
				FilterItem(s);
				GetCDate(identity.fields[0], s, sentHash[sentCerts.index], b, exp, identity.fields[8]);
			END;
			identity.fields[9] := identity.fields[8];
			
			okB := inBC & B.CertTo(pubkey, posB);
			IF okB THEN
				receivedCertsNb := posB.CertPosLen();
			ELSE
				receivedCertsNb := 0;
			END;
			IF inBC THEN
				okS := B.IdPubComplete(pubkey, uid, m, toH, bnb, app, exp) & S.CertTo(toH, posS);
			ELSE
				okS := S.CertTo(h, posS);
			END;
			IF okS THEN
				receivedCertsFutNb := posS.CertPosLen();
			ELSE
				receivedCertsFutNb := 0;
			END;
			receivedCerts.SetLen(receivedCertsNb + receivedCertsFutNb);
			IF receivedCerts.len = 0 THEN
				receivedHash := NIL;
			ELSE
				NEW(receivedHash, receivedCerts.len);
			END;
			A.New(t);
			okB := okB & posB.CertNextPos(from, to);
			WHILE okB DO
				NEW(idE);
				b := B.IdPubComplete(from, idE.uid, m, idE.hash, bnb, app, exp); ASSERT(b, 104);
				idE.future := FALSE;
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b, 105);
				okB := posB.CertNextPos(from, to);
			END;
			okS := okS & posS.CertNextPos(from, toH);
			WHILE okS DO
				NEW(idE);
				b := B.IdPub(from, idE.uid); ASSERT(b, 106);
				idE.hash := toH;
				idE.future := TRUE;
				e := idE;
				b := t.SearchIns(e, n); ASSERT(~b, 107);
				okS := posS.CertNextPos(from, toH);
			END;
			i := 0;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					IF e.future THEN
						receivedCerts.SetItem(i, futureIcon + ' ' + e.uid$);
					ELSE
						receivedCerts.SetItem(i, e.uid$);
					END;
					receivedHash[i] := e.hash;
				END;
				INC(i);
				e := t.Next(e);
			END;
			receivedCerts.index := 0;
			Dialog.UpdateInt(receivedCertsNb);
			Dialog.UpdateInt(receivedCertsFutNb);
			Dialog.UpdateList(receivedCerts);
			IF receivedCerts.len = 0 THEN
				identity.fields[6] := "";
			ELSE
				receivedCerts.GetItem(receivedCerts.index, s);
				b := s[0] = futureIcon;
				FilterItem(s);
				GetCDate(s, identity.fields[0], receivedHash[receivedCerts.index], b, exp, identity.fields[6]);
			END;
			identity.fields[7] := identity.fields[6];
		END Certs;
	
	PROCEDURE Get (IN hash: S.Hash; IN uid: ARRAY OF CHAR; OUT bloc, blocDate, pubkey, limitDate: ARRAY OF CHAR; OUT inBC, member: BOOLEAN);
		
		VAR
			
			bnb: INTEGER;
			exp, app, mt, t: LONGINT;
			uid2: BA.String;
			p: B.Pubkey;
			h: S.Hash;
			d: BA.DateTime;
			b, bb, m: BOOLEAN;
		
		BEGIN (*Get*)
			inBC := B.IdUidComplete(uid, p, m, h, bnb, app, exp);
			member := inBC & m;
			IF inBC THEN
				Strings.IntToString(bnb, bloc);
				b := B.TimeOf(bnb, mt, t); ASSERT(b, 100);
				BA.TimestampToString(mt, d);
			ELSE
				b := S.IdHash(hash, bb, p, uid2, exp); ASSERT(b, 101);
				bloc := "";
				d := "";
			END;
			pubkey := p$;
			blocDate := d$;
			BA.TimestampToString(exp, d);
			limitDate := d$;
		END Get;
	
	PROCEDURE NotTooFar (member: BOOLEAN; OUT proportionOfSentries: ARRAY OF CHAR): BOOLEAN;
		
		VAR
			
			certifiers: POINTER TO ARRAY OF B.Pubkey;
			s: Dialog.String;
			i, j, n: INTEGER;
			b: BOOLEAN;
			prop: REAL;
		
		BEGIN (*NotTooFar*)
			IF member THEN
				n := receivedCertsNb + 1;
				i := 1;
			ELSE
				n := receivedCerts.len;
				i := 0;
			END;
			IF n = 0 THEN
				proportionOfSentries := "0.00%";
				RETURN FALSE;
			END;
			NEW(certifiers, n);
			IF member THEN
				certifiers[0] := identity.fields[2]$;
			END;
			FOR j := 0 TO receivedCerts.len - 1 DO
				receivedCerts.GetItem(j, s);
				IF (s[0] # futureIcon) OR ~member THEN
					FilterItem(s);
					b := B.IdUid(s, certifiers[i]); ASSERT(b, 100);
					INC(i);
				END;
			END;
			prop := B.PercentOfSentries(certifiers);
			Strings.RealToStringForm(100 * prop, 16, 6, - 2, '', proportionOfSentries);
			proportionOfSentries := proportionOfSentries + "%";
			RETURN prop >= B.pars.xpercent;
		END NotTooFar;
	
	PROCEDURE FixCertNextDate (member: BOOLEAN; IN p: B.Pubkey; OUT date: ARRAY OF CHAR);
		
		VAR
			
			pos: B.CertPos;
			ok, b: BOOLEAN;
			from, to: B.Pubkey;
			block_number: INTEGER;
			tm, t, exp, d: LONGINT;
			da: BA.DateTime;
		
		BEGIN (*FixCertNextDate*)
			IF member THEN
				d := 0;
				IF B.CertFrom(p, pos) THEN
					ok := pos.CertNextPos(from, to);
					WHILE ok DO
						b := B.Cert(from, to, block_number, exp); ASSERT(b, 100);
						b := B.TimeOf(block_number, tm, t); ASSERT(b, 101);
						d := MAX(d, tm);
						ok := pos.CertNextPos(from, to);
					END;
					INC(d, B.pars.sigPeriod);
					BA.TimestampToString(d, da);
					IF d <= B.Now() THEN
						date := "! " + da$;
					ELSE
						date := da$;
					END;
				ELSE
					date := "!";
				END;
			ELSE
				date := "";
			END;
		END FixCertNextDate;
	
	PROCEDURE CalcQuality (OUT quality: ARRAY OF CHAR);
		
		VAR
			
			pubs: ARRAY 1 OF B.Pubkey;
		
		BEGIN (*CalcQuality*)
			pubs[0] := identity.fields[2]$;
			Strings.RealToStringForm(100 * B.PercentOfSentries(pubs), 16, 6, - 2, '', quality);
			quality := quality + "%";
		END CalcQuality;
	
	PROCEDURE CalcCentrality (inBC: BOOLEAN; OUT centrality: ARRAY OF CHAR);
		
		BEGIN (*CalcCentrality*)
			IF inBC THEN
				Strings.RealToStringForm(100 * C.CountOne(identity.fields[2]$), 16, 6, - 2, '', centrality);
				centrality := centrality + "%";
			ELSE
				centrality := "0.00%"
			END;
		END CalcCentrality;
	
	PROCEDURE Fix;
		
		VAR
			
			i: INTEGER;
			hash: B.Hash;
			inBC: BOOLEAN;
		
		BEGIN (*Fix*)
			IF identityList.len > 0 THEN
				ring.Change(identity.fields[0]);
				hash := identityHash[identityList.index];
				identity.fields[10] := hash$;
				Get(hash, identity.fields[0], identity.fields[16], identity.fields[18], identity.fields[2], identity.fields[4], inBC, identity.member);
				identity.sentry := identity.member & B.IsSentry(identity.fields[2]$);
				FixCertNextDate(identity.member, identity.fields[2]$, identity.fields[14]);
				Certs(hash, identity.fields[2]$, inBC);
				IF identity.calcDist THEN
					identity.distanceOK := NotTooFar(identity.member, identity.fields[12]);
				END;
				IF identity.calcQual THEN
					CalcQuality(identity.fields[20]);
				END;
				IF identity.calcCentr THEN
					CalcCentrality(inBC, identity.fields[22]);
				END;
				FOR i := 0 TO nonEditableNb - 1 DO
					identity.fields[2 * i + 1] := identity.fields[2 * i];
				END;
				Dialog.Update(identity);
			END;
		END Fix;
	
	PROCEDURE DoSearch;
		
		VAR
			
			t: A.Tree;
			e: A.Elem;
			i: INTEGER;
		
		BEGIN (*DoSearch*)
			IF ring.BackEmpty() THEN
				A.New(t);
				identityOldNb := 0; identityNb := 0; identityFutNb := 0;
			ELSE
				UpdateCombo(hint, maxItems);
				t := Find(hint.item, identityOldNb, identityNb, identityFutNb);
			END;
			Dialog.UpdateInt(identityOldNb);
			Dialog.UpdateInt(identityNb);
			Dialog.UpdateInt(identityFutNb);
			identityList.SetLen(t.NumberOfElems());
			IF identityList.len = 0 THEN
				identityHash := NIL;
			ELSE
				NEW(identityHash, identityList.len);
			END;
			i := 0;
			e := t.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdE DO
					identityHash[i] := e.hash;
					IF e.future THEN
						identityList.SetItem(i, futureIcon + ' ' + e.uid$);
					ELSIF e.active THEN
						identityList.SetItem(i, e.uid$);
					ELSE
						identityList.SetItem(i, oldIcon + ' ' + e.uid$);
					END;
				END;
				INC(i);
				e := t.Next(e);
			END;
			identityList.index := 0;
			Dialog.UpdateList(identityList);
			IF identityList.len = 0 THEN
				receivedCertsNb := 0;
				receivedCertsFutNb := 0;
				receivedCerts.SetLen(0);
				sentCertsNb := 0;
				sentCertsFutNb := 0;
				sentCerts.SetLen(0);
				identity.member := FALSE;
				identity.sentry := FALSE;
				identity.distanceOK := FALSE;
				FOR i := 0 TO 2 * nonEditableNb - 1 DO
					identity.fields[i] := "";
				END;
				Dialog.UpdateInt(identityOldNb);
				Dialog.UpdateInt(identityNb);
				Dialog.UpdateInt(identityFutNb);
				Dialog.UpdateInt(receivedCertsNb);
				Dialog.UpdateInt(receivedCertsFutNb);
				Dialog.UpdateList(receivedCerts);
				Dialog.UpdateInt(sentCertsNb);
				Dialog.UpdateInt(sentCertsFutNb);
				Dialog.UpdateList(sentCerts);
				Dialog.Update(identity);
			ELSE
				identityList.GetItem(identityList.index, identity.fields[0]);
				FilterItem(identity.fields[0]);
				Fix;
			END;
		END DoSearch;
	
	PROCEDURE Search*;
		
		BEGIN (*Search*)
			ring.Push(hint.item);
			DoSearch;
		END Search;
	
	PROCEDURE First*;
		
		VAR
			
			item: POINTER TO ARRAY OF CHAR;
		
		BEGIN (*First*)
			IF ~ring.BackEmpty() THEN
				ring.First(item);
				hint.item := item$;
				Dialog.Update(hint);
				DoSearch;
			END;
		END First;
	
	PROCEDURE Backward*;
		
		VAR
			
			item: POINTER TO ARRAY OF CHAR;
		
		BEGIN (*Backward*)
			IF ring.Back(item) THEN
				hint.item := item$;
				Dialog.Update(hint);
				DoSearch;
			END;
		END Backward;
	
	PROCEDURE Forward*;
		
		VAR
			
			item: POINTER TO ARRAY OF CHAR;
		
		BEGIN (*Forward*)
			IF ring.Forth(item) THEN
				hint.item := item$;
				Dialog.Update(hint);
				DoSearch;
			END;
		END Forward;
	
	PROCEDURE BackwardGuard* (VAR par: Dialog.Par);
		
		BEGIN (*BackwardGuard*)
			par.disabled := ring.BackEmpty();
		END BackwardGuard;
	
	PROCEDURE ForwardGuard* (VAR par: Dialog.Par);
		
		BEGIN (*ForwardGuard*)
			par.disabled := ring.ForthEmpty();
		END ForwardGuard;
	
	PROCEDURE DistanceGuard* (VAR par: Dialog.Par);
		
		BEGIN (*DistanceGuard*)
			par.disabled := ~identity.calcDist;
		END DistanceGuard;
	
	PROCEDURE QualityGuard* (VAR par: Dialog.Par);
		
		BEGIN (*QualityGuard*)
			par.disabled := ~identity.calcQual;
		END QualityGuard;
	
	PROCEDURE CentralityGuard* (VAR par: Dialog.Par);
		
		BEGIN (*CentralityGuard*)
			par.disabled := ~identity.calcCentr;
		END CentralityGuard;
	
	PROCEDURE DistanceNotifier* (op, from, to: INTEGER);
		
		BEGIN (*DistanceNotifier*)
			IF (op = Dialog.changed) & identity.calcDist THEN
				Fix;
			END;
		END DistanceNotifier;
	
	PROCEDURE QualityNotifier* (op, from, to: INTEGER);
		
		BEGIN (*QualityNotifier*)
			IF (op = Dialog.changed) & identity.calcQual THEN
				Fix;
			END;
		END QualityNotifier;
	
	PROCEDURE CentralityNotifier* (op, from, to: INTEGER);
		
		BEGIN (*CentralityNotifier*)
			IF (op = Dialog.changed) & identity.calcCentr THEN
				Fix;
			END;
		END CentralityNotifier;
	
	PROCEDURE CopyReceived*;
		
		BEGIN (*CopyReceived*)
			IF receivedCerts.len > 0 THEN
				receivedCerts.GetItem(receivedCerts.index, hint.item);
				FilterItem(hint.item);
				Dialog.UpdateList(hint);
				Search;
			END;
		END CopyReceived;
	
	PROCEDURE CopySent*;
		
		BEGIN (*CopySent*)
			IF sentCerts.len > 0 THEN
				sentCerts.GetItem(sentCerts.index, hint.item);
				FilterItem(hint.item);
				Dialog.UpdateList(hint);
				Search;
			END;
		END CopySent;
	
	PROCEDURE (VAR e: ExpSort) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN (e.exps[i] < e.exps[j]) OR (e.exps[i] = e.exps[j]) & (BA.CompP(e.ids[i], e.ids[j]) = BA.lt);
		END Less;
	
	PROCEDURE (VAR e: ExpSort) Swap (i, j: INTEGER);
		
		VAR
			
			id: Dialog.String;
			date: BA.DateTime;
			exp: LONGINT;
		
		BEGIN (*Swap*)
			id := e.ids[i]; e.ids[i] := e.ids[j]; e.ids[j] := id;
			date := e.dates[i]; e.dates[i] := e.dates[j]; e.dates[j] := date;
			exp := e.exps[i]; e.exps[i] := e.exps[j]; e.exps[j] := exp;
		END Swap;
	
	PROCEDURE PrintCertifiers*;
		
		VAR
			
			cert: B.StringArr;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			i, j, bnb: INTEGER;
			item: Dialog.String;
			title: Views.Title;
			a: TextModels.Attributes;
			es: ExpSort;
			p, q: B.Pubkey;
			b, bb, m: BOOLEAN;
			h: B.Hash;
			uid: BA.String;
			exp, app: LONGINT;
		
		BEGIN (*PrintCertifiers*)
			IF identity.fields[0] # "" THEN
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString(identity.fields[0]);
				f.WriteLn; f.WriteLn;
				IF receivedCerts.len > 0 THEN
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:PresentCertifiers");
					f.rider.SetAttr(a);
					f.WriteString(" ("); f.WriteInt(receivedCertsNb);
					f.WriteString(" + "); f.WriteInt(receivedCertsFutNb); f.WriteString(")");
					f.WriteLn; f.WriteLn;
					NEW(es.ids, receivedCerts.len);
					NEW(es.dates, receivedCerts.len);
					NEW(es.exps, receivedCerts.len);
					j := 0;
					FOR i := 0 TO receivedCerts.len - 1 DO
						receivedCerts.GetItem(i, item);
						f.WriteString(item); f.WriteLn;
						es.ids[j] := item;
						b := item[0] # futureIcon;
						FilterItem(item);
						IF b OR B.IdUid(item, p) & B.IdUid(identity.fields[0], q) & ~B.Cert(p, q, bnb, exp) OR S.IdHash(identity.fields[5]$, bb, q, uid, exp) & ~bb THEN
							b := B.IdUidComplete(item, p, m, h, bnb, app, es.exps[j]); ASSERT(b, 100);
							IF ~m THEN
								es.ids[j] := oldIcon + item;
							END;
							BA.TimestampToString(es.exps[j], es.dates[j]);
							INC(j);
						END;
					END;
					f.WriteLn;
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:SortedByMExpDates");
					f.rider.SetAttr(a);
					f.WriteLn; f.WriteLn;
					es.QuickSort(0, j - 1);
					FOR i := 0 TO j - 1 DO
						f.WriteString(es.dates[i]); f.WriteTab;
						f.WriteString(es.ids[i]);
						f.WriteLn;
					END;
					f.WriteLn;
					FOR i := 0 TO receivedCerts.len - 1 DO
						receivedCerts.GetItem(i, item);
						b := item[0] = futureIcon;
						es.ids[i] := item;
						FilterItem(item);
						GetCDate(item, identity.fields[0], receivedHash[i], b, es.exps[i], es.dates[i]);
					END;
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:SortedByCExpDates");
					f.rider.SetAttr(a);
					f.WriteLn; f.WriteLn;
					es.QuickSort(0, receivedCerts.len - 1);
					j := receivedCerts.len; i := B.pars.sigQty;
					WHILE (i > 0) & (j > 0) DO
						DEC(j);
						IF es.ids[j][0] # futureIcon THEN
							DEC(i);
						END;
					END;
					IF i > 0 THEN (* Less than B.pars.sigQty certifications : don't display. *)
						j := - 1;
					END;
					FOR i := 0 TO receivedCerts.len - 1 DO
						IF i = j THEN
							a := f.rider.attr; f.rider.SetAttr(TextModels.NewColor(f.rider.attr, Ports.red));
						END;
						f.WriteString(es.dates[i]); f.WriteTab;
						f.WriteString(es.ids[i]);
						IF i = j THEN
							f.rider.SetAttr(a);
						END;
						f.WriteLn;
					END;
					f.WriteLn;
				END;
				B.AllCertifiers(identity.fields[0], cert);
				IF cert # NIL THEN
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:AllCertifiers");
					f.rider.SetAttr(a);
					f.WriteString(" ("); f.WriteInt(LEN(cert)); f.WriteString(")");
					f.WriteLn; f.WriteLn;
					FOR i := 0 TO LEN(cert) - 1 DO
						f.WriteString(cert[i]); f.WriteLn;
					END;
				END;
				Dialog.MapString("#Duniter0:Certifiers", title);
				Views.OpenAux(TextViews.dir.New(t), title);
			END;
		END PrintCertifiers;
	
	PROCEDURE PrintCertified*;
		
		VAR
			
			cert: B.StringArr;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			i, bnb, j: INTEGER;
			item: Dialog.String;
			title: Views.Title;
			a: TextModels.Attributes;
			es: ExpSort;
			p, q: B.Pubkey;
			b, bb, m: BOOLEAN;
			h: B.Hash;
			uid: BA.String;
			exp, app: LONGINT;
		
		BEGIN (*PrintCertified*)
			IF identity.fields[0] # "" THEN
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString(identity.fields[0]);
				f.WriteLn; f.WriteLn;
				IF sentCerts.len > 0 THEN
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:PresentCertified");
					f.rider.SetAttr(a);
					f.WriteString(" ("); f.WriteInt(sentCertsNb);
					f.WriteString(" + "); f.WriteInt(sentCertsFutNb); f.WriteString(")");
					f.WriteLn; f.WriteLn;
					NEW(es.ids, sentCerts.len);
					NEW(es.dates, sentCerts.len);
					NEW(es.exps, sentCerts.len);
					j := 0;
					FOR i := 0 TO sentCerts.len - 1 DO
						sentCerts.GetItem(i, item);
						f.WriteString(item); f.WriteLn;
						es.ids[j] := item;
						b := item[0] # futureIcon;
						FilterItem(item);
						IF b OR B.IdUid(identity.fields[0], p) & B.IdUid(item, q) & ~B.Cert(p, q, bnb, exp) OR S.IdHash(sentHash[i], bb, q, uid, exp) & ~bb THEN
							IF B.IdUidComplete(item, p, m, h, bnb, app, es.exps[j]) THEN
								IF ~m THEN
									es.ids[j] := oldIcon + item;
								END;
							ELSE
								b := S.IdHash(sentHash[i], bb, p, uid, es.exps[j]); ASSERT(b, 100);
							END;
							BA.TimestampToString(es.exps[j], es.dates[j]);
							INC(j);
						END;
					END;
					f.WriteLn;
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:SortedByMExpDates");
					f.rider.SetAttr(a);
					f.WriteLn; f.WriteLn;
					es.QuickSort(0, j - 1);
					FOR i := 0 TO j - 1 DO
						f.WriteString(es.dates[i]); f.WriteTab;
						f.WriteString(es.ids[i]);
						f.WriteLn;
					END;
					f.WriteLn;
					FOR i := 0 TO sentCerts.len - 1 DO
						sentCerts.GetItem(i, item);
						es.ids[i] := item;
						b := item[0] = futureIcon;
						FilterItem(item);
						GetCDate(identity.fields[0], item, sentHash[i], b, es.exps[i], es.dates[i]);
					END;
					f.WriteLn;
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:SortedByCExpDates");
					f.rider.SetAttr(a);
					f.WriteLn; f.WriteLn;
					es.QuickSort(0, sentCerts.len - 1);
					FOR i := 0 TO sentCerts.len - 1 DO
						f.WriteString(es.dates[i]); f.WriteTab;
						f.WriteString(es.ids[i]);
						f.WriteLn;
					END;
					f.WriteLn;
				END;
				B.AllCertified(identity.fields[0], cert);
				IF cert # NIL THEN
					a := f.rider.attr; f.rider.SetAttr(TextModels.NewWeight(f.rider.attr, Fonts.bold));
					f.WriteMsg("#Duniter0:AllCertified");
					f.rider.SetAttr(a);
					f.WriteString(" ("); f.WriteInt(LEN(cert)); f.WriteString(")");
					f.WriteLn; f.WriteLn;
					FOR i := 0 TO LEN(cert) - 1 DO
						f.WriteString(cert[i]); f.WriteLn;
					END;
				END;
				Dialog.MapString("#Duniter0:Certified", title);
				Views.OpenAux(TextViews.dir.New(t), title);
			END;
		END PrintCertified;
	
	PROCEDURE CopyReceivedGuard* (VAR par: Dialog.Par);
		
		BEGIN (*CopyReceivedGuard*)
			par.disabled := receivedCerts.len = 0;
		END CopyReceivedGuard;
	
	PROCEDURE CopySentGuard* (VAR par: Dialog.Par);
		
		BEGIN (*CopySentGuard*)
			par.disabled := sentCerts.len = 0;
		END CopySentGuard;
	
	PROCEDURE PrintCertGuard* (VAR par: Dialog.Par);
		
		BEGIN (*PrintCertGuard*)
			par.disabled := identity.fields[0] = "";
		END PrintCertGuard;
	
	PROCEDURE IdentityListNotifier* (op, from, to: INTEGER);
		
		BEGIN (*IdentityListNotifier*)
			IF (op = Dialog.changed) & (identityList.index >= 0) & (identityList.index < identityList.len) THEN
				identityList.GetItem(identityList.index, identity.fields[0]);
				FilterItem(identity.fields[0]);
				Fix;
			END;
		END IdentityListNotifier;
	
	PROCEDURE NonEditableNotifier* (n, op, from, to: INTEGER);
		
		BEGIN (*NonEditableNotifier*)
			IF op = Dialog.changed THEN
				ASSERT(n IN {0 .. nonEditableNb - 1}, 100);
				identity.fields[2 * n] := identity.fields[2 * n + 1];
			END;
		END NonEditableNotifier;
	
	PROCEDURE CertsNotifier* (n, op, from, to: INTEGER);
		
		VAR
			
			s: Dialog.String;
			exp: LONGINT;
			future: BOOLEAN;
		
		BEGIN (*CertsNotifier*)
			IF op = Dialog.changed THEN
				CASE n OF
					|3:
						IF receivedCerts.len > 0 THEN
							receivedCerts.GetItem(MIN(MAX(receivedCerts.index, 0), receivedCerts.len - 1), s);
							future := s[0] = futureIcon;
							FilterItem(s);
							GetCDate(s, identity.fields[0], receivedHash[receivedCerts.index], future, exp, identity.fields[2 * n]);
						ELSE
							identity.fields[2 * n] := ""
						END;
					|4:
						IF sentCerts.len > 0 THEN
							sentCerts.GetItem(MIN(MAX(sentCerts.index, 0), sentCerts.len - 1), s);
							future := s[0] = futureIcon;
							FilterItem(s);
							GetCDate(identity.fields[0], s, sentHash[sentCerts.index], future, exp, identity.fields[2 * n]);
						ELSE
							identity.fields[2 * n] := ""
						END;
				END;
				identity.fields[2 * n + 1] := identity.fields[2 * n];
				Dialog.Update(identity);
			END;
		END CertsNotifier;
	
	PROCEDURE NbNotifier* (op, from, to: INTEGER);
		
		BEGIN (*NbNotifier*)
			IF op = Dialog.changed THEN
				DoSearch;
			END;
		END NbNotifier;
	
	PROCEDURE Update (VAR changed: BOOLEAN);
		
		BEGIN (*Update*)
			IF changed & (identity.fields[0] # "") THEN
				hint.item := identity.fields[0];
				Search;
			END;
		END Update;
	
	BEGIN (*Duniter0IdentitySearch*)
		identity.calcDist := TRUE; identity.calcQual := FALSE; identity.calcCentr := FALSE;
		identityDispOld := FALSE; identityDispMem := TRUE; identityDispFut := TRUE;
		InitRing(ring);
		B.AddUpdateProc(Update)
	CLOSE
		B.RemoveUpdateProc(Update);
	END Duniter0IdentitySearch.
