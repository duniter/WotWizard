(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1CentralitiesStressD;
	
	(* Calculate the stress centrality with Ulrik Brandes' algorithm, slightly modified to deal with the fact that only paths between members have to be considered, and limited to B.pars.stepMax distance *)
	
	

	IMPORT
		
		(*
		L := StdLog,
		*)
		
		BA := Duniter1Basic, B := Duniter1Blockchain, N := UtilNetStressD, Math, TextMappers, TextModels, TextViews, J := UtilJson, UtilSort;
	
	TYPE
		
		Action = POINTER TO RECORD (B.Action)
			output: BA.String;
		END;
		
		UpdateA = POINTER TO RECORD (B.Action)
		END;
		
		Net = POINTER TO RECORD (N.Net)
		END;
		
		Node = POINTER TO RECORD (N.Node)
			p: B.Pubkey;
			pos: B.CertPos;
		END;
		
		One = RECORD
			p: B.Pubkey;
			c: REAL;
		END;
		
		Ones = POINTER TO ARRAY OF One;
		
		OnesSort = RECORD (UtilSort.T)
			ones: Ones;
		END;
	
		Central = POINTER TO RECORD
			id: B.String;
			c: REAL;
		END;
		
		Centrals = POINTER TO ARRAY OF Central;
		
		CentralSort = EXTENSIBLE RECORD (UtilSort.T)
			c: Centrals;
		END;
		
		CentralSortId = RECORD (CentralSort)
		END;
	
	VAR
		
		net: Net;
		allOnes: OnesSort;
		
		mustUpdate: BOOLEAN;
	
	PROCEDURE (VAR s: OnesSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			o: One;
		
		BEGIN (*Swap*)
			o := s.ones[p1]; s.ones[p1] := s.ones[p2]; s.ones[p2] := o;
		END Swap;
	
	PROCEDURE (VAR s: OnesSort) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN s.ones[p1].p < s.ones[p2].p;
		END Less;
	
	PROCEDURE (VAR s: CentralSort) Swap (p1, p2: INTEGER);
		
		VAR
			
			c: Central;
		
		BEGIN (*Swap*)
			c := s.c[p1]; s.c[p1] := s.c[p2]; s.c[p2] := c;
		END Swap;
	
	PROCEDURE (VAR s: CentralSort) Less (p1, p2: INTEGER): BOOLEAN, EXTENSIBLE;
		
		BEGIN (*Less*)
			RETURN (s.c[p1].c > s.c[p2].c) OR (s.c[p1].c = s.c[p2].c) & (BA.CompP(s.c[p1].id, s.c[p2].id) = BA.lt);
		END Less;
	
	PROCEDURE (VAR s: CentralSortId) Less (p1, p2: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN BA.CompP(s.c[p1].id, s.c[p2].id) = BA.lt;
		END Less;
	
	PROCEDURE NewNode (IN p: B.Pubkey): Node;
		
		VAR
			
			n: Node;
		
		BEGIN (*NewNode*)
			NEW(n);
			n.p := p;
			RETURN n;
		END NewNode;
	
	PROCEDURE (net: Net) Number (): INTEGER; 
		
		BEGIN (*Number*)
			RETURN B.IdLen();
		END Number;
	
	PROCEDURE (net: Net) Enumerate (first: BOOLEAN; OUT node: N.Node; OUT member: BOOLEAN): BOOLEAN;
		
		VAR
			
			p: B.Pubkey;
			id: B.String;
			b: BOOLEAN;
			h: B.Hash;
			bnb: INTEGER;
			exp, app: LONGINT;
		
		BEGIN (*Enumerate*)
			IF B.IdNextUid(first, id) THEN
				b := B.IdUidComplete(id, p, member, h, bnb, app, exp); ASSERT(b, 100);
				node := NewNode(p);
				RETURN TRUE;
			END;
			RETURN FALSE;
		END Enumerate;
	
	PROCEDURE (n1: Node) Compare (n2: N.Node): BYTE;
		
		BEGIN (*Compare*)
			WITH n2: Node DO
				IF n1.p < n2.p THEN
					RETURN BA.lt;
				END;
				IF n1.p > n2.p THEN
					RETURN BA.gt;
				END;
				RETURN BA.eq;
			END;
		END Compare;

	PROCEDURE (n: Node) FromTo (first: BOOLEAN; OUT follow: N.Node): BOOLEAN;
		
		VAR
			
			b: BOOLEAN;
			from, to: B.Pubkey;
		
		BEGIN (*FromTo*)
			(* Counterintuitive : the result doesn't depend on the direction of arrows *)
			IF first THEN
				b := B.CertFrom(n.p, n.pos);
			END;
			IF ~n.pos.CertNextPos(from, to) THEN
				RETURN FALSE;
			END;
			follow := NewNode(to);
			RETURN TRUE;
		END FromTo;
	
	PROCEDURE DoCount (OUT centers, centersId: Centrals);
		
		VAR
			
			i, len: INTEGER;
			b: BOOLEAN;
			c: Central;
			s: CentralSort;
			sId: CentralSortId;
		
		BEGIN (*DoCount*)
			IF allOnes.ones = NIL THEN
				len := 0;
			ELSE
				len := LEN(allOnes.ones) - 1;
			END;
			IF len = 0 THEN
				centers := NIL;
				centersId := NIL;
			ELSE
				NEW(centers, len);
				NEW(centersId, len);
				FOR i := 0 TO len - 1 DO
					NEW(c);
					b := B.IdPub(allOnes.ones[i].p, c.id); ASSERT(b, 100);
					c.c := allOnes.ones[i].c;
					centers[i] := c;
					centersId[i] := c;
				END;
				s.c := centers;
				s.QuickSort(0, len - 1);
				sId.c := centersId;
				sId.QuickSort(0, len - 1);
			END;
		END DoCount;
	
	PROCEDURE List (): J.Json;
		
		VAR
			
			centers, centersId: Centrals;
			i: INTEGER;
			mt: LONGINT;
		
		BEGIN (*List*)
			DoCount(centers, centersId);
			J.StartObject;
			J.StartArray;
			IF centers # NIL THEN
				FOR i := 0 TO LEN(centers) - 1 DO
					J.StartObject;
					J.PushString(centers[i].id);
					J.BuildField("id");
					J.PushReal(centers[i].c);
					J.BuildField("c");
					J.BuildObject;
				END;
			END;
			J.BuildArray;
			J.BuildField("centrals");
			J.StartArray;
			IF centersId # NIL THEN
				FOR i := 0 TO LEN(centersId) - 1 DO
					J.StartObject;
					J.PushString(centersId[i].id);
					J.BuildField("id");
					J.PushReal(centersId[i].c);
					J.BuildField("c");
					J.BuildObject;
				END;
			END;
			J.BuildArray;
			J.BuildField("centrals_byId");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			mt := B.Now();
			J.PushInteger(mt);
			J.BuildField("now");
			J.BuildObject;
			RETURN J.GetJson();
		END List;
	
	PROCEDURE Json (j: J.Json; IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Json*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			j.Write(f);
			BA.VRegister(TextViews.dir.New(t), BA.waitLoc, name$, 100, "CentralitiesStressD.Json");
		END Json;
	
	PROCEDURE (a: Action) Activate;
		
		BEGIN (*Activate*)
			Json(List(), a.output);
		END Activate;
	
	PROCEDURE Count* (IN output: ARRAY OF CHAR);
		
		VAR
			
			u: UpdateA;
			a: Action;
		
		BEGIN (*Count*)
			IF mustUpdate THEN
				NEW(u);
				B.AddAction(u);
			END;
			NEW(a);
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END Count;
	
	PROCEDURE CountAllOnes;
		
		VAR
			
			i, len: INTEGER;
			ok: BOOLEAN;
			cV: LONGINT;
			cT: N.Centrals;
			node: N.Node;
			max: REAL;
		
		BEGIN (*CountAllOnes*)
			cT := net.Centralities(B.pars.stepMax);
			len := net.nbNodes;
			max := 0.;
			NEW(allOnes.ones, len + 1);
			i := 0;
			ok := cT.Walk(TRUE, node, cV);
			WHILE ok DO
				WITH node: Node DO
					allOnes.ones[i].p := node.p;
					allOnes.ones[i].c := Math.Ln(1 + cV);
					max := MAX(max, allOnes.ones[i].c);
					INC(i);
				END;
				ok := cT.Walk(FALSE, node, cV);
			END;
			ASSERT(i = len, 60);
			FOR i := 0 TO len - 1 DO
				allOnes.ones[i] .c := allOnes.ones[i].c / max;
			END;
			allOnes.QuickSort(0, len - 1);
		END CountAllOnes;
	
	PROCEDURE Update;
		
		BEGIN (*Update*)
			net.Update;
			CountAllOnes;
			mustUpdate := FALSE;
		END Update;
	
	PROCEDURE (u: UpdateA) Activate;
		
		BEGIN (*Activate*)
			Update;
		END Activate;
	
	PROCEDURE CountOne* (p: B.Pubkey): REAL;
		
		VAR
			
			len: INTEGER;
			res: REAL;
		
		BEGIN (*CountOne*)
			IF mustUpdate THEN
				Update;
			END;
			IF allOnes.ones = NIL THEN
				res := 0.;
			ELSE
				len := LEN(allOnes.ones) - 1;
				IF len = 0 THEN
					res := 0.;
				ELSE
					allOnes.ones[len].p := p;
					allOnes.BinSearch(0, len - 1, len);
					ASSERT(len < LEN(allOnes.ones) - 1, 100);
					res := allOnes.ones[len].c;
				END;
			END;
			RETURN res;
		END CountOne;
	
	PROCEDURE RecordUpdate;
		
		BEGIN (*RecordUpdate*)
			mustUpdate := TRUE;
		END RecordUpdate;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			NEW(net);
			B.AddUpdateProc(RecordUpdate);
			mustUpdate := TRUE;
		END Init;
	
	BEGIN (*Duniter1CentralitiesStressD*)
		Init;
	CLOSE
		B.RemoveUpdateProc(RecordUpdate);
	END Duniter1CentralitiesStressD.
