(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1BlockchainUpdt;
	
	
	
	IMPORT
		
		(**
		L := StdLog,
		**)
		
		B := UtilBBTree2, BA := Duniter1BasicUpdt, Files, Services, S := SqlDB, Strings, TextMappers, TextModels, TextViews, J := UtilJson, UtilLog, UtilMutex, Views;
	
	CONST
		
		(* Driver SQLite *)
		driver* = "SQLiteDriver";
		
		syncName = "updating.txt";
		syncDelay = 15 * Services.resolution; (* ms *)
		verifyPeriod = 2 * Services.resolution; (* ms; Minimum delay between two verifications of the presence of syncName *)
		secureDelay = 2 * Services.resolution; (* ms *)
		addDelay = 5 * Services.resolution; (* ms *)
		
		(* Number of pages used by UtilBTree *)
		pageNb = 2000;
		
		(* Max length of a Pubkey *)
		pubkeyLen = 44;
		
		(* Max length of a Hash *)
		hashLen = 64;
		
		(* Number of last blocks to be read again at every update, since they could have changed *)
		secureGap = 100;
		
		(* Directory of the Parameters json file, in the WotWizard directory *)
		dDir* = "Duniter1";
		(* Name of the Parameters json file *)
		dPars = "DPars.json";
		(* Path of the WotWizard database, in the WotWizard.exe directory *)
		dBase = "Duniter1\DBase.data";
		dSyncName = "updated.txt";
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0; (* Index timeT *)
		joinAndLeavePlace = 1; (* Index joinAndLeaveT *)
		idPubPlace = 2; (* Index idPubT *)
		idUidPlace = 3; (* Index idUidT *)
		idHashPlace = 4; (* Index idHashT *)
		idTimePlace = 5; (* Index idTimeT *)
		certFromPlace = 6; (* Index certFromT *)
		certToPlace = 7; (* Index certToT *)
		certTimePlace = 8; (* Index certTimeT *)
		undoListPlace = 9; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 10; (* Last read block *)
		idLenPlace = 11; (* Number of actual members *)
		
		placeNb = 12; (* Number of places *)
	
	TYPE
		
		MutexData = POINTER TO RECORD
			t0, t1: LONGINT;
		END;
		
		(* Procedure called at every update *)
		UpdateProc = PROCEDURE;
		
		(* Chained list of procedures called at every update *)
		UpdateList = POINTER TO RECORD
			next: UpdateList;
			update: UpdateProc;
		END;
		
		(* Action for updating DBase.data *)
		UpdateAction = POINTER TO RECORD (Services.Action)
		END;
		
		String* = BA.String;
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		Hash* = ARRAY hashLen + 1 OF CHAR;
		
		(* Duniter Parameters *)
		Parameters* = POINTER TO RECORD
			
			(* The %growth of the UD every [dtReeval] period = 0.0488 /  (6 months) = 4.88% / (6 months) *)
			c-: REAL;
			
			(* Time period between two UD = 86400 s = 1 day *)
			dt-,
			
			(* UD(0), i.e. initial Universal Dividend = 1000 cents = 10 Ğ1 *)
			ud0-,
			
			(* Minimum delay between 2 certifications of a same issuer = 432000 s = 5 days *)
			sigPeriod-,
			
			(* Maximum quantity of active certifications made by member = 100 *)
			sigStock-,
			
			(* Maximum delay a certification can wait before being expired for non-writing = 5259600 s = 2 months *)
			sigWindow-,
			
			(* Maximum age of an active certification = 63115200 s = 2 years *)
			sigValidity-,
			
			(* Minimum delay before replaying a certification = 5259600 s = 2 months *)
			sigReplay-,
			
			(* Minimum quantity of signatures to be part of the WoT = 5 *)
			sigQty-,
			
			(* Maximum delay an identity can wait before being expired for non-writing = 5259600 s = 2 months *)
			idtyWindow-,
			
			(* Maximum delay a membership can wait before being expired for non-writing = 5259600 s = 2 months *)
			msWindow-,
			
			(* Minimum delay between 2 memberships of a same issuer = 5259600 s = 2 months *)
			msPeriod-: INTEGER;
			
			(* Minimum percent of sentries to reach to match the distance rule = 0.8 = 80% *)
			xpercent-: REAL;
			
			(* Maximum age of an active membership = 31557600 s = 1 year *)
			msValidity-,
			
			(* Maximum distance between a newcomer and [xpercent] of sentries = 5 *)
			stepMax-,
			
			(* Number of blocks used for calculating median time = 24 *)
			medianTimeBlocks-,
			
			(* The average time for writing 1 block (wished time) = 300 s = 5 min *)
			avgGenTime-,
			
			(* The number of blocks required to evaluate again PoWMin value = 12 *)
			dtDiffEval-: INTEGER;
			
			(* The percent of previous issuers to reach for personalized difficulty = 0.67 = 67% *)
			percentRot-: REAL;
			
			(* Time of first UD = 1488970800 s = 2017/03/08 11:00:00 UTC+0 *)
			udTime0-,
			
			(* Time of first reevaluation of the UD = 1490094000 s = 2017/03/21 11:00:00 UTC+0 *)
			udReevalTime0-: LONGINT;
			
			(* Time period between two re-evaluation of the UD = 15778800 s = 6 months *)
			dtReeval-,
			
			(* Maximum delay a transaction can wait before being expired for non-writing = 604800 s = 7 days *)
			txWindow-: INTEGER;
			
		END;
	
	CONST
		
		mutexOwner = FALSE;
		
		(* Types of elements in UndoList *)
		timeList = 0;
		idAddList = 1;
		joinList = 2;
		activeList = 3;
		leaveList = 4;
		idAddTimeList = 5;
		idRemoveTimeList = 6;
		certAddList = 7;
		certRemoveList = 8;
		remCertifiers = 9;
		remCertified = 10;
		
		hasNotLeaved = -1;
	
	TYPE
		
		(* Chained list of the operations to be undone before every update *)
		UndoList = POINTER TO RECORD (B.Data)
			next: B.FilePos;
			type: BYTE;
			(* timeList -> Time; joinList, activeList, leaveList -> Identity; certAddList, certRemoveList -> Certification, etc... *)
			ref,
			aux,
			aux2: LONGINT;
		END;
		
		(* Factory of UndoList *)
		UndoListFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			bnb: INTEGER;
			mTime,
			time: LONGINT;
		END;
		
		(* Factory of Time *)
		TimeFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeaveL = POINTER TO RECORD (B.Data)
			next: B.FilePos;
			joiningBlock, (* Block numbers *)
			leavingBlock: INTEGER;
		END;
		
		(* Factory of JoinAndLeaveL *)
		JoinAndLeaveLFac = POINTER TO RECORD (B.DataFac)
		END;
		
		JoinAndLeave = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			list: B.FilePos; (* JoinAndLeaveL *)
		END;
		
		(* Factory of JoinAndLeave *)
		JoinAndLeaveFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Identity = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			uid: String;
			member: BOOLEAN;
			hash: Hash;
			block_number: INTEGER; (* Where the Identity is written *)
			application, (* Date of last membership application (joiners, actives, leavers) *)
			expires_on: LONGINT;
			certifiers, (* Index of all certifiers uid, old or present, of this Identity ; B.String -> nothing *)
			certified: B.FilePos; (* Index of all uid, old or present, certified by this Identity ; B.String -> nothing *)
		END;
		
		(* Factory of Identity *)
		IdentityFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Certification = POINTER TO RECORD (B.Data)
			from,
			to: Pubkey;
			block_number: INTEGER; (* Where the Certification is written *)
			expires_on: LONGINT;
		END;
		
		(* Factory of Certification *)
		CertificationFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* INTEGER index key *)
		IntKey = POINTER TO RECORD (B.Data)
			ref: INTEGER;
		END;
		
		(* Factory of IntKey *)
		IntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of IntKey *)
		IntKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* LONGINT index key *)
		LIntKey = POINTER TO RECORD (B.Data)
			ref: LONGINT;
		END;
		
		(* Factory of LIntKey *)
		LIntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data) (* # Pubkey! *)
			ref: Pubkey;
		END;
		
		(* Factory of PubKey *)
		PubKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of PubKey *)
		PubKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Hashkey index key *)
		HashKey = POINTER TO RECORD (B.Data)
			ref: Hash;
		END;
		
		(* Factory of HashKey *)
		HashKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of HashKey *)
		HashKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Uid index key manager *)
		UidKeyMan = POINTER TO RECORD (B.StringKeyManager) 
		END;
		
		(* Manager of Identity sorted by expiration dates *)
		IdKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Manager of Certification sorted by expiration dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
	
	CONST
		
		(* Sizes of B.Data *)
		pubKeyS = (pubkeyLen + 1) * B.CHS;
		
		(* Sizes of keys *)
		timeKeyS = B.INS;
		idTimeKeyS = B.LIS;
		certTimeKeyS = B.LIS;
	
	VAR
		
		lg: UtilLog.Log;
		mutex: UtilMutex.Mutex;
		
		duniLoc,
		dLoc: Files.Locator;
		
		updateList: UpdateList; (* Head of general UpdateList *)
		update: UpdateAction;
		
		doScan1: BOOLEAN;
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		joinAndLeaveT, (* PubKey -> JoinAndLeave *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		idHashT, (* HashKey -> Identity *)
		idTimeT, (* LIntKey -> nothing; addresses of Identity sorted by expiration dates *)
		certFromT, certToT, (* PubKey -> sub-index(PubKey -> Certification) *)
		certTimeT: B.Index; (* LIntKey -> nothing; addresses of Certification sorted by expiration dates *)
		
		undoList: B.FilePos; (* Head of UndoList *)
		
		lastBlock: INTEGER; (* Last written block *)
		now: LONGINT; (* Present medianTime and time *)
		idLenM: INTEGER; (* Number of members *)
		
		(* Factories *)
		undoListFac: UndoListFac;
		timeFac: TimeFac;
		joinAndLeaveLFac: JoinAndLeaveLFac;
		joinAndLeaveFac: JoinAndLeaveFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		lIntKeyFac: LIntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		hashKeyFac: HashKeyFac;
		
		(* Data managers *)
		timeMan,
		joinAndLeaveLMan,
		joinAndLeaveMan,
		idMan,
		certMan,
		undoListMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: UidKeyMan;
		hashKeyMan: HashKeyMan;
		intKeyMan: IntKeyMan;
		idKTimeMan: IdKTimeMan;
		certKTimeMan: CertKTimeMan;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
			t.time := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
			w.OutLInt(t.time);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (jlL: JoinAndLeaveL) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jlL.next := r.InLInt();
			jlL.joiningBlock := r.InInt();
			jlL.leavingBlock := r.InInt();
		END Read;
	
	PROCEDURE (jlL: JoinAndLeaveL) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutLInt(jlL.next);
			w.OutInt(jlL.joiningBlock);
			w.OutInt(jlL.leavingBlock);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveLFac) New (size: INTEGER): JoinAndLeaveL;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*New*)
			NEW(jlL);
			RETURN jlL;
		END New;
	
	PROCEDURE (jl: JoinAndLeave) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(jl.pubkey);
			jl.list := r.InLInt();
		END Read;
	
	PROCEDURE (jl: JoinAndLeave) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(jl.pubkey);
			w.OutLInt(jl.list);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveFac) New (size: INTEGER): JoinAndLeave;
		
		VAR
			
			jl: JoinAndLeave;
		
		BEGIN (*New*)
			NEW(jl);
			RETURN jl;
		END New;
	
	PROCEDURE (id: Identity) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(id.pubkey);
			NEW(id.uid, r.InCharsLen() + 1); r.InChars(id.uid);
			id.member := r.InBool();
			r.InChars(id.hash);
			id.block_number := r.InInt();
			id.application := r.InLInt();
			id.expires_on := r.InLInt();
			id.certifiers := r.InLInt();
			id.certified := r.InLInt();
		END Read;
	
	PROCEDURE (id: Identity) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(id.pubkey);
			w.OutChars(id.uid);
			w.OutBool(id.member);
			w.OutChars(id.hash);
			w.OutInt(id.block_number);
			w.OutLInt(id.application);
			w.OutLInt(id.expires_on);
			w.OutLInt(id.certifiers);
			w.OutLInt(id.certified);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (l: UndoList) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.next := r.InLInt();
			l.type := r.InByte();
			l.ref := r.InLInt();
			l.aux := r.InLInt();
			l.aux2 := r.InLInt();
		END Read;
	
	PROCEDURE (l: UndoList) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutLInt(l.next);
			w.OutByte(l.type);
			w.OutLInt(l.ref);
			w.OutLInt(l.aux);
			w.OutLInt(l.aux2);
		END Write;
	
	PROCEDURE (lf: UndoListFac) New (size: INTEGER): UndoList;
		
		VAR
			
			l: UndoList;
		
		BEGIN (*New*)
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.INS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (l: LIntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.ref := r.InLInt();
		END Read;
	
	PROCEDURE (l: LIntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutLInt(l.ref);
		END Write;
	
	PROCEDURE (lf: LIntKeyFac) New (size: INTEGER): LIntKey;
		
		VAR
			
			l: LIntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.LIS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (pf: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	PROCEDURE (hash: HashKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(hash.ref);
		END Read;
	
	PROCEDURE (hash: HashKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(hash.ref);
		END Write;
	
	PROCEDURE (hf: HashKeyFac) New (size: INTEGER): HashKey;
		
		VAR
			
			hash: HashKey;
		
		BEGIN (*New*)
			NEW(hash);
			IF size = 0 THEN
				hash.ref := "";
			END;
			RETURN hash;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			ASSERT(PKMCompP(p1, p2) = B.lt, 21);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	PROCEDURE HKMCompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*HKMCompP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					IF h1.ref < h2.ref THEN
						RETURN B.lt;
					END;
					IF h1.ref > h2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END HKMCompP;
	
	PROCEDURE (hm: HashKeyMan) CompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN HKMCompP(h1, h2);
		END CompP;
	
	PROCEDURE (hm: HashKeyMan) PrefP (h1: B.Data; VAR h2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			h: HashKey;
		
		BEGIN (*PrefP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			ASSERT(HKMCompP(h1, h2) = B.lt, 21);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					l2 := LEN(h2.ref$);
					NEW(h);
					l := 0;
					h.ref[l] := 0X;
					WHILE (l <= l2) & ~((HKMCompP(h1, h) = B.lt) & (HKMCompP(h, h2) <= B.eq)) DO
						h.ref[l] := h2.ref[l];
						INC(l);
						h.ref[l] := 0X;
					END;
				END;
			END;
			h2 := h;
		END PrefP;
	
	(* Comparison method of two Strings. Use the lexical order. *)
	PROCEDURE (um: UidKeyMan) CompP (key1, key2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			ASSERT((key1 # NIL) & (key2 # NIL), 20);
			WITH key1: B.String DO
				WITH key2: B.String DO
					IF key1.c = NIL THEN
						IF key2.c = NIL THEN
							RETURN B.eq;
						END;
						RETURN B.lt;
					END;
					IF key2.c = NIL THEN
						RETURN B.gt;
					END;
					RETURN BA.CompP(key1.c, key2.c);
				END;
			END;
		END CompP;
	
	(* Comparison of Identity(s) by expiration dates *)
	PROCEDURE (im: IdKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			id1, id2: Identity;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				id1 := idMan.ReadData(l1.ref)(Identity);
			END;
			WITH l2: LIntKey DO
				id2 := idMan.ReadData(l2.ref)(Identity);
			END;
			IF ABS(id1.expires_on) < ABS(id2.expires_on) THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired identities *)
			END;
			IF ABS(id1.expires_on) > ABS(id2.expires_on) THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ < id2.pubkey$ THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ > id2.pubkey$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* Comparison of Certification(s) by expiration dates *)
	PROCEDURE (im: CertKTimeMan) CompP (l1, l2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH l1: LIntKey DO
				c1 := certMan.ReadData(l1.ref)(Certification);
			END;
			WITH l2: LIntKey DO
				c2 := certMan.ReadData(l2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired certifications *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* Last written block *)
	PROCEDURE LastBlock* (): INTEGER;
		
		BEGIN (*LastBlock*)
			RETURN lastBlock;
		END LastBlock;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b, 100);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL, 101);
					database.WritePlace(timePlace, database.CreateIndex(timeKeyS));
					database.WritePlace(joinAndLeavePlace, database.CreateIndex(0));
					database.WritePlace(idPubPlace, database.CreateIndex(0));
					database.WritePlace(idUidPlace, database.CreateIndex(0));
					database.WritePlace(idHashPlace, database.CreateIndex(0));
					database.WritePlace(idTimePlace, database.CreateIndex(idTimeKeyS));
					database.WritePlace(certFromPlace, database.CreateIndex(0));
					database.WritePlace(certToPlace, database.CreateIndex(0));
					database.WritePlace(certTimePlace, database.CreateIndex(certTimeKeyS));
					database.WritePlace(undoListPlace, B.bNil);
					database.WritePlace(lastNPlace, - 1);
					database.WritePlace(idLenPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				joinAndLeaveLMan := database.CreateDataMan(joinAndLeaveLFac);
				joinAndLeaveMan := database.CreateDataMan(joinAndLeaveFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				undoListMan := database.CreateDataMan(undoListFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				joinAndLeaveT := database.OpenIndex(database.ReadPlace(joinAndLeavePlace), pubKeyMan, pubKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				idHashT := database.OpenIndex(database.ReadPlace(idHashPlace), hashKeyMan, hashKeyFac);
				idTimeT := database.OpenIndex(database.ReadPlace(idTimePlace), idKTimeMan, lIntKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
				certTimeT := database.OpenIndex(database.ReadPlace(certTimePlace), certKTimeMan, lIntKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf (bnb: INTEGER; OUT mTime: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> uid *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPub*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPubComplete* (IN pubkey: Pubkey; OUT uid: String; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT application, expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPubComplete*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				application := id.application;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubComplete;
	
	(* uid -> Pubkey *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* Hash -> pubkey *)
	PROCEDURE IdHash* (IN hash: Hash; OUT pub: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idH: HashKey;
		
		BEGIN (*IdHash*)
			NEW(idH);
			idH.ref := hash;
			IF idHashT.Search(idH) THEN
				id := idMan.ReadData(idHashT.ReadValue())(Identity);
				pub := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdHash;
	
	(* (Pubkey, Pubkey) -> Certification *)
PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Scan the string s from position i to the position of stop excluded; update i and return the scanned string in sub *)
	PROCEDURE ScanS (IN s: ARRAY OF CHAR; stop: CHAR; OUT sub: ARRAY OF CHAR; VAR i: INTEGER);
		
		VAR
			
			j: INTEGER;
		
		BEGIN (*ScanS*)
			j := 0;
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				sub[j] := s[i];
				INC(i); INC(j);
			END;
			sub[j] := 0X;
			INC(i);
		END ScanS;
	
	(* Skip the string s from position i to the position of stop excluded; update i *)
	PROCEDURE SkipS (IN s: ARRAY OF CHAR; stop: CHAR; VAR i: INTEGER);
		
		BEGIN (*SkipS*)
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				INC(i);
			END;
			INC(i);
		END SkipS;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params (d: S.Database);
		
		CONST
			
			txWindow = 60 * 60 * 24 * 7;
		
		VAR
			
			res: INTEGER;
			cur: S.Row;
			ss: POINTER TO ARRAY OF CHAR;
			s: ARRAY 20 OF CHAR;
			t: S.Table;
			i: INTEGER;
		
		BEGIN (*Params*)
			NEW(pars);
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT parameters FROM block WHERE number = 0 AND NOT fork");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT(t.columns = 1, 102); ASSERT(t.rows = 1, 103);
			 t.Read(0, cur);
			ss := cur.fields[0];
			ss[LEN(ss$)] := ':';
			i := 0;
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.c, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dt, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.ud0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigPeriod, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigStock, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigQty, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.idtyWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.xpercent, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.stepMax, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.medianTimeBlocks, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.avgGenTime, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtDiffEval, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.percentRot, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udReevalTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtReeval, res); ASSERT(res = 0, 104);
			pars.txWindow := txWindow;
			pars.msPeriod := pars.msWindow;
			pars.sigReplay := pars.msPeriod;
		END Params;
	
	(* Add a block in timeT *)
	PROCEDURE Times (withList: BOOLEAN; IN s1, s2, s3: ARRAY OF CHAR);
		
		VAR
			
			t: Time;
			i: IntKey;
			res: INTEGER;
			tRef: B.FilePos;
			b: BOOLEAN;
			tL: UndoList; (* timeList *)
		
		BEGIN (*Times*)
			NEW(t);
			Strings.StringToInt(s1, t.bnb, res); ASSERT(res = 0, 100);
			Strings.StringToLInt(s2, t.mTime, res); ASSERT(res = 0, 101);
			Strings.StringToLInt(s3, t.time, res); ASSERT(res = 0, 102);
			tRef := timeMan.WriteAllocateData(t);
			NEW(i); i.ref := t.bnb;
			b := timeT.SearchIns(i); ASSERT(~b, 103);
			timeT.WriteValue(tRef);
			IF withList THEN
				NEW(tL); tL.next := undoList; tL.type := timeList; tL.ref := tRef; tL.aux := 0;
				undoList := undoListMan.WriteAllocateData(tL);
			END;
			now := t.mTime;
		END Times;
	
	PROCEDURE RemoveCertifiersCertified (withList: BOOLEAN; idRef: B.FilePos; id: Identity);
		
		VAR
			
			c1, c2: B.Index;
			idU1, idU2: B.String;
			id2Ref: B.FilePos;
			id2: Identity;
			b: BOOLEAN;
			rL: UndoList; (*remCertifiers & remCertified *)
		
		BEGIN (*RemoveCertifiersCertified*)
			NEW(idU1); idU1.c := id.uid;
			
			IF id.certifiers # B.bNil THEN
				c1 := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
				c1.Next;
				WHILE c1.PosSet() DO
					idU2 := c1.CurrentKey()(B.String);
					b := idUidT.Search(idU2); ASSERT(b, 100);
					id2Ref := idUidT.ReadValue();
					id2 := idMan.ReadData(id2Ref)(Identity);
					ASSERT(id2.certified # B.bNil, 101);
					c2 := database.OpenIndex(id2.certified, uidKeyMan, uidKeyFac);
					b := c2.Erase(idU1); ASSERT(b, 102);
					b := c2.IsEmpty();
					c2.Close;
					IF b THEN
						database.DeleteIndex(id2.certified); id2.certified := B.bNil;
						idMan.WriteData(id2Ref, id2);
					END;
					IF withList THEN
						NEW(rL); rL.next := undoList; rL.type := remCertified; rL.ref := id2Ref; rL.aux := idRef;
						undoList := undoListMan.WriteAllocateData(rL);
					END;
					c1.Next;
				END;
				c1.Close;
			END;
			
			IF id.certified # B.bNil THEN
				c1 := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
				c1.Next;
				WHILE c1.PosSet() DO
					idU2 := c1.CurrentKey()(B.String);
					b := idUidT.Search(idU2); ASSERT(b, 103);
					id2Ref := idUidT.ReadValue();
					id2 := idMan.ReadData(id2Ref)(Identity);
					ASSERT(id2.certifiers # B.bNil, 104);
					c2 := database.OpenIndex(id2.certifiers, uidKeyMan, uidKeyFac);
					b := c2.Erase(idU1); ASSERT(b, 105);
					b := c2.IsEmpty();
					c2.Close;
					IF b THEN
						database.DeleteIndex(id2.certifiers); id2.certifiers := B.bNil;
						idMan.WriteData(id2Ref, id2);
					END;
					IF withList THEN
						NEW(rL); rL.next := undoList; rL.type := remCertifiers; rL.ref := id2Ref; rL.aux := idRef;
						undoList := undoListMan.WriteAllocateData(rL);
					END;
					c1.Next;
				END;
				c1.Close;
			END;
		END RemoveCertifiersCertified;
	
	PROCEDURE RevokeId (withList: BOOLEAN; IN p: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
			idRef: B.FilePos;
			id: Identity;
			idL: UndoList; (* leaversList *)
		
		BEGIN (*RevokeId*)
			NEW(idP); idP.ref := p;
			b := idPubT.Search(idP); ASSERT(b, 100);
			idRef := idPubT.ReadValue();
			id := idMan.ReadData(idRef)(Identity);
			IF withList THEN
				NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
				undoList := undoListMan.WriteAllocateData(idL);
			END;
			id.expires_on := BA.revoked;
			RemoveCertifiersCertified(withList, idRef, id);
			idMan.WriteData(idRef, id);
		END RevokeId;
	
	(*
	- Le membre demande à partir ; il passe par les champs leavers et excluded ; ses éléments d'identité (uid et clé publique) peuvent être réutilisés par lui-même mais pas par d'autres; il ne peut plus recevoir de certification.
	- Le membre révoque son identité explicitement ; champs revoked et excluded ; ses éléments d'identité sont bloqués à jamais.
	- Le membre ne renouvelle pas son appartenance dans les temps (ou perd ses sigQty certifications ???) ; champ excluded uniquement ; au bout d'un an, ses éléments d'identité sont bloqués à jamais (mais il n'apparaît dans aucun champ supplémentaire).
	*)
	(*
	La perte de certif ne provoque pas la révocation implicite. C’est bien le défaut de renouvellement qui provoque la révocation, les 2 mécanismes sont indépendants de ce point de vue.
Si les certifications reviennent, ça rend simplement l’adhésion possible à nouveau. C’est bien elle qui gère le cycle de vie du membre, les certifications ne sont qu’un prérequis.
Ainsi un membre qui n’a plus que 4 certifs est non seulement exclu mais ne peut pas se renouveler. Au moment de la perte le membre est exclu, puis si le membre ne se renouvelle pas au moment des 1 an de délai depuis sa dernière adhésion il ne se passe rien (on ne peut pas exclure un membre déjà exclu), puis au bout de 2 ans c’est la révocation implicite.
Faut vraiment voir l’adhésion comme le fil conducteur, et les certifications comme un moyen de prolonger ce fil.
.Ce qui se passe en BDD, 2 choses :
    - Etape 1 (bloc n) : la certification expire, si le membre a moins de 5 certifications valides restants celui-ci est marqué comme “à exclure” (champ kick)
    -Etape 2 (bloc n+1) : le membre doit être inscrit dans le champ Excluded du bloc.
Si le membre retrouve ses cinq certifications, il doit se renouveler pour revenir. Revenir n’est jamais automatique.
	*)
	(* For one block, add joining & leaving identities in joinAndLeaveT and updade identities in idPubT and idUidT; update certFromT & certToT too *)
	PROCEDURE Identities (withList: BOOLEAN; IN ssJ, ssA, ssL, ssR, ssE, nb: ARRAY OF CHAR; t: S.Table);
		
		VAR
			
			i, n, res, bnb: INTEGER;
			idRef, jlRef: B.FilePos;
			s: ARRAY 101 OF CHAR;
			b: BOOLEAN;
			id, oldId: Identity;
			p: Pubkey;
			idP: PubKey;
			idU: B.String;
			idH: HashKey;
			idL: UndoList; (* joinList, activeList *)
			jl: JoinAndLeave;
			jlL: JoinAndLeaveL;
			cur: S.Row;
			iK: LIntKey;
		
		BEGIN (*Identities*)
			i := 1;
			WHILE ssJ[i] # ']' DO (* joiners : Insert id *)
				INC(i);
				INC(idLenM);
				NEW(id);
				id.member := TRUE;
				ScanS(ssJ, ':', id.pubkey, i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 100);
				b := TimeOf(n, id.application); ASSERT(b, 101);
				id.expires_on := id.application + pars.msValidity;
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '"', s, i); NEW(id.uid, LEN(s$) + 1); id.uid^ := s$;
				IF ssJ[i] # ']' THEN
					INC(i);
				END;
				REPEAT
					t.Exec("SELECT hash FROM i_index WHERE pub = '" + id.pubkey + "' ORDER BY writtenOn ASC");
					ASSERT(t.res IN {0, 6}, 102);
				UNTIL t.res = 0;
				ASSERT((t.rows = 0) OR (t.columns = 1), 103);
				id.hash := "";
				FOR n := 0 TO t.rows - 1 DO
					t.Read(n, cur);
					IF (cur.fields[0] # NIL) & (cur.fields[0]$ # "") THEN
						id.hash := cur.fields[0]$;
					END;
				END;
				ASSERT(id.hash # "", 104);
				Strings.StringToInt(nb, id.block_number, res); ASSERT(res = 0, 105);
				bnb := id.block_number;
				NEW(idU); NEW(idU.c, LEN(id.uid$) + 1); idU.c^ := id.uid$;
				NEW(idP); idP.ref := id.pubkey;
				NEW(idH); idH.ref := id.hash;
				IF idPubT.SearchIns(idP) THEN
					idRef := idPubT.ReadValue();
					oldId := idMan.ReadData(idRef)(Identity);
					ASSERT(~oldId.member & (oldId.uid$ = id.uid$) & (oldId.hash = id.hash), 106);
					NEW(iK); iK.ref := idRef;
					b := idTimeT.Erase(iK);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
					id.block_number := oldId.block_number;
					id.certifiers := oldId.certifiers; id.certified := oldId.certified;
					idMan.WriteData(idRef, id);
					b := idUidT.SearchIns(idU); ASSERT(b, 107);
					ASSERT(idUidT.ReadValue() = idRef, 108);
					b := idHashT.SearchIns(idH); ASSERT(b, 109);
					ASSERT(idHashT.ReadValue() = idRef, 110);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := oldId.expires_on; idL.aux2 := oldId.application;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				ELSE
					id.certifiers := B.bNil; id.certified := B.bNil;
					idRef := idMan.WriteAllocateData(id);
					idPubT.WriteValue(idRef);
					b := idUidT.SearchIns(idU); ASSERT(~b, 111);
					idUidT.WriteValue(idRef);
					b := idHashT.SearchIns(idH); ASSERT(~b, 112);
					idHashT.WriteValue(idRef);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
				IF joinAndLeaveT.SearchIns(idP) THEN
					jlRef := joinAndLeaveT.ReadValue();
					jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				ELSE
					NEW(jl);
					jl.pubkey := id.pubkey;
					jl.list := B.bNil;
					jlRef := joinAndLeaveMan.AllocateData(jl);
					joinAndLeaveT.WriteValue(jlRef);
				END;
				NEW(jlL);
				jlL.next := jl .list;
				jlL.joiningBlock := bnb;
				jlL.leavingBlock := hasNotLeaved;
				jl.list := joinAndLeaveLMan.WriteAllocateData(jlL);
				joinAndLeaveMan.WriteData(jlRef, jl);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := joinList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
			END;
			
			i := 1;
			WHILE ssA[i] # ']' DO (* actives *)
				INC(i);
				NEW(idP);
				ScanS(ssA, ':', idP.ref, i);
				SkipS(ssA, ':', i);
				ScanS(ssA, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 113);
				SkipS(ssA, '"', i);
				IF ssA[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 114);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 115);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.application); ASSERT(b, 116);
				id.expires_on := id.application + pars.msValidity;
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssL[i] # ']' DO (* leavers *)
				INC(i);
				NEW(idP);
				ScanS(ssL, ':', idP.ref, i);
				SkipS(ssL, ':', i);
				ScanS(ssL, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 117);
				SkipS(ssL, '"', i);
				IF ssL[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 118);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.application); ASSERT(b, 119);
				id.expires_on := - ABS(id.expires_on); (* id.expires_on < 0 if leaving *)
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssR[i] # ']' DO (* revoked *)
				INC(i);
				ScanS(ssR, ':', p, i);
				SkipS(ssR, '"', i);
				IF ssR[i] # ']' THEN
					INC(i);
				END;
				NEW(idP); idP.ref := p;
				b := idPubT.Search(idP); ASSERT(b, 120);
				idRef := idPubT.ReadValue();
				NEW(iK); iK.ref := idRef;
				IF idTimeT.Erase(iK) & withList THEN
					NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				RevokeId(withList, p);
			END;
			
			i := 1;
			WHILE ssE[i] # ']' DO (* excluded *)
				INC(i);
				DEC(idLenM);
				NEW(idP);
				ScanS(ssE, '"', idP.ref, i);
				IF ssE[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 121);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 122);
				id.member := FALSE;
				idMan.WriteData(idRef, id);
				b := joinAndLeaveT.Search(idP); ASSERT(b, 123);
				jlRef := joinAndLeaveT.ReadValue();
				jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
				ASSERT(jlL.leavingBlock = hasNotLeaved, 124);
				Strings.StringToInt(nb, jlL.leavingBlock, res); ASSERT(res = 0, 125);
				joinAndLeaveMan.WriteData(jl.list, jlL);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := leaveList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				IF id.expires_on # BA.revoked THEN
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
					IF id.expires_on >= 0 THEN (* ~leaving *)
						INC(id.expires_on, pars.msValidity);
					ELSE
						DEC(id.expires_on, pars.msValidity);
					END;
					idMan.WriteData(idRef, id);
					NEW(iK); iK.ref := idRef;
					b := idTimeT.SearchIns(iK); ASSERT(~b, 126);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddTimeList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
			END;
		END Identities;
	
	(* Add certifications of one block in certFromT, certToT and certTimeT *)
	PROCEDURE Certifications (withList: BOOLEAN; IN ss, nb: ARRAY OF CHAR);
		
		VAR
			
			i, n, res: INTEGER;
			pC, v, oldPC: B.FilePos;
			b: BOOLEAN;
			c: Certification;
			idP: PubKey;
			idU: B.String;
			idRef: B.FilePos;
			id: Identity;
			cL: UndoList; (*certAddList *)
			ind: B.Index;
			iK: LIntKey;
			s: ARRAY 11 OF CHAR;
		
		BEGIN (*Certifications*)
			i := 1;
			WHILE ss[i] # ']' DO
				INC(i);
				NEW(c);
				ScanS(ss, ':', c.from, i);
				ScanS(ss, ':', c.to, i);
				ScanS(ss, ':', s, i);
				SkipS(ss, '"', i);
				IF ss[i] # ']' THEN
					INC(i);
				END;
				Strings.StringToInt(nb, c.block_number, res); ASSERT(res = 0, 100);
				Strings.StringToInt(s, n, res); ASSERT(res = 0, 101);
				b := TimeOf(n, c.expires_on); ASSERT(b, 102);
				INC(c.expires_on, pars.sigValidity);
				pC := certMan.WriteAllocateData(c);
				NEW(idP);
				idP.ref := c.from;
				IF certFromT.SearchIns(idP) THEN
					v := certFromT.ReadValue();
				ELSE
					v := database.CreateIndex(pubKeyS);
					certFromT.WriteValue(v);
				END;
				idP.ref := c.to;
				ind := database.OpenIndex(v, pubKeyMan, pubKeyFac);
				IF ind.SearchIns(idP) THEN
					oldPC := ind.ReadValue();
				ELSE
					oldPC := B.bNil;
				END;
				ind.WriteValue(pC);
				ind.Close;
				idP.ref := c.to;
				IF certToT.SearchIns(idP) THEN
					v := certToT.ReadValue();
				ELSE
					v := database.CreateIndex(pubKeyS);
					certToT.WriteValue(v);
				END;
				idP.ref := c.from;
				ind := database.OpenIndex(v, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP);
				ind.WriteValue(pC);
				ind.Close;
				NEW(iK);
				IF oldPC = B.bNil THEN
					NEW(idU);
					idP.ref := c.from;
					b := idPubT.Search(idP); ASSERT(b, 103);
					idRef := idPubT.ReadValue();
					id := idMan.ReadData(idRef)(Identity);
					b := IdPub(c.to, idU.c); ASSERT(b, 104);
					IF id.certified = B.bNil THEN
						id.certified := database.CreateIndex(0);
						idMan.WriteData(idRef, id);
					END;
					ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
					b := ind.SearchIns(idU);
					ind.Close;
					idP.ref := c.to;
					b := idPubT.Search(idP); ASSERT(b, 105);
					idRef := idPubT.ReadValue();
					id := idMan.ReadData(idRef)(Identity);
					b := IdPub(c.from, idU.c); ASSERT(b, 106);
					IF id.certifiers = B.bNil THEN
						id.certifiers := database.CreateIndex(0);
						idMan.WriteData(idRef, id);
					END;
					ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
					b := ind.SearchIns(idU);
					ind.Close;
				ELSE
					iK.ref := oldPC;
					b := certTimeT.Erase(iK); ASSERT(b, 107);
				END;
				iK.ref := pC;
				b := certTimeT.SearchIns(iK); ASSERT(~b, 108);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certAddList; cL.ref := pC; cL.aux := oldPC;
					undoList := undoListMan.WriteAllocateData(cL);
				ELSIF oldPC # B.bNil THEN
					certMan.EraseData(oldPC);
				END;
			END;
		END Certifications;
	
	(* Remove c keys from certFromT and certToT *)
	PROCEDURE RemoveCert (c: Certification);
		
		VAR
			
			pKFrom, pKTo: PubKey;
			b, empty: BOOLEAN;
			n: B.FilePos;
			ind: B.Index;
		
		BEGIN (*RemoveCert*)
			NEW(pKFrom); NEW(pKTo);
			pKFrom.ref := c.from; pKTo.ref := c.to;
			
			b := certFromT.Search(pKFrom); ASSERT(b, 100);
			n := certFromT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKTo); ASSERT(b, 101);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certFromT.Erase(pKFrom); ASSERT(b, 102);
			END;
			
			b := certToT.Search(pKTo); ASSERT(b, 103);
			n := certToT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKFrom); ASSERT(b, 104);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certToT.Erase(pKTo); ASSERT(b, 105);
			END;
		END RemoveCert;
	
	(* Remove expired certifications from certFromT and certToT *)
	PROCEDURE RemoveExpiredCerts (now, secureNow: LONGINT);
		
		VAR
			
			c: Certification;
			iK: LIntKey;
			b, withList: BOOLEAN;
			pC: B.FilePos;
			cL: UndoList; (* certRemoveList *)
		
		BEGIN (*RemoveExpiredCerts*)
			NEW(c); c.expires_on := now; c.from := "";
			pC := certMan.WriteAllocateData(c);
			NEW(iK); iK.ref := pC;
			b := certTimeT.Search(iK);
			certMan.EraseData(pC);
			WHILE certTimeT.PosSet() DO
				pC := certTimeT.CurrentKey()(LIntKey).ref;
				certTimeT.Next;
				c := certMan.ReadData(pC)(Certification);
				RemoveCert(c);
				withList := c.expires_on >= secureNow;
				iK.ref := pC;
				b := certTimeT.Erase(iK); ASSERT(b, 100);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certRemoveList; cL.ref := pC; cL.aux := 0;
					undoList := undoListMan.WriteAllocateData(cL);
				ELSE
					certMan.EraseData(pC);
				END;
			END;
		END RemoveExpiredCerts;
	
	PROCEDURE RevokeExpiredIds (now, secureNow: LONGINT);
		
		VAR
			
			id: Identity;
			iK: LIntKey;
			b, withList: BOOLEAN;
			pId: B.FilePos;
			idL: UndoList;
		
		BEGIN (*RevokeExpiredIds*)
			NEW(id); id.expires_on := now; id.pubkey := ""; NEW(id.uid, 1); id.uid^ := "";
			pId := idMan.WriteAllocateData(id);
			NEW(iK); iK.ref := pId;
			b := idTimeT.Search(iK);
			idMan.EraseData(pId);
			WHILE idTimeT.PosSet() DO
				pId := idTimeT.CurrentKey()(LIntKey).ref;
				idTimeT.Next;
				id := idMan.ReadData(pId)(Identity);
				iK.ref := pId;
				b := idTimeT.Erase(iK); ASSERT(b, 100);
				withList := ABS(id.expires_on) >= secureNow;
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := pId; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				RevokeId(withList, id.pubkey);
			END;
		END RevokeExpiredIds;
	
	(* Undo the last operations done from the secureGap last blocks *)
	PROCEDURE RemoveSecureGap;
		
		VAR
			
			b: BOOLEAN;
			i: IntKey;
			li: LIntKey;
			p: PubKey;
			u: B.String;
			h: HashKey;
			t: Time;
			jlL: JoinAndLeaveL;
			jl: JoinAndLeave;
			idRef: B.FilePos;
			id: Identity;
			c: Certification;
			l: UndoList;
			n, jlRef, jlLRef: B.FilePos;
			ind: B.Index;
		
		BEGIN (*RemoveSecureGap*)
			WHILE undoList # B.bNil DO
				l := undoListMan.ReadData(undoList)(UndoList);
				CASE l.type OF
					|timeList:
						(* Erase the Time data pointed by l.ref and the corresponding key in timeT *)
						t := timeMan.ReadData(l.ref)(Time);
						NEW(i); i.ref := t.bnb;
						b := timeT.Erase(i); ASSERT(b, 100);
						timeMan.EraseData(l.ref);
					|idAddList:
						(* Erase the Identity data pointed by l.ref and the corresponding keys in idPubT, idHashT and idUidT *)
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.Erase(p); ASSERT(b, 101);
						NEW(u); u.c := id.uid;
						b := idUidT.Erase(u); ASSERT(b, 102);
						NEW(h); h.ref := id.hash;
						b := idHashT.Erase(h); ASSERT(b, 103);
						idMan.EraseData(l.ref);
					|joinList:
						(* Let the identity no more be member; erase the last JoinAndLeaveL data corresponding to l.ref; if this is also the first data, erase the corresponding JoinAndLeave data and its key in joinAndLeaveT *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := FALSE;
						idMan.WriteData(l.ref, id);
						DEC(idLenM);
						NEW(p); p.ref := id.pubkey;
						b := joinAndLeaveT.Search(p); ASSERT(b, 104);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlLRef := jl.list;
						jlL := joinAndLeaveLMan.ReadData(jlLRef)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock = hasNotLeaved, 105);
						IF jlL.next = B.bNil THEN
							joinAndLeaveMan.EraseData(jlRef);
							b := joinAndLeaveT.Erase(p); ASSERT(b, 106);
						ELSE
							jl.list := jlL.next;
							joinAndLeaveMan.WriteData(jlRef, jl);
						END;
						joinAndLeaveLMan.EraseData(jlLRef);
					|activeList:
						(* Undo the Identity.expires_on update *)
						id := idMan.ReadData(l.ref)(Identity);
						id.expires_on := l.aux;
						id.application := l.aux2;
						idMan.WriteData(l.ref, id);
					|leaveList:
						(* Update the last JoinAndLeaveL data corresponding to l.ref *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := TRUE;
						idMan.WriteData(l.ref, id);
						INC(idLenM);
						NEW(p); p.ref := id.pubkey;
						b := joinAndLeaveT.Search(p); ASSERT(b, 107);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock # hasNotLeaved, 108);
						jlL.leavingBlock := hasNotLeaved;
						joinAndLeaveLMan.WriteData(jl.list, jlL);
					|idAddTimeList:
						NEW(li); li.ref := l.ref;
						b := idTimeT.Erase(li); ASSERT(b, 109);
					|idRemoveTimeList:
						NEW(li); li.ref := l.ref;
						b := idTimeT.SearchIns(li); ASSERT(~b, 110);
					|certAddList:
						(* Erase the keys corresponding to the certification pointed by l.ref in certFromT and certToT, or, if l.aux # B.bNil, update them; modify Identity. certifiers and Identity.certified as needed *)
						c := certMan.ReadData(l.ref)(Certification);
						NEW(li); li.ref := l.ref;
						b := certTimeT.Erase(li); ASSERT(b, 111);
						NEW(p);
						IF l.aux = B.bNil THEN
							RemoveCert(c);
							NEW(u);
							p.ref := c.from;
							b := idPubT.Search(p); ASSERT(b, 112);
							idRef := idPubT.ReadValue();
							id := idMan.ReadData(idRef)(Identity);
							b := IdPub(c.to, u.c); ASSERT(b, 113);
							ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
							b := ind.Erase(u); ASSERT(b, 114);
							b := ind.IsEmpty();
							ind.Close;
							IF b THEN
								database.DeleteIndex(id.certified); id.certified := B.bNil;
								idMan.WriteData(idRef, id);
							END;
							p.ref := c.to;
							b := idPubT.Search(p); ASSERT(b, 115);
							idRef := idPubT.ReadValue();
							id := idMan.ReadData(idRef)(Identity);
							b := IdPub(c.from, u.c); ASSERT(b, 116);
							ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
							b := ind.Erase(u); ASSERT(b, 117);
							b := ind.IsEmpty();
							ind.Close;
							IF b THEN
								database.DeleteIndex(id.certifiers); id.certifiers := B.bNil;
								idMan.WriteData(idRef, id);
							END;
						ELSE
							p.ref := c.from;
							b := certFromT.Search(p); ASSERT(b, 118);
							n := certFromT.ReadValue();
							ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
							p.ref := c.to;
							b := ind.Search(p); ASSERT(b, 119);
							ind.WriteValue(l.aux);
							ind.Close;
							p.ref := c.to;
							b := certToT.Search(p); ASSERT(b, 120);
							n := certToT.ReadValue();
							ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
							p.ref := c.from;
							b := ind.Search(p); ASSERT(b, 121);
							ind.WriteValue(l.aux);
							ind.Close;
							li.ref := l.aux;
							b := certTimeT.SearchIns(li); ASSERT(~b, 122);
						END;
						certMan.EraseData(l.ref);
					|certRemoveList:
						(* Insert the keys corresponding to the Certification pointed by l.ref into certFromT, certToT and certTimeT *)
						c := certMan.ReadData(l.ref)(Certification);
						NEW(p);
						p.ref := c.from;
						IF certFromT.SearchIns(p) THEN
							n := certFromT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certFromT.WriteValue(n);
						END;
						p.ref := c.to;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 123);
						ind.WriteValue(l.ref);
						ind.Close;
						IF certToT.SearchIns(p) THEN
							n := certToT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certToT.WriteValue(n);
						END;
						p.ref := c.from;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 124);
						ind.WriteValue(l.ref);
						ind.Close;
						NEW(li); li.ref := l.ref;
						b := certTimeT.SearchIns(li); ASSERT(~b, 125);
					|remCertifiers:
						id := idMan.ReadData(l.aux)(Identity);
						NEW(u); u.c := id.uid;
						id := idMan.ReadData(l.ref)(Identity);
						IF id.certifiers = B.bNil THEN
							id.certifiers := database.CreateIndex(0);
							idMan.WriteData(l.ref, id);
						END;
						ind := database.OpenIndex(id.certifiers, uidKeyMan, uidKeyFac);
						b := ind.SearchIns(u); ASSERT(~b, 126);
						ind.Close;
					|remCertified:
						id := idMan.ReadData(l.aux)(Identity);
						NEW(u); u.c := id.uid;
						id := idMan.ReadData(l.ref)(Identity);
						IF id.certified = B.bNil THEN
							id.certified := database.CreateIndex(0);
							idMan.WriteData(l.ref, id);
						END;
						ind := database.OpenIndex(id.certified, uidKeyMan, uidKeyFac);
						b := ind.SearchIns(u); ASSERT(~b, 127);
						ind.Close;
				END;
				undoListMan.EraseData(undoList);
				undoList := l.next;
			END;
		END RemoveSecureGap;
	
	PROCEDURE ReadSyncTime (): LONGINT;
		
		VAR
			
			name: Files.Name;
			v: Views.View;
			t: TextModels.Model;
			s: TextMappers.Scanner;
		
		BEGIN (*ReadSyncTime*)
			name := syncName;
			v := Views.Old(Views.dontAsk, duniLoc, name, BA.utf8Conv); ASSERT(v # NIL, 100);
			t := v(TextViews.View).ThisModel();
			s.ConnectTo(t);
			s.Scan; ASSERT(s.type IN {TextMappers.int, TextMappers.lint}, 101);
			RETURN s.lint;
		END ReadSyncTime;
	
	PROCEDURE WriteSyncTime (t: LONGINT);
		
		VAR
			
			txt: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*WriteSyncTime*)
			txt := TextModels.dir.New();
			f.ConnectTo(txt);
			f.WriteInt(t);
			BA.VRegister(TextViews.dir.New(txt), duniLoc, syncName, 100, "BlockchainUpdt.WriteSyncTime");
		END WriteSyncTime;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks (d: S.Database);
		
		VAR
			
			cur: S.Row;
			t, tt: S.Table;
			i, res: INTEGER;
			s: ARRAY 13 OF CHAR;
			withList: BOOLEAN;
			now, secureNow, t0, t1: LONGINT;
		
		BEGIN (*ScanBlocks*)
			t1 := Services.Ticks() - verifyPeriod + syncDelay - secureDelay;
			t0 := ReadSyncTime();
			idLenM := SHORT(database.ReadPlace(idLenPlace));
			undoList := database.ReadPlace(undoListPlace);
			RemoveSecureGap;
			lastBlock := SHORT(database.ReadPlace(lastNPlace));
			Strings.IntToString(lastBlock - secureGap + 1, s);
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT number, medianTime, time, joiners, actives, leavers, revoked, excluded, certifications FROM block WHERE NOT fork AND number >= " + s + " ORDER BY number ASC");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 9), 102);
			tt := d.NewTable(); ASSERT(tt # NIL, 103);
			FOR i := 0 TO t.rows - 1 DO
				IF Services.Ticks() > t1 THEN
					INC(t1, addDelay);
					INC(t0, addDelay);
					WriteSyncTime(t0);
				END;
				t.Read(i, cur);
				IF i MOD 5000 = 0 THEN
					lg.Msg("Added block " + cur.fields[0]);
				END;
				withList := i >= t.rows - secureGap;
				Times(withList , cur.fields[0], cur.fields[1], cur.fields[2]);
				Identities(withList, cur.fields[3], cur.fields[4], cur.fields[5], cur.fields[6], cur.fields[7], cur.fields[0], tt);
				Certifications(withList, cur.fields[8], cur.fields[0]);
			END;
			IF t.rows > 0 THEN
				t.Read(t.rows - 1, cur);
				Strings.StringToInt(cur.fields[0], lastBlock, res); ASSERT(res = 0, 104);
				Strings.StringToLInt(cur.fields[1], now, res); ASSERT(res = 0, 105);
				IF secureGap = 0 THEN
					secureNow := MAX(LONGINT);
				ELSE
					IF t.rows >= secureGap THEN
						t.Read(t.rows - secureGap, cur);
					ELSE
						t.Read(0, cur);
					END;
					Strings.StringToLInt(cur.fields[1], secureNow, res); ASSERT(res = 0, 106);
				END;
				RevokeExpiredIds(now, secureNow);
				RemoveExpiredCerts(now, secureNow); (* Élimine toutes les certifications expirées avec réversibilité dans secureGap *)
			END;
			database.WritePlace(undoListPlace, undoList);
			database.WritePlace(lastNPlace, lastBlock);
			database.WritePlace(idLenPlace, idLenM);
			lg.Msg("Last read block:");
			lg.Int(lastBlock);
			lg.Msg("Number of members:");
			lg.Int(idLenM);
			lg.Msg("");
		END ScanBlocks;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			IF l = NIL THEN
				NEW(l);
				l.next := NIL;
				l.update := updateProc;
				IF m = NIL THEN
					updateList := l;
				ELSE
					m.next := l;
				END;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList;
			m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			IF l # NIL THEN
				IF m = NIL THEN
					updateList := l.next;
				ELSE
					m.next := l.next;
				END;
			END;
		END RemoveUpdateProc;
	
	(* Scan the Duniter database *)
	PROCEDURE Scan;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan*)
			S.OpenDatabase(driver, "", "", BA.duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			ScanBlocks(d);
		END Scan;
	
	(* Scan the Duniter parameters in block 0 *)
	PROCEDURE Scan1;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan1*)
			S.OpenDatabase(driver, "", "", BA.duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			Params(d);
		END Scan1;
	
	PROCEDURE ExportParameters;
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*ExportParameters*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			J.BuildJsonFrom(pars).Write(f);
			BA.VRegister(TextViews.dir.New(t), dLoc, dPars, 100, "BlockchainUpdt.ExportParameters");
		END ExportParameters;
	
	PROCEDURE UpdateAll;
		
		BEGIN (*UpdateAll*)
			Files.dir.Delete(duniLoc, syncName); ASSERT(duniLoc.res IN {0, 2}, 100);
			Services.DoLater(update, Services.Ticks() + verifyPeriod)
		END UpdateAll;
	
	PROCEDURE DoUpdates (d: ANYPTR; done: BOOLEAN);
		
		VAR
			
			l: UpdateList;
			f: Files.File;
			res: INTEGER;
		
		BEGIN (*DoUpdates*)
			IF done THEN
				IF doScan1 THEN
					doScan1 := FALSE;
					Scan1;
					ExportParameters;
				END;
				OpenB;
				l := updateList;
				WHILE l # NIL DO
					l.update;
					l := l.next;
				END;
				CloseB;
				BA.Collect;
				mutex.Unlock(NIL, NIL);
				f := Files.dir.New(dLoc, Files.dontAsk);
				lg.Assert(f # NIL, 100, 0, "BlockchainUpdt.DoUpdates");
				f.Register(dSyncName, "txt", Files.dontAsk, res);
				lg.Assert(res = 0, 101, res, "BlockchainUpdt.DoUpdates");
				UpdateAll;
			ELSIF Services.Ticks() > d(MutexData).t1 THEN
				WITH d: MutexData DO
					INC(d.t1, addDelay);
					INC(d.t0, addDelay);
					WriteSyncTime(d.t0);
				END;
			END;
		END DoUpdates;
	
	PROCEDURE (update: UpdateAction) Do;
		
		VAR
			
			f: Files.File;
			md: MutexData;
		
		BEGIN (*Do*)
			f := Files.dir.Old(duniLoc, syncName, Files.shared);
			IF f = NIL THEN
				Services.DoLater(update, Services.Ticks() + verifyPeriod);
			ELSE
				f.Close;
				NEW(md);
				md.t1 := Services.Ticks() - verifyPeriod + syncDelay - secureDelay;
				md.t0 := ReadSyncTime();
				mutex.Lock(DoUpdates, md);
			END;
		END Do;
	
	PROCEDURE Start*;
		
		BEGIN (*Start*)
			UpdateAll;
		END Start;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			lg := BA.lg;
			lastBlock := - 1;
			now := 0;
			duniLoc := Files.dir.This(BA.duniDir); ASSERT(duniLoc.res = 0, 100);
			dLoc := Files.dir.This(dDir); ASSERT(dLoc.res = 0, 101);
			doScan1 := TRUE;
			updateList := NIL;
			AddUpdateProc(Scan);
			NEW(undoListFac); NEW(timeFac); NEW(joinAndLeaveLFac); NEW(joinAndLeaveFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(lIntKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan);
			NEW(hashKeyFac); NEW(hashKeyMan);
			NEW(intKeyMan); NEW(idKTimeMan); NEW(certKTimeMan);
			idLenM := 0;
			NEW(update);
			mutex := UtilMutex.NewMutex(mutexOwner);
		END Init;
	
	BEGIN (*Duniter1BlockchainUpdt*)
		Init;
	CLOSE
		Services.RemoveAction(update);
	END Duniter1BlockchainUpdt.
