(* 
Duniter1: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE Duniter1WotWizardList;
	
	

	IMPORT
		
		A := UtilAvlTree, B := Duniter1Blockchain, BA := Duniter1Basic, TextMappers, TextModels, TextViews, J := UtilJson, W := Duniter1WotWizard;
	
	CONST
		
		fileA = 1;
		permA = 2;
	
	TYPE
		
		Action = POINTER TO RECORD (B.Action)
			what: INTEGER;
			output: BA.String;
		END;
	
	(* List f with fo, starting at the element of rank i0; if withNow, the output begins with the listing of the current date *)
	PROCEDURE DoListFile (f: W.File): J.Json;
		
		PROCEDURE ListFile (f: W.File; withTo: BOOLEAN);
			
			VAR
				
				now: LONGINT;
				i: INTEGER;
			
			PROCEDURE ListCertOrDoss (cd: W.CertOrDoss);
				
				PROCEDURE ListCertOrDossEnd (cd: W.CertOrDoss);
					
					BEGIN (*ListCertOrDossEnd*)
						J.PushInteger(cd.date);
						J.BuildField("date");
						J.PushInteger(cd.limit);
						J.BuildField("limit");
					END ListCertOrDossEnd;
				
				(* List c *)
				PROCEDURE ListCertif (c: W.Certif);
					
					BEGIN (*ListCertif*)
						J.StartObject;
						J.PushString(c.from);
						J.BuildField("from");
						IF withTo THEN
							J.PushString(c.to);
							J.BuildField("to");
						END;
						J.PushBoolean((c.date < now) & (now <= c.limit));
						J.BuildField("ok");
						ListCertOrDossEnd(c);
						J.BuildObject;
					END ListCertif;
				
				(* List d *)
				PROCEDURE ListDossier (d: W.Dossier);
					
					BEGIN (*ListDossier*)
						J.StartObject;
						J.PushString(d.id);
						J.BuildField("newcomer");
						J.PushInteger(d.princCertif);
						J.BuildField("main_certifs");
						J.PushReal(d.proportionOfSentries);
						J.BuildField("proportion_of_sentries");
						J.PushBoolean((d.princCertif >= B.pars.sigQty) & (now <= d.limit) & (d.proportionOfSentries >= B.pars.xpercent));
						J.BuildField("ok");
						ListCertOrDossEnd(d);
						ListFile(d.certifs, FALSE);
						J.BuildField("certifs");
						J.BuildObject;
					END ListDossier;
				
				BEGIN (*ListCertOrDoss*)
					WITH
						|cd: W.Certif DO
							IF withTo THEN
								J.StartObject;
							END;
							ListCertif(cd);
							IF withTo THEN
								J.BuildField("certif");
								J.BuildObject;
							END;
						|cd: W.Dossier DO
							J.StartObject;
							ListDossier(cd);
							J.BuildField("dossier");
							J.BuildObject;
					END;
				END ListCertOrDoss;
			
			BEGIN (*ListFile*)
				J.StartArray;
				IF f # NIL THEN
					now := B.Now();
					FOR i := 0 TO LEN(f) - 1 DO
						ListCertOrDoss(f[i]);
					END;
				END;
				J.BuildArray;
			END ListFile;
		
		BEGIN (*DoListFile*)
			J.StartObject;
			ListFile(f, TRUE);
			J.BuildField("file");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			J.PushInteger(B.Now());
			J.BuildField("now");
			J.BuildObject;
			RETURN J.GetJson();
		END DoListFile;
	
	(* Print the current W.File *)
	PROCEDURE DoShowFile (): J.Json;
		
		VAR
			
			f: W.File;
			cNb, dNb: INTEGER;
		
		BEGIN (*DoShowFile*)
			W.FillFile(0, f, cNb, dNb);
			RETURN DoListFile(f);
		END DoShowFile;
	
	(* List permutations returned by CalcPermutations *)
	PROCEDURE ListPermutations (f: W.File): J.Json;
		
		VAR
			
			n: INTEGER;
			sets, tD: A.Tree;
			e, ee: A.Elem;
			debug: W.Debug;
		
		PROCEDURE ByDate (tId: A.Tree): A.Tree;
			
			VAR
				
				tD: A.Tree;
				pD: W.PropDate;
				e, ee: A.Elem;
				b: BOOLEAN;
			
			BEGIN (*ByDate*)
				A.New(tD);
				e := tId.Next(NIL);
				WHILE e # NIL DO
					WITH e: W.Propagation DO
						NEW(pD);
						pD.id := e.id;
						pD.date := e.date;
						pD.after := e.after;
						ee := pD;
						b := tD.SearchIns(ee, n); ASSERT(~b, 101);
					END;
					e := tId.Next(e);
				END;
				RETURN tD;
			END ByDate;
		
		BEGIN (*ListPermutations*)
			debug := NIL;
			J.StartObject;
			J.StartArray;
			IF W.CalcPermutations(f, debug, sets) THEN
				e := sets.Next(NIL);
				WHILE e # NIL DO
					J.StartObject;
					WITH e: W.Set DO
						J.PushReal(e.proba);
						J.BuildField("proba");
						tD := ByDate(e.t);
						J.StartArray;
						ee := tD.Next(NIL);
						WHILE ee # NIL DO
							J.StartObject;
							WITH ee: W.Propagation DO
								J.PushString(ee.id);
								J.BuildField("id");
								J.PushInteger(ee.date);
								J.BuildField("date");
								J.PushBoolean(ee.after);
								J.BuildField("after");
							END;
							J.BuildObject;
							ee := tD.Next(ee);
						END;
						J.BuildArray;
						J.BuildField("permutation");
					END;
					J.BuildObject;
					e := sets.Next(e);
				END;
			END;
			J.BuildArray;
			J.BuildField("permutations");
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			J.PushInteger(B.Now());
			J.BuildField("now");
			J.BuildObject;
			RETURN J.GetJson();
		END ListPermutations;
	
	(* Print the set of current possible permutations of entries *)
	PROCEDURE DoPermutations (): J.Json;
		
		VAR
			
			f: W.File;
			cNb, dNb: INTEGER;
		
		BEGIN (*DoPermutations*)
			W.FillFile(B.pars.sigQty, f, cNb, dNb);
			RETURN ListPermutations(f);
		END DoPermutations;
	
	PROCEDURE Json (j: J.Json; IN name: ARRAY OF CHAR);
		
		VAR
			
			t: TextModels.Model;
			f: TextMappers.Formatter;
		
		BEGIN (*Json*)
			t := TextModels.dir.New();
			f.ConnectTo(t);
			j.Write(f);
			BA.VRegister(TextViews.dir.New(t), BA.waitLoc, name$, 100, "WotWizardList.Json");
		END Json;
	
	PROCEDURE (a: Action) Activate;
		
		BEGIN (*Activate*)
			CASE a.what OF
				|fileA:
					Json(DoShowFile(), a.output);
				|permA:
					Json(DoPermutations(), a.output);
			END;
		END Activate;
	
	(* Print the current W.File *)
	PROCEDURE ShowFile* (IN output: ARRAY OF CHAR);
		VAR
			
			a: Action;
		
		BEGIN (*ShowFile*)
			NEW(a);
			a.what := fileA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END ShowFile;
	
	(* Print the set of current possible permutations of entries *)
	PROCEDURE Permutations* (IN output: ARRAY OF CHAR);
		
		VAR
			
			a: Action;
		
		BEGIN (*Permutations*)
			NEW(a);
			a.what := permA;
			NEW(a.output, LEN(output$) + 1); a.output^ := output$;
			B.AddAction(a);
		END Permutations;
	
	END Duniter1WotWizardList.
