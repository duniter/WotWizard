(*
Babel: a compiler compiler.

Copyright (C) 2001 Gérard Meunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE BabelAvl;
	
	
	
	(* This module implements balanced and threaded trees. *)
	
	CONST
		
		(* Results of comparison. *)
		inf* = -1; (* less than *)
		ega* = 0; (* equal *)
		sup* = + 1; (* greater than *)
	
	TYPE
		
		Elem* = POINTER TO ABSTRACT RECORD (* Element of a tree. *)
			left, right: Elem; (* Left and right links. *)
			lTag, rTag: BOOLEAN; (* Indicate if the corresponding links point to a child or to the next element. *)
			bal: BYTE; (* AVL balance (inf, ega or sup). *)
			rank: INTEGER; (* Rank in the tree. *)
		END;
		
		Tree* = POINTER TO LIMITED RECORD (* An AVL tree. *)
			root: Elem;
		END;
		
		VoidElem = POINTER TO RECORD (Elem)
		END;
	
	(* Compare e to el; returns inf if e< el, ega if e= el and sup if e> el. *)
	PROCEDURE (e: Elem) Compare- (el: Elem): BYTE, NEW, EXTENSIBLE;
		
		BEGIN (*Compare*)
			HALT(25);
			RETURN ega;
		END Compare;
	
	(* Creates a new empty tree t. *)
	PROCEDURE New* (OUT t: Tree);
		
		VAR
			
			e: VoidElem;
		
		BEGIN (*New*)
			NEW(t);
			NEW(e);
			e.left := e;
			e.lTag := FALSE;
			e.right := e;
			e.rTag := TRUE;
			t.root := e;
		END New;
	
	PROCEDURE BalGI (VAR p: Elem; VAR h: BOOLEAN);
		
		VAR
			
			p1, p2: Elem;
		
		BEGIN (*BalGI*)
			CASE p.bal OF
				|sup:
					p.bal := ega;
					h := FALSE;
				|ega:
					p.bal := inf;
				|inf:
					p1 := p.left;
					IF p1.bal = inf THEN
						IF p1.rTag THEN
							p.left := p1.right;
						ELSE
							p.left := p1;
						END;
						p.lTag := p1.rTag;
						p1.right := p;
						p1.rTag := TRUE;
						p.bal := ega;
						p1.bal := ega;
						DEC(p.rank, p1.rank);
						p := p1;
					ELSE
						p2 := p1.right;
						IF p2.lTag THEN
							p1.right := p2.left;
						ELSE
							p1.right := p2;
						END;
						p1.rTag := p2.lTag;
						p2.left := p1;
						p2.lTag := TRUE;
						IF p2.rTag THEN
							p.left := p2.right;
						ELSE
							p.left := p2;
						END;
						p.lTag := p2.rTag;
						p2.right := p;
						p2.rTag := TRUE;
						IF p2.bal = inf THEN
							p.bal := sup;
						ELSE
							p.bal := ega;
						END;
						IF p2.bal = sup THEN
							p1.bal := inf;
						ELSE
							p1.bal := ega;
						END;
						p2.bal := ega;
						INC(p2.rank, p1.rank);
						DEC(p.rank, p2.rank);
						p := p2;
					END;
					h := FALSE;
			END;
		END BalGI;
	
	PROCEDURE BalDI (VAR p: Elem; VAR h: BOOLEAN);
		
		VAR
			
			p1, p2: Elem;
		
		BEGIN (*BalDI*)
			CASE p.bal OF
				|inf:
					p.bal := ega;
					h := FALSE;
				|ega:
					p.bal := sup;
				|sup:
					p1 := p.right;
					IF p1.bal = sup THEN
						IF p1.lTag THEN
							p.right := p1.left;
						ELSE
							p.right := p1;
						END;
						p.rTag := p1.lTag;
						p1.left := p;
						p1.lTag := TRUE;
						p.bal := ega;
						p1.bal := ega;
						INC(p1.rank, p.rank);
						p := p1;
					ELSE
						p2 := p1.left;
						IF p2.rTag THEN
							p1.left := p2.right;
						ELSE
							p1.left := p2;
						END;
						p1.lTag := p2.rTag;
						p2.right := p1;
						p2.rTag := TRUE;
						IF p2.lTag THEN
							p.right := p2.left;
						ELSE
							p.right := p2;
						END;
						p.rTag := p2.lTag;
						p2.left := p;
						p2.lTag := TRUE;
						IF p2.bal = sup THEN
							p.bal := inf;
						ELSE
							p.bal := ega;
						END;
						IF p2.bal = inf THEN
							p1.bal := sup;
						ELSE
							p1.bal := ega;
						END;
						p2.bal := ega;
						DEC(p1.rank, p2.rank);
						INC(p2.rank, p.rank);
						p := p2;
					END;
					h := FALSE;
			END;
		END BalDI;
	
	PROCEDURE BalGE (VAR p: Elem; VAR h: BOOLEAN);
		
		VAR
			
			p1, p2: Elem;
		
		BEGIN (*BalGE*)
			CASE p.bal OF
				|inf:
					p.bal := ega;
				|ega:
					p.bal := sup;
					h := FALSE;
				|sup:
					p1 := p.right;
					IF p1.bal = inf THEN
						p2 := p1.left;
						IF p2.rTag THEN
							p1.left := p2.right;
						ELSE
							p1.left := p2;
						END;
						p1.lTag := p2.rTag;
						p2.right := p1;
						p2.rTag := TRUE;
						IF p2.lTag THEN
							p.right := p2.left;
						ELSE
							p.right := p2;
						END;
						p.rTag := p2.lTag;
						p2.left := p;
						p2.lTag := TRUE;
						IF p2.bal = sup THEN
							p.bal := inf;
						ELSE
							p.bal := ega;
						END;
						IF p2.bal = inf THEN
							p1.bal := sup;
						ELSE
							p1.bal := ega;
						END;
						p2.bal := ega;
						DEC(p1.rank, p2.rank);
						INC(p2.rank, p.rank);
						p := p2;
					ELSE
						IF p1.lTag THEN
							p.right := p1.left;
						ELSE
							p.right := p1;
						END;
						p.rTag := p1.lTag;
						p1.left := p;
						p1.lTag := TRUE;
						IF p1.bal = ega THEN
							p.bal := sup;
							p1.bal := inf;
							h := FALSE;
						ELSE
							p.bal := ega;
							p1.bal := ega;
						END;
						INC(p1.rank, p.rank);
						p := p1;
					END;
			END;
		END BalGE;
	
	PROCEDURE BalDE (VAR p: Elem; VAR h: BOOLEAN);
		
		VAR
			
			p1, p2: Elem;
		
		BEGIN (*BalDE*)
			CASE p.bal OF
				|sup:
					p.bal := ega;
				|ega:
					p.bal := inf;
					h := FALSE;
				|inf:
					p1 := p.left;
					IF p1.bal = sup THEN
						p2 := p1.right;
						IF p2.lTag THEN
							p1.right := p2.left;
						ELSE
							p1.right := p2;
						END;
						p1.rTag := p2.lTag;
						p2.left := p1;
						p2.lTag := TRUE;
						IF p2.rTag THEN
							p.left := p2.right;
						ELSE
							p.left := p2;
						END;
						p.lTag := p2.rTag;
						p2.right := p;
						p2.rTag := TRUE;
						IF p2.bal = inf THEN
							p.bal := sup;
						ELSE
							p.bal := ega;
						END;
						IF p2.bal = sup THEN
							p1.bal := inf;
						ELSE
							p1.bal := ega;
						END;
						p2.bal := ega;
						INC(p2.rank, p1.rank);
						DEC(p.rank, p2.rank);
						p := p2;
					ELSE
						IF p1.rTag THEN
							p.left := p1.right;
						ELSE
							p.left := p1;
						END;
						p.lTag := p1.rTag;
						p1.right := p;
						p1.rTag := TRUE;
						IF p1.bal = ega THEN
							p.bal := inf;
							p1.bal := sup;
							h := FALSE;
						ELSE
							p.bal := ega;
							p1.bal := ega;
						END;
						DEC(p.rank, p1.rank);
						p := p1;
					END;
			END;
		END BalDE;
	
	PROCEDURE SupG (first: BOOLEAN; VAR r: Elem; VAR t: BOOLEAN; OUT s: Elem; OUT h: BOOLEAN);
		
		BEGIN (*SupG*)
			IF ~r.rTag THEN
				s := r;
				t := r.lTag;
				IF t OR first THEN
					r := r.left;
				END;
				h := TRUE;
			ELSE
				SupG(FALSE, r.right, r.rTag, s, h);
				IF h THEN
					BalDE(r, h);
				END;
			END;
		END SupG;
	
	(* Searches the element key in the sorted tree t; if key is found, returns TRUE, else key is inserted in the tree; rank returns the rank of key in the tree; Elem.Compare must be instantiated. It's key.Compare which is used when testing the position of key in the tree t. *)
	PROCEDURE (t: Tree) SearchIns* (VAR key: Elem; OUT rank: INTEGER): BOOLEAN, NEW;
		
		VAR
			
			h, found: BOOLEAN;
		
		PROCEDURE Ins (q: Elem; l: BOOLEAN; VAR p: Elem; VAR t: BOOLEAN);
			
			BEGIN (*Ins*)
				IF ~t THEN
					found := FALSE;
					h := TRUE;
					t := TRUE;
					IF l THEN
						key.left := p;
						key.right := q;
					ELSE
						key.right := p;
						key.left := q;
					END;
					p := key;
					p.lTag := FALSE;
					p.rTag := FALSE;
					p.bal := ega;
					p.rank := 1;
					rank := 1;
				ELSE
					CASE key.Compare(p) OF
						|inf:
							Ins(p, TRUE, p.left, p.lTag);
							IF ~found THEN
								INC(p.rank);
							END;
							IF h THEN
								BalGI(p, h);
							END;
						|sup:
							Ins(p, FALSE, p.right, p.rTag);
							INC(rank, p.rank);
							IF h THEN
								BalDI(p, h);
							END;
						|ega:
							h := FALSE;
							found := TRUE;
							key := p;
							rank := p.rank;
					END;
				END;
			END Ins;
		
		BEGIN (*SearchIns*)
			ASSERT(t.root # NIL, 20);
			ASSERT(key # NIL, 21);
			Ins(t.root, TRUE, t.root.left, t.root.lTag);
			RETURN found;
		END SearchIns;
	
	(* Searches the element key in the sorted tree t; if key is found, returns TRUE; rank returns the rank of key in the tree, or 0 if not found; Elem.Compare must be instantiated. It's key.Compare which is used when testing the position of key in the tree t. *)
	PROCEDURE (t: Tree) Search* (VAR key: Elem; OUT rank: INTEGER): BOOLEAN, NEW;
		
		VAR
			
			tag: BOOLEAN;
			val: Elem;
		
		BEGIN (*Search*)
			ASSERT(t.root # NIL, 20);
			ASSERT(key # NIL, 21);
			tag := t.root.lTag;
			val := t.root.left;
			rank := 0;
			LOOP
				IF ~tag THEN
					rank := 0;
					RETURN FALSE;
				ELSE
					CASE key.Compare(val) OF
						|inf:
							tag := val.lTag;
							val := val.left;
						|ega:
							INC(rank, val.rank);
							key := val;
							RETURN TRUE;
						|sup:
							INC(rank, val.rank);
							tag := val.rTag;
							val := val.right;
					END;
				END;
			END;
		END Search;
	
	PROCEDURE FixThreadL (p, q: Elem);
		
		BEGIN (*FixThreadL*)
			WHILE p.lTag DO
				p := p.left;
			END;
			p.left := q;
		END FixThreadL;
	
	PROCEDURE FixThreadR (p, q: Elem);
		
		BEGIN (*FixThreadR*)
			WHILE p.rTag DO
				p := p.right;
			END;
			p.right := q;
		END FixThreadR;
	
	PROCEDURE NOE (p: Elem; tag: BOOLEAN): INTEGER;
		
		VAR
			
			n: INTEGER;
		
		BEGIN (*NOE*)
			n := 0;
			WHILE tag DO
				INC(n, p.rank);
				tag := p.rTag;
				p := p.right;
			END;
			RETURN n;
		END NOE;
	
	(* Returns the number of elements in the tree t. *)
	PROCEDURE (t: Tree) NumberOfElems* (): INTEGER, NEW;
		
		BEGIN (*NumberOfElems*)
			ASSERT(t.root # NIL, 20);
			RETURN NOE(t.root.left, t.root.lTag);
		END NumberOfElems;
	
	(* Erases the element of position rank in the tree t; rank must verify 1<= rank<= t.NumberOfElems(). *)
	PROCEDURE (t: Tree) Erase* (rank: INTEGER), NEW;
		
		VAR
			
			h: BOOLEAN;
		
		PROCEDURE Supprime (l: BOOLEAN; VAR p: Elem; VAR t: BOOLEAN);
			
			VAR
				
				s: Elem;
			
			BEGIN (*Supprime*)
				IF ~t THEN
					HALT(21);
				ELSIF rank < p.rank THEN
					Supprime(TRUE, p.left, p.lTag);
					DEC(p.rank);
					IF h THEN
						BalGE(p, h);
					END;
				ELSIF rank > p.rank THEN
					DEC(rank, p.rank);
					Supprime(FALSE, p.right, p.rTag);
					IF h THEN
						BalDE(p, h);
					END;
				ELSIF ~p.lTag THEN
					IF p.rTag THEN
						FixThreadL(p.right, p.left);
						p := p.right;
					ELSE
						IF l THEN
							p := p.left;
						ELSE
							p := p.right;
						END;
						t := FALSE;
					END;
					h := TRUE;
				ELSIF ~p.rTag THEN
					FixThreadR(p.left, p.right);
					p := p.left;
					h := TRUE;
				ELSE
					s := p;
					SupG(TRUE, s.left, s.lTag, p, h);
					p.left := s.left;
					p.lTag := s.lTag;
					p.right := s.right;
					p.rTag := s.rTag;
					p.bal := s.bal;
					p.rank := s.rank - 1;
					FixThreadL(p.right, p);
					IF h THEN
						BalGE(p, h);
					END;
				END;
			END Supprime;
		
		BEGIN (*Erase*)
			ASSERT(t.root # NIL, 20);
			Supprime(TRUE, t.root.left, t.root.lTag);
		END Erase;
	
	(* Returns the element following e in the tree t; if e= NIL, the first element is returned; if e is the last element of the tree, NIL is returned. *)
	PROCEDURE (t: Tree) Next* (e: Elem): Elem, NEW;
		
		VAR
			
			tag: BOOLEAN;
		
		BEGIN (*Next*)
			ASSERT(t.root # NIL, 20);
			IF e = NIL THEN
				e := t.root;
			END;
			tag := e.rTag;
			e := e.right;
			IF tag THEN
				WHILE e.lTag DO
					e := e.left;
				END;
			END;
			IF e = t.root THEN
				RETURN NIL;
			END;
			RETURN e;
		END Next;
	
	(* Returns the element preceding e in the tree t; if e= NIL, the last element is returned; if e is the first element of the tree, NIL is returned. *)
	PROCEDURE (t: Tree) Previous* (e: Elem): Elem, NEW;
		
		VAR
			
			tag: BOOLEAN;
		
		BEGIN (*Previous*)
			ASSERT(t.root # NIL, 20);
			IF e = NIL THEN
				e := t.root;
			END;
			tag := e.lTag;
			e := e.left;
			IF tag THEN
				WHILE e.rTag DO
					e := e.right;
				END;
			END;
			IF e = t.root THEN
				RETURN NIL;
			END;
			RETURN e;
		END Previous;
	
	END BabelAvl.
