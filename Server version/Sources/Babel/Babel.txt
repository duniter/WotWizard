(* 
Babel: a compiler compiler.

Copyright (C) 2001 Gérard Meunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*)

MODULE BabelBabel;
	
	
	
	(* The module BabelBabel is part of the Babel subsystem, a compiler compiler. BabelBabel is the user interface which calls the programming interface module BabelInterface to build a tbl file from a definition document *)
	
	IMPORT
		
		A := BabelAvl, I := BabelInterface, DevCommanders, DevMarkers, Dialog, Files, Fonts, Models, Ports, StdLinks, StdLog, Stores, Strings, TextControllers, TextMappers, TextModels, TextViews, Views;
	
	CONST
		
		sourcesPath = "Bab";
		sourcesType = ".odc";
		tablesPath = "Rsrc";
		tablesType = ".tbl";
		listType = "List.odc";
	
	TYPE
		
		Face = POINTER TO EXTENSIBLE RECORD (I.Face)
			f: TextMappers.Formatter;
			w: Stores.Writer;
			r: TextModels.Reader;
			err: A.Tree;
		END;
		
		FaceNoBatch = POINTER TO RECORD (Face)
		END;
		
		ErrElem = POINTER TO RECORD (A.Elem)
			pos: INTEGER;
			mark: DevMarkers.View;
		END;
	
	PROCEDURE (e1: ErrElem) Compare (e2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH e2: ErrElem DO
				IF e1.pos < e2.pos THEN
					RETURN A.inf;
				ELSIF e1.pos > e2.pos THEN
					RETURN A.sup;
				ELSIF e1.mark.msg$ < e2.mark.msg$ THEN
					RETURN A.inf;
				ELSIF e1.mark.msg$ > e2.mark.msg$ THEN
					RETURN A.sup;
				ELSE
					RETURN A.ega;
				END;
			END;
		END Compare;
	
	PROCEDURE (f: Face) Ln;
		
		BEGIN (*Ln*)
			f.f.WriteLn;
		END Ln;
	
	PROCEDURE (f: Face) String (IN s: ARRAY OF CHAR);
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*String*)
			FOR i := 0 TO LEN(s$) - 1 DO
				f.f.rider.WriteChar(s[i]);
			END;
		END String;
	
	PROCEDURE (f: Face) Map (IN index, p0, p1, p2: ARRAY OF CHAR): I.String;
		
		VAR
			
			s: Dialog.String;
			c: I.String;
		
		BEGIN (*Map*)
			Dialog.MapParamString("#Babel:" + index, p0, p1, p2, s);
			NEW(c, LEN(s$) + 1);
			c^ := s$;
			RETURN c;
		END Map;
	
	PROCEDURE (f: Face) BinInt (i: INTEGER);
		
		BEGIN (*BinInt*)
			f.w.WriteInt(i);
		END BinInt;
		
	PROCEDURE (f: Face) Read (OUT ch: CHAR);
		
		BEGIN (*Read*)
			f.r.Read;
			IF f.r.eot THEN
				ch := I.eOF1;
			ELSE
				ch := f.r.char;
			END;
		END Read;
	
	PROCEDURE (f: Face) Pos (): INTEGER;
		
		BEGIN (*Pos*)
			RETURN f.r.Pos();
		END Pos;
	
	PROCEDURE (f: Face) SetPos (pos: INTEGER);
		
		BEGIN (*SetPos*)
			IF pos <= f.r.Base().Length() THEN
				f.r.SetPos(pos);
			END;
		END SetPos;
	
	PROCEDURE (f: FaceNoBatch) Error (p, l, c: INTEGER; IN mes: ARRAY OF CHAR);
		
		VAR
			
			e: ErrElem;
			el: A.Elem;
			b: BOOLEAN;
			n: INTEGER;
		
		BEGIN (*Error*)
			IF f.err # NIL THEN
				NEW(e);
				e.pos := p - 1;
				e.mark := DevMarkers.dir.NewMsg(mes);
				el := e;
				b := f.err.SearchIns(el, n);
				ASSERT(~b);
			END;
		END Error;
	
	PROCEDURE DecompNom (IN nom, midPath: ARRAY OF CHAR; OUT path, name: Files.Name);
		
		VAR
			
			i: INTEGER;
		
		PROCEDURE Maj (c: CHAR): BOOLEAN;
			
			BEGIN (*Maj*)
				RETURN(c >= 'A') & (c <= 'Z') OR (c >= 'À') & (c <= 'Ö') OR (c >= 'Ø') & (c <= 'Þ');
			END Maj;
		
		BEGIN (*DecompNom*)
			i := 0;
			WHILE (nom[i] # 0X) & Maj(nom[i]) DO
				INC(i);
			END;
			WHILE (nom[i] # 0X) & ~Maj(nom[i]) DO
				INC(i);
			END;
			IF nom[i] = 0X THEN
				path := midPath$;
				name := nom$;
			ELSE
				Strings.Extract(nom, 0, i, path);
				path := path$ + "/" + midPath;
				Strings.Extract(nom, i, MAX(INTEGER), name);
			END;
		END DecompNom;
	
	PROCEDURE Compile1Text (t: TextModels.Model; batch: BOOLEAN): BOOLEAN;
		
		VAR
			
			tm: TextModels.Model;
			f: Face;
			fNB: FaceNoBatch;
			res1: BYTE;
			res2, beg, end: INTEGER;
			res: BOOLEAN;
			v: TextViews.View;
			loc: Files.Locator;
			nom: I.String;
			path, name: Files.Name;
			fi: Files.File;
			mes: Dialog.String;
			el: A.Elem;
			a: TextModels.Attributes;
			script: Stores.Operation;
		
		BEGIN (*Compile1Text*)
			res := TRUE;
			IF batch THEN
				NEW(f);
			ELSE
				NEW(fNB); f := fNB;
				DevMarkers.Unmark(t);
				A.New(f.err);
			END;
			f.r := t.NewReader(NIL);
			tm := TextModels.dir.New();
			f.f.ConnectTo(tm);
			res1 := f.CompComp(nom);
			IF ~batch THEN
				Models.BeginScript(t, "#Dev:InsertMarkers", script);
				el := f.err.Previous(NIL);
				WHILE el # NIL DO
					WITH el: ErrElem DO
						DevMarkers.Insert(t, el.pos, el.mark);
					END;
					el := f.err.Previous(el);
				END;
				Models.EndScript(t, script);
				DevMarkers.ShowFirstError(t, TRUE);
			END;
			IF nom # NIL THEN
				DecompNom(nom, tablesPath, path, name);
			END;
			IF res1 # I.errors THEN
				loc := Files.dir.This(path);
				res := loc.res = 0;
				IF res THEN
					fi := Files.dir.New(loc, Files.dontAsk);
					res := fi # NIL;
					IF res THEN
						f.w.ConnectTo(NIL);
						f.w.ConnectTo(fi);
						f.OutComp;
						fi.Register(name$ + tablesType, tablesType, Files.dontAsk, res2);
						res := res2 = 0;
					END;
				END;
				IF ~res THEN
					f.f.WriteLn;
					Dialog.MapString("#Babel:BNoCreate", mes);
					f.f.WriteString(mes);
					res1 := I.errors;
				END;
			END;
			IF tm.Length() > 0 THEN
				v := TextViews.dir.New(tm);
				IF batch THEN
					IF nom # NIL THEN
						IF loc = NIL THEN
							loc := Files.dir.This(path);
						END;
						Views.RegisterView(v, loc, name$ + listType);
					END;
				ELSE
					Views.OpenAux(v, nom$ + " List");
				END;
			END;
			CASE res1 OF
				|I.withoutDisp:
					Dialog.MapString("#Babel:BOk", mes);
				|I.remarks:
					Dialog.MapString("#Babel:BRem", mes);
				|I.warnings:
					Dialog.MapString("#Babel:BWarning", mes);
				|I.errors:
					Dialog.MapString("#Babel:BError", mes);
			END;
			StdLog.String(mes); StdLog.Ln;
			IF batch OR (res1 # I.errors) THEN
				Dialog.ShowStatus(mes);
			END;
			IF batch & (res1 # I.withoutDisp) & (nom # NIL) THEN
				StdLog.Tab; StdLog.Tab;
				StdLog.Msg("#Babel:BSee");
				StdLog.Char(' ');
				mes := path$ + "/" + name$ + listType;
				StdLog.View(StdLinks.dir.NewLink("StdCmds.OpenBrowser('" + mes$ + "','" + nom$ + " List')"));
				StdLog.String(mes);
				end := StdLog.text.Length(); beg := end - LEN(mes$);
				NEW(a); a.InitFromProp(StdLog.text.Prop(beg, end));
				a := TextModels.NewColor(TextModels.NewStyle(a, {Fonts.underline}), Ports.blue);
				StdLog.text.SetAttr(beg, end, a);
				StdLog.View(StdLinks.dir.NewLink(""));
				StdLog.Char('.');
				StdLog.Ln;
			END;
			RETURN res1 # I.errors;
		END Compile1Text;
	
	PROCEDURE Compile*;
		
		VAR
			
			t: TextModels.Model;
			b: BOOLEAN;
		
		BEGIN (*Compile*)
			t := TextViews.FocusText();
			IF t # NIL THEN
				StdLog.Msg("#Babel:BBabel"); StdLog.String(" ");
				b := Compile1Text(t, FALSE);
			END;
		END Compile;
	
	PROCEDURE Compile1Name (IN nom: ARRAY OF CHAR): BOOLEAN;
		
		VAR
			
			path, name: Files.Name;
			loc: Files.Locator;
			v: Views.View;
		
		BEGIN (*Compile1Name*)
			DecompNom(nom, sourcesPath, path, name);
			StdLog.Tab; StdLog.String(nom); StdLog.String(": ");
			loc := Files.dir.This(path);
			IF loc.res = 0 THEN
				v := Views.OldView(loc, name$ + sourcesType);
				IF (v # NIL) & (v IS TextViews.View) THEN
					RETURN Compile1Text(v(TextViews.View).ThisModel(), TRUE);
				END;
			END;
			StdLog.Msg("#Babel:BNotFound"); StdLog.Ln;
			RETURN FALSE;
		END Compile1Name;
	
	PROCEDURE CompileList*;
		
		VAR
			
			c: TextControllers.Controller;
			s: TextMappers.Scanner;
			beg, end: INTEGER;
		
		BEGIN (*CompileList*)
			c := TextControllers.Focus();
			IF (c # NIL) & c.HasSelection() THEN
				StdLog.Msg("#Babel:BBabel"); StdLog.Ln;
				c.GetSelection(beg, end);
				s.ConnectTo(c.text);
				s.SetPos(beg);
				s.Scan;
				WHILE (s.type = TextMappers.string) & (s.start < end) & Compile1Name(s.string) DO
					s.Scan;
				END;
			END;
		END CompileList;
	
	PROCEDURE CompileThis*;
		
		VAR
			
			s: TextMappers.Scanner;
		
		BEGIN (*CompileThis*)
			IF DevCommanders.par # NIL THEN
				StdLog.Msg("#Babel:BBabel"); StdLog.Ln;
				s.ConnectTo(DevCommanders.par.text);
				s.SetPos(DevCommanders.par.beg);
				s.Scan;
				WHILE (s.type = TextMappers.string) & (s.start < DevCommanders.par.end) & Compile1Name(s.string) DO
					s.Scan;
				END;
			END;
		END CompileThis;
	
	END BabelBabel.
