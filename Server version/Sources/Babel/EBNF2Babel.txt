(* 
Babel: a compiler compiler.

Copyright (C) 2001 Gérard Meunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*)

MODULE BabelEBNF2Babel;
	
	
	
	(* An EBNF3 to Babel translator *)
	
	IMPORT
		
		A := BabelAvl, B := BabelCompil, DevMarkers, Dialog, Files, Stores, Strings, TextControllers, TextMappers, TextModels, TextViews, Views;
	
	TYPE
		
		Directory = POINTER TO RECORD (B. Directory)
			r: Stores.Reader;
		END;
		
		Compilation = POINTER TO RECORD (B.Compilation)
			r: TextModels.Reader;
			fo: TextMappers.Formatter;
		END;
		
		Elem = POINTER TO RECORD (A.Elem)
			nom: B.String;
		END;
	
	VAR
		
		comp: B.Compiler;
	
	PROCEDURE (e1: Elem) Compare (e2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH e2: Elem DO
				IF e1.nom$ < e2.nom$ THEN
					RETURN A.inf;
				ELSIF e1.nom$ > e2.nom$ THEN
					RETURN A.sup;
				ELSE
					RETURN A.ega;
				END;
			END;
		END Compare;
	
	PROCEDURE (d: Directory) ReadInt (OUT i: INTEGER);
		
		BEGIN (*ReadInt*)
			d.r.ReadInt(i);
		END ReadInt;
	
	PROCEDURE (c: Compilation) Read (OUT ch: CHAR);
		
		BEGIN (*Read*)
			c.r.Read;
			IF c.r.eot THEN
				ch := B.eOF1;
			ELSE
				ch := c.r.char;
			END;
		END Read;
	
	PROCEDURE (c: Compilation) Pos (): INTEGER;
		
		BEGIN (*Pos*)
			RETURN c.r.Pos();
		END Pos;
	
	PROCEDURE (c: Compilation) SetPos (pos: INTEGER);
		
		BEGIN (*SetPos*)
			IF pos <= c.r.Base().Length() THEN
				c.r.SetPos(pos);
			END;
		END SetPos;
	
	PROCEDURE (c: Compilation) Map (IN index: ARRAY OF CHAR): B.String;
		
		VAR
			
			s: Dialog.String;
			ch: B.String;
		
		BEGIN (*Map*)
			Dialog.MapString("#Babel:" + index, s);
			NEW(ch, LEN(s$) + 1);
			ch^ := s$;
			RETURN ch;
		END Map;
	
	PROCEDURE (c: Compilation) Error (pos, line, col: INTEGER; IN msg: ARRAY OF CHAR);
		
		BEGIN (*Error*)
			DevMarkers.Insert(c.r.Base(), pos, DevMarkers.dir.NewMsg(msg));
		END Error;
	
	PROCEDURE (c: Compilation) Execution (fNum, parsNb: INTEGER; pars: B.ObjectsList; OUT o: B.Object; OUT res: ANYPTR): BOOLEAN;
		
		CONST
			
			nil = 1;
			follows = 2;
			append = 3;
			equal = 4;
			or = 5;
			perhaps = 6;
			repeat = 7;
			name = 8;
			string = 9;
			def = 10;
		
		TYPE
			
			Defs = POINTER TO RECORD
				next: Defs;
				nom, s: B.String;
			END;
			
			Items = POINTER TO RECORD
				next: Items;
				sort, n: INTEGER;
				s: B.String;
			END;
			
			Exprs = POINTER TO RECORD
				next: Exprs;
				expr: Items;
			END;
			
			Prods = POINTER TO RECORD
				next: Prods;
				nom: B.String;
				n: INTEGER;
				expr: Items;
			END;
		
		VAR
			
			prods: Prods;
			names, nonTerm, strings: A.Tree;
			defs, defQ: Defs;
			babelName: B.String;
		
		PROCEDURE Equal (nom: B.String; n: INTEGER; e: Exprs; r: Prods; OUT p: Prods);
			
			VAR
				
				q: Prods;
			
			BEGIN (*Equal*)
				NEW(p); q := p;
				WHILE e # NIL DO
					NEW(q.next); q := q.next;
					q.nom := nom;
					q.n := n;
					q.expr := e.expr;
					e := e.next;
				END;
				q.next := r;
				p := p.next;
			END Equal;
		
		PROCEDURE^ Expression (nom: B.String; VAR n: INTEGER; o: B.Object; OUT e: Exprs; OUT p: Prods);
		
		PROCEDURE Factor (only: BOOLEAN; nom: B.String; VAR n: INTEGER; o: B.Object; OUT i: Items; OUT p: Prods);
			
			VAR
				
				func, m: INTEGER;
				j: Items;
				e, f: Exprs;
				q, r, s: Prods;
			
			BEGIN (*Factor*)
				func := o.ObjFunc();
				CASE func OF
					|perhaps:
						m := n;
						Expression(nom, n, o.ObjTermSon(1), e, r);
						IF only THEN
							i := NIL;
							Equal(nom, m, e, r, p);
						ELSE
							INC(n);
							NEW(i);
							i.next := NIL;
							i.sort := name;
							i.s := nom;
							i.n := n;
							NEW(p);
							p.nom := nom;
							p.n := n;
							p.expr := NIL;
							Equal(nom, n, e, r, q);
							p.next := q;
						END;
					|repeat:
						m := n;
						Expression(nom, n, o.ObjTermSon(1), e, r);
						IF only THEN
							i := NIL;
							f := e;
							WHILE f # NIL DO
								NEW(j);
								j.sort := name;
								j.n := m;
								j.s := nom;
								j.next := f.expr;
								f.expr := j;
								f := f.next;
							END;
							Equal(nom, m, e, r, p);
						ELSE
							INC(n);
							NEW(i);
							i.next := NIL;
							i.sort := name;
							i.s := nom;
							i.n := n;
							NEW(p);
							p.nom := nom;
							p.n := n;
							p.expr := NIL;
							f := e;
							WHILE f # NIL DO
								NEW(j);
								j.sort := name;
								j.n := n;
								j.s := nom;
								j.next := f.expr;
								f.expr := j;
								f := f.next;
							END;
							Equal(nom, n, e, r, q);
							p.next := q;
						END;
					|name, string:
						NEW(i);
						i.next := NIL;
						i.sort := func;
						o := o.ObjTermSon(1);
						NEW(i.s, o.ObjStringLen() + 1);
						o.ObjString(i.s);
						i.n := 0;
						p := NIL;
					ELSE
						m := n;
						Expression(nom, n, o, e, r);
						IF e.next = NIL THEN
							i := e.expr;
							p := r;
						ELSIF only THEN
							i := e.expr;
							Equal(nom, m, e.next, r, p);
						ELSE
							INC(n);
							NEW(i);
							i.next := NIL;
							i.sort := name;
							i.s := nom;
							i.n := n;
							Equal(nom, n, e, r, p);
						END;
				END;
			END Factor;
		
		PROCEDURE Term (nom: B.String; VAR n: INTEGER; o: B.Object; OUT e: Exprs; OUT p: Prods);
			
			VAR
				
				i, j: Items;
				q, r: Prods;
				oo: B.Object;
				only: BOOLEAN;
			
			BEGIN (*Term*)
				only := TRUE;
				NEW(e);
				NEW(e.expr); i := e.expr;
				NEW(p); q := p;
				WHILE o.ObjFunc() = append DO
					oo := o.ObjTermSon(2);
					only := only & (oo.ObjFunc() # append);
					Factor(only, nom, n, o.ObjTermSon(1), j, r);
					i.next := j; 
					WHILE i.next # NIL DO
						i := i.next;
					END;
					q.next := r;
					WHILE q.next # NIL DO
						q := q.next;
					END;
					o := oo;
				END;
				ASSERT(o.ObjFunc() = nil);
				e.expr := e.expr.next;
				p := p.next;
			END Term;
		
		PROCEDURE Expression (nom: B.String; VAR n: INTEGER; o: B.Object; OUT e: Exprs; OUT p: Prods);
			
			VAR
				
				f, g: Exprs;
				q, r: Prods;
			
			BEGIN (*Expression*)
				NEW(e); f := e;
				NEW(p); q := p;
				WHILE o.ObjFunc() = or DO
					Term(nom, n, o.ObjTermSon(1), g, r);
					f.next := g;
					WHILE f.next # NIL DO
						f := f.next;
					END;
					q.next := r;
					WHILE q.next # NIL DO
						q := q.next;
					END;
					o := o.ObjTermSon(2);
				END;
				Term(nom, n, o, g, r);
				f.next := g;
				WHILE f.next # NIL DO
					f := f.next;
				END;
				q.next := r;
				WHILE q.next # NIL DO
					q := q.next;
				END;
				e := e.next;
				p := p.next;
			END Expression;
		
		PROCEDURE Prod (o: B.Object; OUT p: Prods);
			
			VAR
				
				nom: B.String;
				n: INTEGER;
				oo: B.Object;
				e: Exprs;
				q, r: Prods;
			
			BEGIN (*Prod*)
				oo := o.ObjTermSon(1);
				NEW(nom, oo.ObjStringLen() + 1);
				oo.ObjString(nom);
				IF o.ObjFunc() = equal THEN
					n := 0;
					Expression(nom, n, o.ObjTermSon(2), e, r);
					Equal(nom, 0, e, r, p);
				ELSE ASSERT(o.ObjFunc() = def);
					NEW(defQ.next); defQ := defQ.next;
					defQ.nom := nom;
					oo := o.ObjTermSon(2);
					NEW(defQ.s, oo.ObjStringLen() + 1);
					oo.ObjString(defQ.s);
					ASSERT(defQ.s[0] = "&");
					Strings.Extract(defQ.s, 1, LEN(defQ.s$) - 2, defQ.s);
					Strings.Find(defQ.s, "&&", 0, n);
					WHILE n >= 0 DO
						Strings.Replace(defQ.s, n, 1, "");
						Strings.Find(defQ.s, "&&", n + 1, n);
					END;
				END;
			END Prod;
		
		PROCEDURE Productions (o: B.Object; OUT p: Prods);
			
			VAR
				
				q, r: Prods;
			
			BEGIN (*Productions*)
				NEW(p); q := p;
				WHILE o.ObjFunc() = follows DO
					Prod(o.ObjTermSon(1), r);
					q.next := r;
					WHILE q.next # NIL DO
						q := q.next;
					END;
					o := o.ObjTermSon(2);
				END;
				ASSERT(o.ObjFunc() = nil);
				p := p.next;
				ASSERT(p # NIL); (* Pas d'axiome. À revoir : devrait donner une erreur pour l'utilisateur *)
			END Productions;
		
		PROCEDURE MakeName (nom: B.String; n: INTEGER): B.String;
			
			VAR
				
				s: B.String;
				num: ARRAY 12 OF CHAR;
			
			BEGIN (*MakeName*)
				IF n = 0 THEN
					RETURN nom;
				ELSE
					Strings.IntToString(n, num);
					NEW(s, LEN(num$) + LEN(nom$) + 2);
					s^ := nom$ + "_" + num$;
					RETURN s;
				END;
			END MakeName;
		
		PROCEDURE Parcours (p: Prods);
			
			VAR
				
				el: Elem;
				e: A.Elem;
				b: BOOLEAN;
				n: INTEGER;
				i: Items;
			
			BEGIN (*Parcours*)
				WHILE p # NIL DO
					p.nom := MakeName(p.nom, p.n);
					NEW(el);
					el.nom := p.nom;
					e := el;
					b := nonTerm.SearchIns(e, n);
					i := p.expr;
					WHILE i # NIL DO
						NEW(el);
						CASE i.sort OF
							|name:
								i.s := MakeName(i.s, i.n);
								el.nom := i.s;
								e := el;
								b := names.SearchIns(e, n);
							|string:
								el.nom := i.s;
								e := el;
								b := strings.SearchIns(e, n);
						END;
						i := i.next;
					END;
					p := p.next;
				END;
			END Parcours;
		
		PROCEDURE Ecris (p: Prods);
			
			CONST
				
				stringName = "string_";
			
			VAR
				
				el: Elem;
				e, e2: A.Elem;
				n, m: INTEGER;
				i: Items;
				q: Prods;
				ok, start: BOOLEAN;
				d: Defs;
			
			BEGIN (*Ecris*)
				c.fo.WriteString("BABEL "); c.fo.WriteString(babelName); c.fo.WriteChar(";"); c.fo.WriteLn;
				start := TRUE;
				d := defs;
				WHILE d.next # NIL DO
					NEW(el);
					el.nom := d.next.nom;
					e := el;
					IF names.Search(e, n) THEN
						IF ~nonTerm.Search(e, m) THEN
							names.Erase(n);
						END;
						d := d.next;
					ELSE
						IF start THEN
							start := FALSE;
							c.fo.WriteLn;
							c.fo.WriteString("DEFINITION"); c.fo.WriteLn;
							c.fo.WriteLn;
						END;
						c.fo.WriteString(d.next.nom);
						c.fo.WriteString(" = ");
						c.fo.WriteString(d.next.s);
						c.fo.WriteString(" ;");
						c.fo.WriteLn;
						d.next := d.next.next;
					END;
				END;
				c.fo.WriteLn;
				c.fo.WriteString("LEXICON"); c.fo.WriteLn;
				c.fo.WriteLn;
				c.fo.WriteString("spaces- = ([' ', #9, #2] | $)+ ;"); c.fo.WriteLn;
				c.fo.WriteLn;
				e := names.Next(NIL);
				WHILE e # NIL DO
					e2 := e;
					IF ~nonTerm.Search(e2, n) THEN
						WITH e: Elem DO
							c.fo.WriteString(e.nom);
							c.fo.WriteString(" = '");
							c.fo.WriteString(e.nom);
							c.fo.WriteString("' ;");
							c.fo.WriteLn;
						END;
					END;
					e := names.Next(e);
				END;
				c.fo.WriteLn;
				e := strings.Next(NIL); n := 0;
				WHILE e # NIL DO
					INC(n);
					c.fo.WriteString(stringName); c.fo.WriteInt(n);
					c.fo.WriteString(" = ");
					c.fo.WriteString(e(Elem).nom);
					c.fo.WriteString(" ;");
					c.fo.WriteLn;
					e := strings.Next(e);
				END;
				c.fo.WriteLn;
				defs := defs.next;
				WHILE defs # NIL DO
					c.fo.WriteString(defs.nom);
					c.fo.WriteString(" = ");
					c.fo.WriteString(defs.s);
					c.fo.WriteString(" ;");
					c.fo.WriteLn;
					defs := defs.next
				END;
				c.fo.WriteLn;
				c.fo.WriteString("DECLARATION"); c.fo.WriteLn;
				c.fo.WriteLn;
				e := nonTerm.Next(NIL);
				WHILE e # NIL DO
					c.fo.WriteChar("_"); c.fo.WriteString(e(Elem).nom);
					c.fo.WriteString(" ;");
					c.fo.WriteLn;
					e := nonTerm.Next(e);
				END;
				c.fo.WriteLn;
				c.fo.WriteString("GRAMMAR"); c.fo.WriteLn;
				c.fo.WriteLn;
				q := p;
				WHILE p # NIL DO
					c.fo.WriteChar("_"); c.fo.WriteString(p.nom);
					c.fo.WriteString(" = ");
					i := p.expr;
					WHILE i # NIL DO
						NEW(el);
						el.nom := i.s;
						e := el;
						CASE i.sort OF
							|name:
								IF nonTerm.Search(e, n) THEN
									c.fo.WriteChar("_");
								END;
								c.fo.WriteString(el.nom);
							|string:
								ok := strings.Search(e, n); ASSERT(ok);
								c.fo.WriteString(stringName); c.fo.WriteInt(n);
						END;
						c.fo.WriteChar(" ");
						i := i.next;
					END;
					c.fo.WriteChar(";");
					c.fo.WriteLn;
					p := p.next;
				END;
				c.fo.WriteLn;
				c.fo.WriteString("AXIOM"); c.fo.WriteLn;
				c.fo.WriteLn;
				c.fo.WriteChar("_"); c.fo.WriteString(q.nom);
				c.fo.WriteChar(".");
				c.fo.WriteLn;
			END Ecris;
		
		BEGIN (*Execution*)
			o := B.Parameter(pars, 1);
			NEW(babelName, o.ObjStringLen() + 1);
			o.ObjString(babelName);
			o := B.Parameter(pars, 2);
			NEW(defs); defQ := defs;
			Productions(o, prods);
			defQ.next := NIL;
			A.New(names);
			A.New(nonTerm);
			A.New(strings);
			Parcours(prods);
			Ecris(prods);
			res := NIL;
			RETURN TRUE;
		END Execution;
	
	PROCEDURE Init;
		
		VAR
			
			l: Files.Locator;
			f: Files.File;
			d: Directory;
		
		BEGIN (*Init*)
			l := Files.dir.This("Babel/Rsrc");
			ASSERT(l.res = 0);
			f := Files.dir.Old(l, "EBNF2Babel.tbl", Files.shared);
			ASSERT(f # NIL);
			NEW(d);
			d.r.ConnectTo(f);
			comp := d.ReadCompiler();
		END Init;
	
	PROCEDURE CompileText (in, out: TextModels.Model; beg: INTEGER): BOOLEAN;
		
		VAR
			
			co: Compilation;
		
		BEGIN (*CompileText*)
			NEW(co);
			co.r := in.NewReader(NIL);
			co.r.SetPos(beg);
			co.fo.ConnectTo(out);
			RETURN co.Compile(comp, TRUE);
		END CompileText;
	
	PROCEDURE Compile*;
		
		VAR
			
			c: TextControllers.Controller;
			beg, end: INTEGER;
			t: TextModels.Model;
		
		BEGIN (*Compile*)
			c := TextControllers.Focus();
			IF c # NIL THEN
				IF c.HasSelection() THEN
					c.GetSelection(beg, end);
					beg := MAX(beg - 1, 0);
				ELSE
					beg := 0;
				END;
				DevMarkers.Unmark(c.text);
				t := TextModels.dir.New();
				IF CompileText(c.text, t, beg) THEN
					Dialog.ShowStatus("#Babel:BOk");
					Views.OpenView(TextViews.dir.New(t));
				ELSE
					DevMarkers.ShowFirstError(c.text, TRUE);
				END;
			END;
		END Compile;
	
	BEGIN (*BabelEBNF2Babel*)
		Init;
	END BabelEBNF2Babel.

BabelEBNF2Babel.Compile;
