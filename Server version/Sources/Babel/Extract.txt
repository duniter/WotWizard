(* 
Babel: a compiler compiler.

Copyright (C) 2001 Gérard Meunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*)

MODULE BabelExtract;
	
	
	
	(* The module BabelExtract is part of the Babel subsystem, a compiler compiler. BabelExtract provides a converter which may be used to read the contents of tbl files. *)
	
	IMPORT
		
		Converters, Dialog, Files, Stores, TextMappers, TextModels, TextViews, Views;

	TYPE
		
		String = POINTER TO ARRAY OF CHAR;
		
		(* Definitions for the lexical analyzer *)
		
		TokLex = RECORD (* A token *)
			nom: String;
			utile,
			valUt: BOOLEAN;
		END;
		
		ToksLex = POINTER TO ARRAY OF TokLex;
		
		GotoLex = POINTER TO ABSTRACT RECORD
			goto: INTEGER;
		END;
		
		GotoLexC = POINTER TO RECORD (GotoLex)
			premCar,
			derCar: CHAR;
		END;
		
		GotoLexT = POINTER TO RECORD (GotoLex)
			transit: INTEGER;
		END;
		
		TransLex = POINTER TO ARRAY OF GotoLex;
		
		Card = POINTER TO ARRAY OF INTEGER;
		
		EtatLex = RECORD
			recon,
			nbTrans,
			nbEps: INTEGER;
			transL: TransLex;
		END;
		
		EtatsLex = POINTER TO ARRAY OF EtatLex;
		
	(* Definitions for the parser *)
	
	CONST
		
		deplaceS = 0;
		reduitS = 1;
		accepteS = 2;
		erreurS = 3;
	
	TYPE
		
		ActionS = RECORD
			quoi: BYTE;
			premTerm,
			derTerm,
			aux: INTEGER;
		END;
		
		ActSynt = POINTER TO ARRAY OF ActionS;
		
		ActionSynt = RECORD
			nbT: INTEGER;
			actions: ActSynt;
		END;
		
		ActionsSynt = POINTER TO ARRAY OF ActionSynt;
		
		GtS = RECORD
			depart,
			arrivee: INTEGER;
		END;
		
		GotoS = POINTER TO ARRAY OF GtS;
		
		GotoSynt = RECORD
			nbAtts: INTEGER;
			typsAt: Card;
			nbE: INTEGER;
			gotos: GotoS;
		END;
		
		GotosSynt = POINTER TO ARRAY OF GotoSynt;
		
		(* Definitions for the semantic analyser *)
		
		Param = RECORD
			profD,
			attD: INTEGER;
		END;
		
		Params = POINTER TO ARRAY OF Param;
		
		ActionSem = RECORD
			sOrH: BOOLEAN;
			profG,
			attG,
			fonc,
			nbPars: INTEGER;
			pars: Params;
		END;
		
		ActionsSem = POINTER TO ARRAY OF ActionSem;
		
		RegleSynt = RECORD
			longueur,
			nonTerm,
			nbAct: INTEGER;
			act: ActionsSem;
		END;
		
		ReglesSynt = POINTER TO ARRAY OF RegleSynt;
		
		RecEtat = RECORD
			etatDep,
			nTGoto: INTEGER;
		END;
		
		RecEtats = POINTER TO ARRAY OF RecEtat;
		
		RecTerm = RECORD
			numTerm,
			nbEtats: INTEGER;
			recEtat: RecEtats;
		END;
		
		RecTerms = POINTER TO ARRAY OF RecTerm;
		
		Compilateur = POINTER TO RECORD (* A compiler *)
			nbToksLex: INTEGER;
			toksLex: ToksLex;
			nbEtatsLex,
			profEtatsL: INTEGER;
			etatsLex: EtatsLex;
			nbEtatsCom,
			profEtatsC: INTEGER;
			etatsCom: EtatsLex;
			nbEtatsSynt: INTEGER;
			actionSynt: ActionsSynt;
			nbNonTSynt: INTEGER;
			gotoSynt: GotosSynt;
			nbRegleSynt: INTEGER;
			regleSynt: ReglesSynt;
			nbRecTerms: INTEGER;
			recTerms: RecTerms;
		END;
	
	PROCEDURE LisCompilateur (rd: Stores.Reader): Compilateur;
		
		(* Reading of compiler tables in the f '.tbl' file *)
		
		CONST
			
			eOS = 0X;
		
		VAR
			
			c: Compilateur;
			t: ToksLex;
			a: ActSynt;
			ca: Card;
			g: GotoS;
			aS: ActionsSem;
			p: Params;
			r: RecEtats;
			i, j, m, k: INTEGER;
		
		PROCEDURE ReadInt (OUT i: INTEGER);
			
			BEGIN (*ReadInt*)
				rd.ReadInt(i);
			END ReadInt;
		
		PROCEDURE ReadByte (OUT b: BYTE);
			
			VAR
				
				i: INTEGER;
			
			BEGIN (*ReadByte*)
				ReadInt(i);
				b := SHORT(SHORT(i));
			END ReadByte;
		
		PROCEDURE ReadBool (OUT b: BOOLEAN);
			
			VAR
				
				i: INTEGER;
			
			BEGIN (*ReadBool*)
				ReadInt(i);
				ASSERT((i = 0) OR (i = 1));
				b := i = 1;
			END ReadBool;
		
		PROCEDURE ReadChar (OUT c: CHAR);
			
			VAR
				
				i: INTEGER;
			
			BEGIN (*ReadChar*)
				ReadInt(i);
				c := CHR(i);
			END ReadChar;
	
	PROCEDURE ReadString (OUT s: ARRAY OF CHAR);
		
		VAR
			
			n: INTEGER;
			c: CHAR;
		
		BEGIN (*ReadString*)
			n := 0;
			ReadChar(c);
			WHILE c # eOS DO
				s[n] := c;
				INC(n);
				ReadChar(c);
			END;
		END ReadString;
	
		PROCEDURE LisEtatsRedLex (nE: INTEGER; OUT eL: EtatsLex);
			
			VAR
				
				i, j: INTEGER;
				t: TransLex;
				gC: GotoLexC;
				gT: GotoLexT;
			
			BEGIN (*LisEtatsRedLex*)
				NEW(eL, nE);
				FOR i := 0 TO nE-1 DO
					ReadInt(eL[i].recon);
					ReadInt(eL[i].nbTrans);
					ReadInt(eL[i].nbEps);
				END;
				FOR i := 0 TO nE-1 DO
					IF eL[i].nbTrans > 0 THEN
						NEW(t, eL[i].nbTrans);
						FOR j := 0 TO eL[i].nbEps - 1 DO
							NEW(gT);
							ReadInt(gT.goto);
							ReadInt(gT.transit);
							t[j] := gT;
						END;
						FOR j := eL[i].nbEps TO eL[i].nbTrans - 1 DO
							NEW(gC);
							ReadInt(gC.goto);
							ReadChar(gC.premCar);
							ReadChar(gC.derCar);
							t[j] := gC;
						END;
						eL[i].transL := t;
					END;
				END;
			END LisEtatsRedLex;
		
		BEGIN (*LisCompilateur*)
			NEW(c);
			ReadInt(c.nbToksLex);
			ReadInt(c.nbEtatsLex);
			ReadInt(c.profEtatsL);
			ReadInt(c.nbEtatsCom);
			ReadInt(c.profEtatsC);
			ReadInt(c.nbEtatsSynt);
			ReadInt(c.nbNonTSynt);
			ReadInt(c.nbRegleSynt);
			ReadInt(c.nbRecTerms);
			NEW(t, c.nbToksLex);
			FOR i := 0 TO c.nbToksLex - 1 DO
				ReadBool(t[i].utile);
				ReadBool(t[i].valUt);
			END;
			FOR i := 0 TO c.nbToksLex - 1 DO
				ReadInt(k);
				IF k # 0 THEN
					NEW(t[i].nom, k);
					ReadString(t[i].nom);
				END;
			END;
			c.toksLex := t;
			LisEtatsRedLex(c.nbEtatsLex, c.etatsLex);
			LisEtatsRedLex(c.nbEtatsCom, c.etatsCom);
			NEW(c.actionSynt, c.nbEtatsSynt);
			FOR i := 0 TO c.nbEtatsSynt - 1 DO
				ReadInt(c.actionSynt[i].nbT);
			END;
			FOR i := 0 TO c.nbEtatsSynt - 1 DO
				NEW(a, c.actionSynt[i].nbT);
				FOR j := 0 TO c.actionSynt[i].nbT - 1 DO
					ReadByte(a[j].quoi);
					ReadInt(a[j].premTerm);
					ReadInt(a[j].derTerm);
					ReadInt(a[j].aux);
				END;
				c.actionSynt[i].actions := a;
			END;
			NEW(c.gotoSynt, c.nbNonTSynt);
			FOR i := 0 TO c.nbNonTSynt - 1 DO
				ReadInt(c.gotoSynt[i].nbAtts);
				ReadInt(c.gotoSynt[i].nbE);
			END;
			FOR i := 0 TO c.nbNonTSynt - 1 DO
				IF c.gotoSynt[i].nbAtts > 0 THEN
					NEW(ca, c.gotoSynt[i].nbAtts);
					FOR j := 0 TO c.gotoSynt[i].nbAtts - 1 DO
						ReadInt(ca[j]);
					END;
					c.gotoSynt[i].typsAt := ca;
				END;
				IF c.gotoSynt[i].nbE > 0 THEN
					NEW(g, c.gotoSynt[i].nbE);
					FOR j := 0 TO c.gotoSynt[i].nbE-1 DO
						ReadInt(g[j].depart);
						ReadInt(g[j].arrivee);
					END;
					c.gotoSynt[i].gotos := g;
				END;
			END;
			NEW(c.regleSynt, c.nbRegleSynt);
			FOR i := 0 TO c.nbRegleSynt - 1 DO
				ReadInt(c.regleSynt[i].longueur);
				ReadInt(c.regleSynt[i].nonTerm);
				ReadInt(c.regleSynt[i].nbAct);
			END;
			FOR i := 0 TO c.nbRegleSynt - 1 DO
				IF c.regleSynt[i].nbAct > 0 THEN
					NEW(aS, c.regleSynt[i].nbAct);
					FOR j := 0 TO c.regleSynt[i].nbAct - 1 DO
						ReadBool(aS[j].sOrH);
						ReadInt(aS[j].profG);
						ReadInt(aS[j].attG);
						ReadInt(aS[j].fonc);
						ReadInt(aS[j].nbPars);
					END;
					FOR j := 0 TO c.regleSynt[i].nbAct - 1 DO
						IF aS[j].nbPars > 0 THEN
							NEW(p, aS[j].nbPars);
							FOR m := 0 TO aS[j].nbPars - 1 DO
								ReadInt(p[m].profD);
								ReadInt(p[m].attD);
							END;
							aS[j].pars := p;
						END;
					END;
					c.regleSynt[i].act := aS;
				END;
			END;
			IF c.nbRecTerms > 0 THEN
				NEW(c.recTerms, c.nbRecTerms);
				FOR i := 0 TO c.nbRecTerms - 1 DO
					ReadInt(c.recTerms[i].numTerm);
					ReadInt(c.recTerms[i].nbEtats);
				END;
				FOR i := 0 TO c.nbRecTerms - 1 DO
					NEW(r, c.recTerms[i].nbEtats);
					FOR j := 0 TO c.recTerms[i].nbEtats - 1 DO
						ReadInt(r[j].etatDep);
						ReadInt(r[j].nTGoto);
					END;
					c.recTerms[i].recEtat := r;
				END;
			END;
			RETURN c;
		END LisCompilateur;
	
	PROCEDURE EcrisCompilateur (c: Compilateur; VAR f: TextMappers.Formatter);
		
		VAR
			
			i, j, k: INTEGER;
			
			rien,
			sansNom,
			utile,
			inutile,
			valeurU,
			valeurNonU,
			copie,
			douce,
			dure: Dialog.String;
		
		PROCEDURE EcrisEtatsRedLex (nT, nE, pE: INTEGER; eL: EtatsLex; nN, pN, lN: ARRAY OF CHAR);
			
			VAR
				
				i, j: INTEGER;
			
			PROCEDURE WriteChar (x: CHAR);
				
				BEGIN (*WriteChar*)
					f.WriteChar(x);
					IF (x >= " ") & (x # 7FX) THEN
						f.WriteString(" (");
						f.WriteIntForm(ORD(x), 10H, 0, " ", FALSE);
						f.WriteString("X)");
					END;
				END WriteChar;
			
			BEGIN (*EcrisEtatsRedLex*)
				f.WriteString(nN); f.WriteString(' = '); f.WriteInt(nE); f.WriteLn;
				f.WriteString(pN); f.WriteString(' = '); f.WriteInt(pE); f.WriteLn;
				FOR i := 0 TO nE-1 DO
					f.WriteTab; f.WriteString(lN); f.WriteString(' '); f.WriteInt(i); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteString('recon = ');
					IF eL[i].recon < nT THEN
						f.WriteInt(eL[i].recon);
					ELSE
						f.WriteString(rien);
					END;
					f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteString('nbTrans = '); f.WriteInt(eL[i].nbTrans); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteString('nbEps = '); f.WriteInt(eL[i].nbEps); f.WriteLn;
					FOR j := 1 TO eL[i].nbEps DO
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('transL '); f.WriteInt(j - 1); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('goto = '); f.WriteInt(eL[i].transL[j - 1].goto); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('transit = '); f.WriteInt(eL[i].transL[j - 1](GotoLexT).transit); f.WriteLn;
					END;
					FOR j := eL[i].nbEps + 1 TO eL[i].nbTrans DO
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('transL '); f.WriteInt(j - 1); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('goto = '); f.WriteInt(eL[i].transL[j - 1].goto); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('premCar = '); WriteChar(eL[i].transL[j - 1](GotoLexC).premCar); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('derCar = '); WriteChar(eL[i].transL[j - 1](GotoLexC).derCar); f.WriteLn;
					END;
				END;
			END EcrisEtatsRedLex;
		
		BEGIN (*EcrisCompilateur*)
			Dialog.MapString("#Babel:ENothing", rien);
			Dialog.MapString("#Babel:Eunnamed", sansNom);
			Dialog.MapString("#Babel:Eused", utile);
			Dialog.MapString("#Babel:Eunused", inutile);
			Dialog.MapString("#Babel:EusedVal", valeurU);
			Dialog.MapString("#Babel:EunusedVal", valeurNonU);
			Dialog.MapString("#Babel:Ecopy", copie);
			Dialog.MapString("#Babel:Esoft", douce);
			Dialog.MapString("#Babel:Ehard", dure);
			f.WriteString('nbToksLex = '); f.WriteInt(c.nbToksLex); f.WriteLn;
			FOR i := 0 TO c.nbToksLex - 1 DO
				f.WriteTab; f.WriteString('toksLex '); f.WriteInt(i); f.WriteLn;
				f.WriteTab; f.WriteTab; 
				IF c.toksLex[i].nom = NIL THEN
					f.WriteString(sansNom);
				ELSE
					f.WriteString(c.toksLex[i].nom);
				END;
				f.WriteLn;
				f.WriteTab; f.WriteTab; 
				IF c.toksLex[i].utile THEN
					f.WriteString(utile);
				ELSE
					f.WriteString(inutile);
				END;
				f.WriteLn;
				f.WriteTab; f.WriteTab;
				IF c.toksLex[i].valUt THEN
					f.WriteString(valeurU);
				ELSE
					f.WriteString(valeurNonU);
				END;
				f.WriteLn;
			END;
			EcrisEtatsRedLex(c.nbToksLex, c.nbEtatsLex, c.profEtatsL, c.etatsLex, 'nbEtatsLex', 'profEtatsL', 'etatsLex');
			EcrisEtatsRedLex(3, c.nbEtatsCom, c.profEtatsC, c.etatsCom, 'nbEtatsCom', 'profEtatsC', 'etatsCom');
			f.WriteString('nbEtatsSynt = '); f.WriteInt(c.nbEtatsSynt); f.WriteLn;
			FOR i := 0 TO c.nbEtatsSynt - 1 DO
				f.WriteTab; f.WriteString('actionSynt '); f.WriteInt(i); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('nbT = '); f.WriteInt(c.actionSynt[i].nbT); f.WriteLn;
				FOR j := 0 TO c.actionSynt[i].nbT - 1 DO
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('actions '); f.WriteInt(j + 1); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('quoi = ');
					CASE c.actionSynt[i].actions[j].quoi OF
						|deplaceS:
							 f.WriteString('deplaceS'); f.WriteLn;
							 f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('aux = '); f.WriteInt(c.actionSynt[i].actions[j].aux); f.WriteLn;
						|reduitS:
							 f.WriteString('reduitS'); f.WriteLn;
							 f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('aux = '); f.WriteInt(c.actionSynt[i].actions[j].aux); f.WriteLn;
						|accepteS:
							 f.WriteString('accepteS'); f.WriteLn;
						|erreurS:
							 f.WriteString('erreurS'); f.WriteLn;
					END;
					IF j < c.actionSynt[i].nbT - 1 THEN
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('premTerm = '); f.WriteInt(c.actionSynt[i].actions[j].premTerm); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('derTerm = '); f.WriteInt(c.actionSynt[i].actions[j].derTerm); f.WriteLn;
					END;
				END;
			END;
			f.WriteString('nbNonTSynt = '); f.WriteInt(c.nbNonTSynt); f.WriteLn;
			FOR i := 0 TO c.nbNonTSynt - 1 DO
				f.WriteTab; f.WriteString('gotoSynt '); f.WriteInt(i); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('nbAtts = '); f.WriteInt(c.gotoSynt[i].nbAtts); f.WriteLn;
				FOR j := 0 TO c.gotoSynt[i].nbAtts - 1 DO
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('typsAt '); f.WriteInt(j + 1); f.WriteString(' = '); f.WriteInt(c.gotoSynt[i].typsAt[j]); f.WriteLn;
				END;
				f.WriteTab; f.WriteTab; f.WriteString('nbE = '); f.WriteInt(c.gotoSynt[i].nbE); f.WriteLn;
				FOR j := 0 TO c.gotoSynt[i].nbE- 1 DO
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('gotos '); f.WriteInt(j + 1); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('depart = '); f.WriteInt(c.gotoSynt[i].gotos[j].depart); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('arrivee = '); f.WriteInt(c.gotoSynt[i].gotos[j].arrivee); f.WriteLn;
				END;
			END;
			f.WriteString('nbRegleSynt = '); f.WriteInt(c.nbRegleSynt); f.WriteLn;
			FOR i := 0 TO c.nbRegleSynt - 1 DO
				f.WriteTab; f.WriteString('regleSynt '); f.WriteInt(i); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('longueur = '); f.WriteInt(c.regleSynt[i].longueur); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('nonTerm = '); f.WriteInt(c.regleSynt[i].nonTerm); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('nbAct = '); f.WriteInt(c.regleSynt[i].nbAct); f.WriteLn;
				FOR j := 0 TO c.regleSynt[i].nbAct - 1 DO
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('act '); f.WriteInt(j + 1); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; 
					IF c.regleSynt[i].act[j].sOrH THEN
						IF c.regleSynt[i].act[j].fonc = 0 THEN
							f.WriteString(copie);
						ELSE
							f.WriteString(douce);
						END;
					ELSE
						f.WriteString(dure);
					END;
					f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('profG = '); f.WriteInt(c.regleSynt[i].act[j].profG); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('attG = '); f.WriteInt(c.regleSynt[i].act[j].attG); f.WriteLn;
					IF c.regleSynt[i].act[j].fonc > 0 THEN
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('fonc = '); f.WriteInt(c.regleSynt[i].act[j].fonc); f.WriteLn;
					END;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('nbPars = '); f.WriteInt(c.regleSynt[i].act[j].nbPars); f.WriteLn;
					FOR k := 0 TO c.regleSynt[i].act[j].nbPars - 1 DO
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('pars '); f.WriteInt(k + 1); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('profD = '); f.WriteInt(c.regleSynt[i].act[j].pars[k].profD); f.WriteLn;
						f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('attD = '); f.WriteInt(c.regleSynt[i].act[j].pars[k].attD); f.WriteLn;
					END;
				END;
			END;
			f.WriteString('nbRecTerms = '); f.WriteInt(c.nbRecTerms); f.WriteLn;
			FOR i := 0 TO c.nbRecTerms - 1 DO
				f.WriteTab; f.WriteString('recTerms '); f.WriteInt(i + 1); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('numTerm = '); f.WriteInt(c.recTerms[i].numTerm); f.WriteLn;
				f.WriteTab; f.WriteTab; f.WriteString('nbEtats = '); f.WriteInt(c.recTerms[i].nbEtats); f.WriteLn;
				FOR j := 0 TO c.recTerms[i].nbEtats - 1 DO
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('recEtat '); f.WriteInt(j + 1); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('etatDep = '); f.WriteInt(c.recTerms[i].recEtat[j].etatDep); f.WriteLn;
					f.WriteTab; f.WriteTab; f.WriteTab; f.WriteTab; f.WriteString('nTGoto = '); f.WriteInt(c.recTerms[i].recEtat[j].nTGoto); f.WriteLn;
				END;
			END;
		END EcrisCompilateur;
	
	PROCEDURE Do*;
		
		(* Extracts the content of a tbl file *)
		
		VAR
			
			loc: Files.Locator;
			name: Files.Name;
			fi: Files.File;
			rd: Stores.Reader;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			v: TextViews.View;
			c: Compilateur;
		
		BEGIN (*Do*)
			Dialog.GetIntSpec('tbl', loc, name);
			IF loc # NIL THEN
				fi := Files.dir.Old(loc, name, Files.shared);
				IF fi # NIL THEN
					rd.ConnectTo(fi);
					c := LisCompilateur(rd);
					t := TextModels.dir.New();
					f.ConnectTo(t);
					EcrisCompilateur(c, f);
					v := TextViews.dir.New(t);
					Views.OpenView(v);
				END;
			END;
		END Do;
	
	PROCEDURE ImportTbl* (fi: Files.File; OUT s: Stores.Store);
		
		VAR
			
			rd: Stores.Reader;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			c: Compilateur;
		
		BEGIN (*ImportTbl*)
			ASSERT(fi # NIL, 20); ASSERT(fi.type = 'tbl', 21);
			rd.ConnectTo(fi);
			c := LisCompilateur(rd);
			t := TextModels.dir.New();
			f.ConnectTo(t);
			EcrisCompilateur(c, f);
			s := TextViews.dir.New(t);
		END ImportTbl;
	
	PROCEDURE Install*;
		
		(* Installs a converter which can read the content of a tbl file. *)
		
		BEGIN (*Install*)
			Converters.Register("BabelExtract.ImportTbl", "", "TextViews.View", "tbl", {});
		END Install;

	END BabelExtract.

BabelExtract.Do;
BabelExtract.Install;
