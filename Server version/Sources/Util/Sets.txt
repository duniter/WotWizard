(* 
Util: Utility tools.

Copyright (C) 2001…2018 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE UtilSets;
	
	
	
	(* The module UtilSets implements the type Set, a set of integers. *)
	
	CONST
		
		loadFactor = 0.8;
	
	TYPE
		
		Elem = POINTER TO RECORD
			next: Elem;
			val: INTEGER;
		END;
		
		(* Set of non-negative integers. *)
		Set* = POINTER TO LIMITED RECORD
			size, nbElems-: INTEGER; 
			present: POINTER TO ARRAY OF INTEGER;
			elems: Elem;
		END;
		
		SetIterator* = RECORD
			s: Set;
			cour: Elem;
		END;

	VAR

		add, next: ARRAY 11 OF INTEGER;

	PROCEDURE CalcNextPrime (n: INTEGER): INTEGER;

		VAR

			i, p, j: INTEGER;

		BEGIN (*CalcNextPrime*)
			IF n < 2 THEN
				RETURN 2;
			ELSIF n < 7 THEN
				i := 8;
				p := n - 2;
				n := 2;
			ELSE
				i := 0;
				p := (n - 7) MOD 30;
				n := 7 + (n - 7) DIV 30 * 30;
			END;
			j := 0;
			WHILE p >= j DO
				INC(j, add[i]);
				i := next[i];
			END;
			INC(n, j);
			p := 7; j := 0;
			WHILE p * p <= n DO
				IF n MOD p = 0 THEN
					INC(n, add[i]);
					i := next[i];
					p := 7; j := 0;
				ELSE
					INC(p, add[j]);
					j := next[j];
				END;
			END;
			RETURN n;
		END CalcNextPrime;

	(* Creates and returns a new empty set. *)
	PROCEDURE New (size: INTEGER): Set;
		
		VAR
			
			s: Set;
			i: INTEGER;
		
		BEGIN (*New*)
			NEW(s);
			s.size := CalcNextPrime(size);
			s.nbElems := 0;
			NEW(s.present, s.size);
			FOR i := 0 TO s.size - 1 DO
				s.present[i] := MAX(INTEGER);
			END;
			s.elems := NIL;
			RETURN s;
		END New;

	(* Creates and returns a new empty set. *)
	PROCEDURE NewSet* (): Set;
		
		CONST
			
			firstSize = 100H;
		
		BEGIN (*NewSet*)
			RETURN New(firstSize);
		END NewSet;
	
	PROCEDURE ^ Increase (s: Set);
	
	(* Includes the integer e in the set s.*)
	PROCEDURE (s: Set) Incl* (e: INTEGER), NEW;
		
		VAR
			
			h, c: INTEGER;
			el: Elem;
		
		BEGIN (*Incl*)
			h := e MOD s.size;
			IF (s.present[h] # MAX(INTEGER)) & (s.present[h] # e) THEN
				c := e MOD (s.size - 1) + 1;
				REPEAT
					DEC(h, c);
					IF h < 0 THEN
						INC(h, s.size);
					END;
				UNTIL (s.present[h] = MAX(INTEGER)) OR (s.present[h] = e);
			END;
			IF s.present[h] = e THEN
				RETURN;
			END;
			s.present[h] := e;
			INC(s.nbElems);
			NEW(el);
			el.next := s.elems;
			el.val := e;
			s.elems := el;
			IF s.nbElems / s.size > loadFactor THEN
				Increase(s);
			END;
		END Incl;
	
	PROCEDURE Increase (s: Set);
		
		VAR
			
			e: Elem;
			ss: Set;
		
		BEGIN (*Increase*)
			ss := New(2 * s.size);
			e := s.elems;
			WHILE e # NIL DO
				ss.Incl(e.val);
				e := e.next;
			END;
			s.size := ss.size;
			s.present := ss.present;
		END Increase;
	
	(* Tests whether the integer e is in the set s. *)
	PROCEDURE (s: Set) In* (e: INTEGER): BOOLEAN, NEW;
		
		VAR
			
			h, c: INTEGER;
		
		BEGIN (*In*)
			h := e MOD s.size;
			IF (s.present[h] # MAX(INTEGER)) & (s.present[h] # e) THEN
				c := e MOD (s.size - 1) + 1;
				REPEAT
					DEC(h, c);
					IF h < 0 THEN
						INC(h, s.size);
					END;
				UNTIL (s.present[h] = MAX(INTEGER)) OR (s.present[h] = e);
			END;
			RETURN s.present[h] = e;
		END In;
	
	(* Sets s to the interval min..max. *)
	PROCEDURE Interval* (min, max: INTEGER): Set;
		
		VAR
			
			s: Set;
			e: INTEGER;

		BEGIN (*Interval*)
			s := NewSet();
			IF min <= max THEN
				FOR e := min TO max DO
					s.Incl(e);
				END;
			END;
			RETURN s;
		END Interval;
	
	(* Tests whether s is empty. *)
	PROCEDURE (s: Set) IsEmpty* (): BOOLEAN, NEW;

		BEGIN (*IsEmpty*)
			RETURN s.nbElems = 0;
		END IsEmpty;
	
	(* Creates and returns a copy of s.*)
	PROCEDURE (s: Set) Copy* (): Set, NEW;

		VAR

			f: Set;
			e: INTEGER;
			es, ef, eff: Elem;

		BEGIN (*Copy*)
			f := NewSet();
			f.size := s.size;
			f.nbElems := s.nbElems;
			NEW(f.present, f.size);
			FOR e := 0 TO f.size - 1 DO
				f.present[e] := s.present[e];
			END;
			NEW(ef); eff := ef;
			es := s.elems;
			WHILE es # NIL DO
				NEW(ef.next); ef := ef.next;
				ef.val := es.val;
				es := es.next;
			END;
			ef.next := NIL;
			f.elems := eff.next;
			RETURN f;
		END Copy;
	
	(* Returns in s1 the union of s1 and s2; much more efficient than Union. *)
	PROCEDURE (s1: Set) Add* (s2: Set), NEW;
		
		VAR
			
			el: Elem;
		
		BEGIN (*Add*)
			ASSERT(s2 # NIL, 20);
			el := s2.elems;
			WHILE el # NIL DO
				s1.Incl(el.val);
				el := el.next;
			END;
		END Add;
	
	(* Returns the union of s1 and s2. *)
	PROCEDURE (s1: Set) Union* (s2: Set): Set, NEW;
		
		VAR
			
			s: Set;
		
		BEGIN (*Union*)
			ASSERT(s2 # NIL, 20);
			IF s1.nbElems < s2.nbElems THEN
				s := s1; s1 := s2; s2 := s;
			END;
			s := s1.Copy();
			s.Add(s2);
			RETURN s;
		END Union;
	
	(* Returns the intersection of s1 and s2. *)
	PROCEDURE (s1: Set) Inter* (s2: Set): Set, NEW;
		
		VAR
			
			s: Set;
			el: Elem;
		
		BEGIN (*Inter*)
			ASSERT(s2 # NIL, 20);
			IF s1.nbElems > s2.nbElems THEN
				s := s1; s1 := s2; s2 := s;
			END;
			s := NewSet();
			el := s1.elems;
			WHILE el # NIL DO
				IF s2.In(el.val) THEN
					s.Incl(el.val);
				END;
				el := el.next;
			END;
			RETURN s;
		END Inter;
	
	(* Returns the difference between s1 and s2. *)
	PROCEDURE (s1: Set) Diff* (s2: Set): Set, NEW;
		
		VAR
			
			s: Set;
			el: Elem;
		
		BEGIN (*Diff*)
			ASSERT(s2 # NIL, 20);
			s := NewSet();
			el := s1.elems;
			WHILE el # NIL DO
				IF ~s2.In(el.val) THEN
					s.Incl(el.val);
				END;
				el := el.next;
			END;
			RETURN s;
		END Diff;
	
	(* Returns the exclusive union of s1 and s2. *)
	PROCEDURE (s1: Set) XOR* (s2: Set): Set, NEW;
		
		VAR
			
			s: Set;
			el: Elem;
		
		BEGIN (*XOR*)
			ASSERT(s2 # NIL, 20);
			s := NewSet();
			el := s1.elems;
			WHILE el # NIL DO
				IF ~s2.In(el.val) THEN
					s.Incl(el.val);
				END;
				el := el.next;
			END;
			el := s2.elems;
			WHILE el # NIL DO
				IF ~s1.In(el.val) THEN
					s.Incl(el.val);
				END;
				el := el.next;
			END;
			RETURN s;
		END XOR;
	
	(* Adds the interval min..max to the set s. *)
	PROCEDURE (s: Set) Flood* (min, max: INTEGER), NEW;
		
		BEGIN (*Flood*)
			s.Add(Interval(min, max));
		END Flood;
	
	(* Adds the interval min..max to the set s. *)
	PROCEDURE (s: Set) Fill* (min, max: INTEGER): Set, NEW;
		
		BEGIN (*Fill*)
			RETURN s.Union(Interval(min, max));
		END Fill;
	
	(* Removes the interval min..max from the set s. *)
	PROCEDURE (s: Set) Clear* (min, max: INTEGER): Set, NEW;
		
		BEGIN (*Clear*)
			RETURN s.Diff(Interval(min, max));
		END Clear;
	
	(* Sets s to the Component Pascal SET se. *)
	PROCEDURE Small* (se: SET): Set;
		
		VAR
			
			s: Set;
			e: INTEGER;
		
		BEGIN (*Small*)
			s := NewSet();
			FOR e := MIN(SET) TO MAX(SET) DO
				IF e IN se THEN
					s.Incl(e);
				END;
			END;
			RETURN s;
		END Small;
	
	(* Tests whether s1= s2. *)
	PROCEDURE (s1: Set) Equal* (s2: Set): BOOLEAN, NEW;
		
		BEGIN (*Equal*)
			ASSERT(s2 # NIL, 20);
			RETURN s1.XOR(s2).IsEmpty();
		END Equal;
	
	(* Tests whether s1 is a subset of s2. *)
	PROCEDURE (s1: Set) Subset* (s2: Set): BOOLEAN, NEW;
		
		BEGIN (*Subset*)
			ASSERT(s2 # NIL, 20);
			RETURN s1.Diff(s2).IsEmpty();
		END Subset;
	
	PROCEDURE (VAR i: SetIterator) Attach* (s: Set), NEW;
		
		BEGIN (*Attach*)
			ASSERT(s # NIL, 20);
			i.s := s;
			i.cour := NIL;
		END Attach;
	
	(* On return, e contains the first element of the set attached to i. Returns TRUE if such an element exists. Usage: ok:= i.FirstE(e); WHILE ok DO ... ok:= i.NextE(e) END; *)
	PROCEDURE (VAR i: SetIterator) FirstE* (OUT e: INTEGER): BOOLEAN, NEW;
		
		VAR
			
			ok: BOOLEAN;
		
		BEGIN (*FirstE*)
			ASSERT(i.s # NIL, 20);
			i.cour := i.s.elems;
			ok := i.cour # NIL;
			IF ok THEN
				e := i.cour.val;
			END;
			RETURN ok;
		END FirstE;
	
	(* On return, e contains the next element of the set attached to i. Returns TRUE if such an element exists. i.FirstE must have been called once before i.NextE. Usage: ok:= i.FirstE(e); WHILE ok DO ... ok:= i.NextE(e) END; *)
	PROCEDURE (VAR i: SetIterator) NextE* (OUT e: INTEGER): BOOLEAN, NEW;
		
		VAR
			
			ok: BOOLEAN;
		
		BEGIN (*NextE*)
			ASSERT(i.s # NIL, 20);
			ASSERT(i.cour # NIL, 21);
			i.cour := i.cour.next;
			ok := i.cour # NIL;
			IF ok THEN
				e := i.cour.val;
			END;
			RETURN ok;
		END NextE;

	PROCEDURE Init;

		BEGIN (*Init*)
			add[0] := 4;
			add[1] := 2;
			add[2] := 4;
			add[3] := 2;
			add[4] := 4;
			add[5] := 6;
			add[6] := 2;
			add[7] := 6;
			add[8] := 1;
			add[9] := 2;
			add[10] := 2;
			
			next[0] := 1;
			next[1] := 2;
			next[2] := 3;
			next[3] := 4;
			next[4] := 5;
			next[5] := 6;
			next[6] := 7;
			next[7] := 0;
			next[8] := 9;
			next[9] := 10;
			next[10] := 0;
		END Init;
	
	BEGIN (*UtilSets*)
		Init;
	END UtilSets.
