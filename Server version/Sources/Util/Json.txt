(* 
Util: Utility tools.

Copyright (C) 2017…2018 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE UtilJson;
	
	

	IMPORT
		
		(**
		UtilLog,
		**)
		
		B := BabelCompil, Converters, Files, M := Meta, A := UtilMetaArray, Stores, Strings, TextMappers, TextModels, TextViews, Views;
	
	CONST
		
		compDir = "Util/Rsrc"; (* Directory of compiler files *)
		compName = "Json.tbl"; (* Json compiler *)
	
	TYPE
		
		StrPtr* = POINTER TO ARRAY OF CHAR;
		
		(* For compiler internalizing *)
		Directory = POINTER TO RECORD (B.Directory)
			r: Stores.Reader;
		END;
		
		Compilation = POINTER TO ABSTRACT RECORD (B.Compilation)
			json: Json;
		END;
		
		(* Compilation from a string (ReadString) *)
		CompilationS = POINTER TO RECORD (Compilation)
			s: StrPtr;
			cur: INTEGER;
		END;
		
		(* Compilation from a TextModels.Model (ReadText & ReadFile) *)
		CompilationT = POINTER TO RECORD (Compilation)
			r: TextModels.Reader;
		END;
		
		(* Outputs of ReadString, ReadText & ReadFile *)
		
		StringP* = POINTER TO ARRAY OF CHAR;
		
		Json* = POINTER TO LIMITED RECORD
		END;
		
		Object* = POINTER TO LIMITED RECORD (Json)
			fields-: Fields;
		END;
		
		Fields* = POINTER TO ARRAY OF Field;
		
		Field* = LIMITED RECORD
			name-: StringP;
			value-: Value;
		END;
		
		Array* = POINTER TO LIMITED RECORD (Json)
			elements-: Values;
		END;
		
		Values* = POINTER TO ARRAY OF Value;
		
		Value* = POINTER TO LIMITED RECORD
		END;
		
		String* = POINTER TO LIMITED RECORD (Value)
			s-: StringP;
		END;
		
		Integer* = POINTER TO LIMITED RECORD (Value)
			n-: LONGINT;
		END;
		
		Real* = POINTER TO LIMITED RECORD (Value)
			r-: REAL;
		END;
		
		JsonVal* = POINTER TO LIMITED RECORD (Value)
			json-: Json;
		END;
		
		Bool* = POINTER TO LIMITED RECORD (Value)
			bool-: BOOLEAN;
		END;
		
		Null* = POINTER TO LIMITED RECORD (Value)
		END;
		
		(* Stack used for building Json objects *) 
		Stack = POINTER TO ABSTRACT RECORD
			next: Stack;
		END;
		
		StartObj = POINTER TO RECORD (Stack)
		END;
		
		StartArr = POINTER TO RECORD (Stack)
		END;
		
		STValue = POINTER TO RECORD (Stack)
			val: Value;
		END;
		
		STField = POINTER TO RECORD (Stack)
			name: StringP;
			value: Value;
		END;
	
	VAR
		
		(**
		L: UtilLog.Log;
		**)
		
		comp: B.Compiler; (* Compiler of json texts *)
		
		stack: Stack; (* Stack used for building Json objects *) 
	
	(************ Json -> CP ************)
	
	(* Implementation of the standard procedures of Babel *)
	
	PROCEDURE (d: Directory) ReadInt (OUT i: INTEGER);
		
		BEGIN (*ReadInt*)
			d.r.ReadInt(i);
		END ReadInt;
	
	PROCEDURE (c: CompilationS) Read (OUT ch: CHAR);
		
		BEGIN (*Read*)
			ch := c.s[c.cur];
			IF ch = 0X THEN
				ch := B.eOF1;
			END;
			INC(c.cur);
		END Read;
	
	PROCEDURE (c: CompilationS) Pos (): INTEGER;
		
		BEGIN (*Pos*)
			RETURN c.cur;
		END Pos;
	
	PROCEDURE (c: CompilationS) SetPos (pos: INTEGER);
		
		BEGIN (*SetPos*)
			c.cur := pos;
		END SetPos;
	
	PROCEDURE (c: CompilationT) Read (OUT ch: CHAR);
		
		BEGIN (*Read*)
			c.r.Read;
			IF c.r.eot THEN
				ch := B.eOF1;
			ELSE
				ch := c.r.char;
			END;
		END Read;
	
	PROCEDURE (c: CompilationT) Pos (): INTEGER;
		
		BEGIN (*Pos*)
			RETURN c.r.Pos();
		END Pos;
	
	PROCEDURE (c: CompilationT) SetPos (pos: INTEGER);
		
		BEGIN (*SetPos*)
			IF pos <= c.r.Base().Length() THEN
				c.r.SetPos(pos);
			END;
		END SetPos;
	
	PROCEDURE (c: Compilation) Execution (fNum, parsNb: INTEGER; pars: B.ObjectsList; OUT o: B.Object; OUT res: ANYPTR): BOOLEAN;
		
		CONST
			
			object = 1;
			array = 2;
			nil = 3;
			cons = 4;
			
			json = 1;
			string = 2;
			number = 3;
			true = 4;
			false = 5;
			null = 6;
		
		VAR
			
			ok: INTEGER;
			n: Null;
			b: Bool;
			s: StringP;
			int: Integer;
			real: Real;
			sp: String;
			i: LONGINT;
			r: REAL;
		
		PROCEDURE Eval (o: B.Object): Json;
			
			VAR
				
				ob: Object;
				a: Array;
			
			PROCEDURE EvalVal (o: B.Object): Value;
				
				VAR
					
					j: JsonVal;
				
				BEGIN (*EvalVal*)
					CASE o.ObjType() OF
					|B.userObj:
						RETURN o.ObjUser()(Value);
					|B.termObj:
						NEW(j);
						j.json := Eval(o);
						RETURN j;
					END;
				END EvalVal;
			
			PROCEDURE EvalObj (o: B.Object): Fields;
				
				VAR
					
					oo: B.Object;
					n, i: INTEGER;
					f: Fields;
					s: StringP;
				
				BEGIN (*EvalObj*)
					oo := o; n := 0;
					WHILE oo.ObjFunc() = cons DO
						INC(n);
						oo := oo.ObjTermSon(3);
					END;
					ASSERT(oo.ObjFunc() = nil, 100);
					IF n = 0 THEN
						RETURN NIL;
					END;
					NEW(f, n);
					FOR i := 0 TO n - 1 DO
						oo := o.ObjTermSon(1);
						NEW(s, oo.ObjStringLen() + 1); oo.ObjString(s);
						NEW(f[i].name, LEN(s) - 2);
						Strings.Extract(s, 1, LEN(s$) - 2, f[i].name);
						f[i].value := EvalVal(o.ObjTermSon(2));
						o := o.ObjTermSon(3);
					END;
					RETURN f;
				END EvalObj;
			
			PROCEDURE EvalArr (o: B.Object): Values;
				
				VAR
					
					oo: B.Object;
					n, i: INTEGER;
					v: Values;
				
				BEGIN (*EvalArr*)
					oo := o; n := 0;
					WHILE oo.ObjFunc() = cons DO
						INC(n);
						oo := oo.ObjTermSon(2);
					END;
					ASSERT(oo.ObjFunc() = nil, 100);
					IF n = 0 THEN
						RETURN NIL;
					END;
					NEW(v, n);
					FOR i := 0 TO n - 1 DO
						v[i] := EvalVal(o.ObjTermSon(1));
						o := o.ObjTermSon(2);
					END;
					RETURN v;
				END EvalArr;
			
			BEGIN (*Eval*)
				ASSERT(o.ObjType() = B.termObj, 20);
				CASE o.ObjFunc() OF
				|object:
					NEW(ob);
					ob.fields := EvalObj(o.ObjTermSon(1));
					RETURN ob;
				|array:
					NEW(a);
					a.elements := EvalArr(o.ObjTermSon(1));
					RETURN a;
				END;
			END Eval;
		
		BEGIN (*Execution*)
			o := pars[0];
			CASE fNum OF
			|json:
				c.json := Eval(o);
			|string:
				NEW(sp);
				NEW(s, o.ObjStringLen() + 1); o.ObjString(s);
				NEW(sp.s, LEN(s) - 2);
				Strings.Extract(s, 1, LEN(s$) - 2, sp.s);
				res := sp;
			|number:
				NEW(s, o.ObjStringLen() + 1); o.ObjString(s);
				Strings.StringToLInt(s, i, ok);
				IF ok = 0 THEN
					NEW(int); int.n := i;
					res := int;
				ELSE
					Strings.StringToReal(s, r, ok); ASSERT(ok = 0, 100);
					NEW(real); real.r := r;
					res := real;
				END;
			|true,
			 false:
				NEW(b);
				b.bool := fNum = true;
				res := b;
			|null:
				NEW(n);
				res := n;
			END;
			RETURN TRUE;
		END Execution;
	
	(* String -> Json *)
	PROCEDURE ReadString* (IN s: ARRAY OF CHAR): Json;
		
		VAR
			
			c: CompilationS;
		
		BEGIN (*ReadString*)
			NEW(c);
			NEW(c.s, LEN(s$) + 1); c.s^ := s$;
			c.cur := 0;
			IF ~c.Compile(comp, TRUE) THEN
				RETURN NIL;
			END;
			RETURN c.json;
		END ReadString;
	
	(* TextModels.Model -> Json *)
	PROCEDURE ReadText* (t: TextModels.Model): Json;
		
		VAR
			
			c: CompilationT;
		
		BEGIN (*ReadText*)
			NEW(c);
			c.r := t.NewReader(NIL);
			IF ~c.Compile(comp, TRUE) THEN
				RETURN NIL;
			END;
			RETURN c.json;
		END ReadText;
	
	(* File -> Json *)
	PROCEDURE ReadFile* (IN dir, name: ARRAY OF CHAR ): Json;
		
		CONST
			
			textConv = "CpcUtf8Conv.ExportUtf8";
		
		VAR
			
			n: Files.Name;
			loc: Files.Locator;
			conv: Converters.Converter;
			v: Views.View;
		
		BEGIN (*ReadFile*)
			conv := Converters.list;
			WHILE (conv # NIL) & (conv.exp # textConv) DO
				conv := conv.next;
			END;
			ASSERT(conv # NIL, 100);
			loc := Files.dir.This(dir); ASSERT(loc.res = 0, 101);
			n := name$;
			v := Views.Old(Views.dontAsk, loc, n, conv);
			IF (v = NIL) OR ~(v IS TextViews.View) THEN
				RETURN NIL;
			END;
			RETURN ReadText(v(TextViews.View).ThisModel());
		END ReadFile;
	
	(* ApplyTo modifies obj according to j; warning: obj must be a pointer to a global, exported and modifiable record variable of its module, and only its exported and modifiable fields are taken into account; in obj, records must not be extended (i.e. their static types must match their dynamic types), but pointers to arrays, if their lengths are not alreadt correct, are allocated with the same length as in j, provided that their BaseTyp is in {(Meta) boolTyp, sCharTyp, charTyp, byteTyp, sIntTyp, intTyp, sRealTyp, realTyp, longTyp, recTyp} (in particular, no pointers; if you want pointers, replace them by records with a pointer field). *)
	PROCEDURE (j: Json) ApplyTo* (obj: ANYPTR), NEW;
		
		VAR
			
			i, ii: M.Item;
			ok: BOOLEAN;
		
		PROCEDURE Apply (j: Json; i: M.Item);
			
			VAR
				
				k: INTEGER;
			
			PROCEDURE ApplyVal (v: Value; i: M.Item);
				
				BEGIN (*ApplyVal*)
					IF i.vis = M.exported THEN
						WITH
						|v: Bool DO
							ASSERT(i.typ = M.boolTyp, 21);
							i.PutBoolVal(v.bool);
						|v: Integer DO
							CASE i.typ OF
							|M.byteTyp,
							 M.sIntTyp,
							 M.intTyp:
								i.PutIntVal(SHORT(v.n));
							|M.longTyp:
								i.PutLongVal(v.n);
							END;
						|v: JsonVal DO
							Apply(v.json, i);
						|v: Null DO
							ASSERT(i.typ = M.ptrTyp, 22);
							i.PutPtrVal(NIL);
						|v: Real DO
							ASSERT(i.typ IN{M.sRealTyp, M.realTyp}, 23);
							i.PutRealVal(v.r);
						|v: String DO
							IF i.typ = M.ptrTyp THEN
								IF v.s = NIL THEN
									i.PutPtrVal(NIL);
								ELSE
									ASSERT(i.BaseTyp() = M.arrTyp, 24);
									ok := i.PtrVal() # NIL;
									IF ok THEN
										i.Deref(ii);
										ok := ii.Len() = LEN(v.s);
									END;
									IF ~ok THEN
										A.MakeArr(i, LEN(v.s));
									END;
									i.Deref(ii); i := ii;
								END;
							END;
							IF v.s # NIL THEN
								CASE i.typ OF
								|M.sCharTyp,
								 M.charTyp:
									ASSERT(LEN(v.s$) = 1, 25);
									i.PutCharVal(v.s[0]);
								|M.arrTyp:
									ASSERT(i.Len() > LEN(v.s$), 26);
									CASE i.BaseTyp() OF
									|M.sCharTyp:
										i.PutSStringVal(SHORT(v.s$), ok); ASSERT(ok, 100);
									|M.charTyp:
										i.PutStringVal(v.s$, ok); ASSERT(ok, 101);
									END;
								END;
							END;
						END;
					END;
				END ApplyVal;
			
			BEGIN (*Apply*)
				IF i.vis = M.exported THEN
					WITH
					|j: Object DO
						IF i.typ = M.ptrTyp THEN
							IF i.PtrVal() = NIL THEN
								i.PutPtrVal(i.New());
							END;
							i.Deref(ii); i := ii;
						END;
						ASSERT(i.typ = M.recTyp, 22);
						FOR k := 0 TO LEN(j.fields) - 1 DO
							i.Lookup(j.fields[k].name$, ii); ASSERT(ii.obj # M.undef, 23);
							ApplyVal(j.fields[k].value, ii);
						END;
					|j: Array DO
						IF i.typ = M.ptrTyp THEN
							IF j.elements = NIL THEN
								i.PutPtrVal(NIL);
							ELSE
								ASSERT(i.BaseTyp() = M.arrTyp, 24);
								ok := i.PtrVal() # NIL;
								IF ok THEN
									i.Deref(ii);
									ok := ii.Len() = LEN(j.elements);
								END;
								IF ~ok THEN
									A.MakeArr(i, LEN(j.elements));
								END;
								i.Deref(ii); i := ii;
							END;
						END;
						IF j.elements # NIL THEN
							ASSERT((i.typ = M.arrTyp) & (i.Len() >= LEN(j.elements)), 25);
							FOR k := 0 TO LEN(j.elements) - 1 DO
								i.Index(k, ii);
								ApplyVal(j.elements[k], ii);
							END;
						END;
					END;
				END;
			END Apply;
		
		BEGIN (*ApplyTo*)
			M.GetItem(obj, i);
			ASSERT(i.obj = M.varObj, 20);
			Apply(j, i);
		END ApplyTo;
	
	(* Write writes j with fo *)
	PROCEDURE (j: Json) Write* (fo: TextMappers.Formatter), NEW;
		
		PROCEDURE Indent (indent: INTEGER);
			
			VAR
				
				i: INTEGER;
			
			BEGIN (*Indent*)
				FOR i := 1 TO indent DO
					fo.WriteTab;
				END;
			END Indent;
		
		PROCEDURE WriteString (IN s: ARRAY OF CHAR);
			
			PROCEDURE JsonFilter (IN s: ARRAY OF CHAR): POINTER TO ARRAY OF CHAR;
				
				VAR
					
					i, j, n, p: INTEGER;
					ss: POINTER TO ARRAY OF CHAR;
				
				BEGIN (*JsonFilter*)
					n := LEN(s$);
					p := n;
					FOR i := 0 TO n - 1 DO
						CASE s[i] OF
						|'"', '\':
							INC(p);
						ELSE
						END;
					END;
					NEW(ss, p + 1);
					j := 0;
					FOR i := 0 TO n - 1 DO
						CASE s[i] OF
						|'"', '\':
							ss[j] := '\';
							INC(j);
						ELSE
						END;
						ss[j] := s[i];
						INC(j);
					END;
					ss[j] := 0X;
					RETURN ss;
				END JsonFilter;
			
			BEGIN (*WriteString*)
				fo.WriteString('"');
				fo.WriteString(JsonFilter(s));
				fo.WriteString('"');
			END WriteString;
		
		PROCEDURE WriteJson (j: Json; indent: INTEGER);
			
			VAR
				
				i: INTEGER;
			
			PROCEDURE WriteVal (v: Value; indent: INTEGER);
				
				BEGIN (*WriteVal*)
					IF ~(v IS JsonVal) THEN
						Indent(indent);
					END;
					WITH
					|v: String DO
						WriteString(v.s);
					|v: Integer DO
						fo.WriteInt(v.n);
					|v: Real DO
						fo.WriteReal(v.r);
					|v: JsonVal DO
						WriteJson(v.json, indent);
					|v: Bool DO
						IF v.bool THEN
							fo.WriteString('true');
						ELSE
							fo.WriteString('false');
						END;
					|v: Null DO
						fo.WriteString('null');
					END;
				END WriteVal;
			
			PROCEDURE WriteObj (f: Fields; indent: INTEGER);
				
				VAR
					
					i: INTEGER;
				
				PROCEDURE WriteField (IN f: Field; indent: INTEGER);
					
					BEGIN (*WriteField*)
						Indent(indent);
						WriteString(f.name);
						fo.WriteString(':');
						fo.WriteLn;
						WriteVal(f.value, indent + 1);
					END WriteField;
				
				BEGIN (*WriteObj*)
					IF f # NIL THEN
						WriteField(f[0], indent);
						FOR i := 1 TO LEN(f) - 1 DO
							fo.WriteString(',');
							fo.WriteLn;
							WriteField(f[i], indent);
						END;
						fo.WriteLn;
					END;
				END WriteObj;
			
			PROCEDURE WriteArr (v: Values; indent: INTEGER);
				
				BEGIN (*WriteArr*)
					IF v # NIL THEN
						WriteVal(v[0], indent);
						FOR i := 1 TO LEN(v) - 1 DO
							fo.WriteString(',');
							fo.WriteLn;
							WriteVal(v[i], indent);
						END;
						fo.WriteLn;
					END;
				END WriteArr;
			
			BEGIN (*WriteJson*)
				WITH
				|j: Object DO
					Indent(indent);
					fo.WriteString('{');
					fo.WriteLn;
					WriteObj(j.fields, indent + 1);
					Indent(indent);
					fo.WriteString('}');
				|j: Array DO
					Indent(indent);
					fo.WriteString('[');
					fo.WriteLn;
					WriteArr(j.elements, indent + 1);
					Indent(indent);
					fo.WriteString(']');
				END;
			END WriteJson;
		
		BEGIN (*Write*)
			WriteJson(j, 0);
		END Write;
	
	(************ CP -> Json ************)
	
	(* Stack procedures *)
	
	PROCEDURE Push (s: Stack);
		
		BEGIN (*Push*)
			s.next := stack;
			stack := s;
		END Push;
	
	PROCEDURE Pull (): Stack;
		
		VAR
			
			s: Stack;
		
		BEGIN (*Pull*)
			ASSERT(stack # NIL, 20);
			s := stack;
			stack := s.next;
			RETURN s;
		END Pull;
	
	(*StartObject begins a json object *)
	PROCEDURE StartObject*;
		
		VAR
			
			so: StartObj;
		
		BEGIN (*StartObject*)
			NEW(so);
			Push(so);
		END StartObject;
	
	(* StartArray begins a json array *)
	PROCEDURE StartArray*;
		
		VAR
			
			sa: StartArr;
		
		BEGIN (*StartArray*)
			NEW(sa);
			Push(sa);
		END StartArray;
	
	(* PushString pushes the string s on the stack *)
	PROCEDURE PushString* (IN s: ARRAY OF CHAR);
		
		VAR
			
			sv: STValue;
			st: String;
		
		BEGIN (*PushString*)
			NEW(st); NEW(st.s, LEN(s$) + 1); st.s^ := s$;
			NEW(sv); sv.val := st;
			Push(sv);
		END PushString;
	
	(* PushInteger pushes the integer n on the stack *)
	PROCEDURE PushInteger* (n: LONGINT);
		
		VAR
			
			sv: STValue;
			i: Integer;
		
		BEGIN (*PushInteger*)
			NEW(i); i.n := n;
			NEW(sv); sv.val := i;
			Push(sv);
		END PushInteger;
	
	(* PushReal pushes the real r on the stack *)
	PROCEDURE PushReal* (r: REAL);
		
		VAR
			
			sv: STValue;
			re: Real;
		
		BEGIN (*PushReal*)
			NEW(re); re.r := r;
			NEW(sv); sv.val := re;
			Push(sv);
		END PushReal;
	
	(* PushBoolean pushes the boolean b on the stack *)
	PROCEDURE PushBoolean* (b: BOOLEAN);
		
		VAR
			
			sv: STValue;
			bo: Bool;
		
		BEGIN (*PushBoolean*)
			NEW(bo); bo.bool := b;
			NEW(sv); sv.val := bo;
			Push(sv);
		END PushBoolean;
	
	(* PushNull pushes a json null value on the stack *)
	PROCEDURE PushNull*;
		
		VAR
			
			sv: STValue;
			n: Null;
		
		BEGIN (*PushNull*)
			NEW(n); 
			NEW(sv); sv.val := n;
			Push(sv);
		END PushNull;
	
	PROCEDURE PushValue* (v: Value);
		
		VAR
			
			sv: STValue;
		
		BEGIN (*PushValue*)
			NEW(sv);
			sv.val := v;
			Push(sv);
		END PushValue;
	
	(* PushJson pushes the Json j on the stack *)
	PROCEDURE PushJson* (j: Json);
		
		VAR
			
			sv: STValue;
			jv: JsonVal;
		
		BEGIN (*PushJson*)
			NEW(jv);
			jv.json := j;
			NEW(sv);
			sv.val := jv;
			Push(sv);
		END PushJson;
	
	PROCEDURE PushField* (IN f: Field);
		
		VAR
			
			sf: STField;
		
		BEGIN (*PushField*)
			NEW(sf);
			sf.name := f.name; sf.value := f.value;
			Push(sf);
		END PushField;
	
	(* BuildField builds the json object field whose name is name and whose value is the last element on the stack and replaces this element with the built field *)
	PROCEDURE BuildField* (IN name: ARRAY OF CHAR);
		
		VAR
			
			s: Stack;
			sf: STField;
		
		BEGIN (*BuildField*)
			s := Pull();
			ASSERT(s IS STValue, 100);
			NEW(sf);
			NEW(sf.name, LEN(name$) + 1); sf.name^ := name$;
			sf.value := s(STValue).val;
			Push(sf);
		END BuildField;
	
	(* BuildObject builds a json object from all the fields stacked from the last StartObject call and stacks it *)
	PROCEDURE BuildObject*;
		
		VAR
			
			s: Stack;
			n, i: INTEGER;
			sf: STField;
			f: Fields;
			o: Object;
			j: JsonVal;
			sv: STValue;
		
		BEGIN (*BuildObject*)
			s := stack; n := 0;
			WHILE (s # NIL) & (s IS STField) DO
				INC(n); s := s.next;
			END;
			ASSERT((s # NIL) & (s IS StartObj), 100);
			IF n = 0 THEN
				f := NIL;
			ELSE
				NEW(f, n);
				FOR i := n - 1 TO 0 BY - 1 DO
					sf := Pull()(STField);
					f[i].name := sf.name; f[i].value := sf.value;
				END;
			END;
			s := Pull();
			NEW(o); o.fields := f;
			NEW(j); j.json := o;
			NEW(sv); sv.val := j;
			Push(sv);
		END BuildObject;
	
	(* BuildArray builds a json array from all the values stacked from the last StartArray call and stacks it *)
	PROCEDURE BuildArray*;
		
		VAR
			
			s: Stack;
			n, i: INTEGER;
			vals: Values;
			sv: STValue;
			a: Array;
			j: JsonVal;
		
		BEGIN (*BuildArray*)
			s := stack; n := 0;
			WHILE (s # NIL) & (s IS STValue) DO
				INC(n); s := s.next;
			END;
			ASSERT((s # NIL) & (s IS StartArr), 100);
			IF n = 0 THEN
				vals := NIL;
			ELSE
				NEW(vals, n);
				FOR i := n - 1 TO 0 BY - 1 DO
					sv := Pull()(STValue);
					vals[i] := sv.val;
				END;
			END;
			s := Pull();
			NEW(a); a.elements := vals;
			NEW(j); j.json := a;
			NEW(sv); sv.val := j;
			Push(sv);
		END BuildArray;
	
	(* GetJson builds and returns a Json built from the last object on the stack *)
	PROCEDURE GetJson* (): Json;
		
		VAR
			
			j: Json;
		
		BEGIN (*GetJson*)
			ASSERT((stack # NIL) & (stack IS STValue) & (stack(STValue).val IS JsonVal), 20);
			j := Pull()(STValue).val(JsonVal).json;
			RETURN j;
		END GetJson;
	
	(* BuildJsonFrom builds and returns a Json describing obj; warning: obj must be a pointer to a global exported record variable of its module, and only its exported fields are taken into account *)
	PROCEDURE BuildJsonFrom* (obj: ANYPTR): Json;
		
		VAR
			
			i, ii: M.Item;
			char: ARRAY 2 OF CHAR;
			name: M.Name;
			bT, len: INTEGER;
			ss: POINTER TO ARRAY OF SHORTCHAR;
			s: POINTER TO ARRAY OF CHAR;
			ok: BOOLEAN;
		
		PROCEDURE Process (i: M.Item);
			
			VAR
				
				sc: M.Scanner;
				k: INTEGER;
			
			BEGIN (*Process*)
				CASE i.typ OF
				|M.boolTyp:
					PushBoolean(i.BoolVal());
				|M.sCharTyp,
				 M.charTyp:
					char[0] := i.CharVal();
					PushString(char);
				|M.byteTyp,
				 M.sIntTyp,
				 M.intTyp:
					PushInteger(i.IntVal());
				|M.longTyp:
					PushInteger(i.LongVal());
				|M.sRealTyp,
				 M.realTyp:
					PushReal(i.RealVal());
				|M.recTyp:
					StartObject;
					sc.ConnectTo(i);
					sc.Scan;
					WHILE ~sc.eos DO
						Process(sc.this);
						sc.GetObjName(name);
						BuildField(name);
						sc.Scan;
					END;
					BuildObject;
				|M.arrTyp:
					len := i.Len();
					bT := i.BaseTyp();
					IF bT = M.sCharTyp THEN
						NEW(ss, len);
						i.GetSStringVal(ss, ok); ASSERT(ok, 100);
						PushString(LONG(ss$));
					ELSIF bT = M.charTyp THEN
						NEW(s, len);
						i.GetStringVal(s, ok); ASSERT(ok, 101);
						PushString(s$);
					ELSE
						StartArray;
						FOR k := 0 TO i.Len() - 1 DO
							i.Index(k, ii);
							Process(ii);
						END;
						BuildArray;
					END;
				|M.ptrTyp:
					IF i.PtrVal() = NIL THEN
						PushNull;
					ELSE
						i.Deref(ii);
						Process(ii);
					END;
				END;
			END Process;
		
		BEGIN (*BuildJsonFrom*)
			IF obj = NIL THEN
				RETURN NIL;
			END;
			M.GetItem(obj, i);
			ASSERT(i.obj = M.varObj, 20);
			char[1] := 0X;
			Process(i);
			RETURN GetJson();
		END BuildJsonFrom;
	
	PROCEDURE Roll* (n: INTEGER);
		
		VAR
			
			s, ss: Stack;
		
		BEGIN (*Roll*)
			ASSERT(n >= 1, 20);
			s := stack;
			WHILE (s # NIL) & (n > 2) DO
				s := s.next; DEC(n);
			END;
			ASSERT((s # NIL) & (s.next # NIL), 21);
			IF n >= 2 THEN
				ss := s.next;
				s.next := ss.next;
				ss.next := stack;
				stack := ss;
			END;
		END Roll;
	
	PROCEDURE RollD* (n: INTEGER);
		
		VAR
			
			s, ss: Stack;
		
		BEGIN (*RollD*)
			ASSERT(n >= 1, 20);
			s := stack;
			WHILE (s # NIL) & (n > 1) DO
				s := s.next; DEC(n);
			END;
			ASSERT(s # NIL, 21);
			IF n >= 2 THEN
				ss := stack;
				stack := stack.next;
				ss.next := s.next;
				s.next := ss;
			END;
		END RollD;
	
	PROCEDURE Swap*;
		
		BEGIN (*Swap*)
			Roll(2);
		END Swap;
	
	PROCEDURE Init;
		
		VAR
			
			loc: Files.Locator;
			d: Directory;
			f: Files.File;
		
		BEGIN (*Init*)
			(**
			L := UtilLog.NewLog("Duniter1/Rsrc", "JsonLog.txt", TRUE);
			**)
			
			(* Compilers reading *)
			NEW(d);
			loc := Files.dir.This(compDir);
			ASSERT(loc.res = 0, 100);
			f := Files.dir.Old(loc, compName, Files.shared);
			ASSERT(f # NIL, 101);
			d.r.ConnectTo(f);
			comp := d.ReadCompiler();
			
			(* Initialisation of stack *)
			stack := NIL;
		END Init;
	
	BEGIN (*UtilJson*)
		Init;
	END UtilJson.
