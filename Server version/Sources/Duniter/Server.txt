(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterServer;
	
	
	
	(* Server *)

	IMPORT
		
		A := UtilAvlTree, B := DuniterBlockchain, BA := DuniterBasic, L := DuniterLog, Dialog, Files, HostFiles, HostMenus, Math, Services, Strings, TextMappers, TextModels, TextViews, W := DuniterWotWizard, J := UtilJson, Views;
	
	CONST
		
		version = "2.3.2se";
		
		rsrcDir = "Duniter/Rsrc"; (* Directory for the two following files *)
		parametersName = "Parameters.txt"; (* File containing the greatest allowed allocated memory size and the longest run time for W.CalcPermutations *)
		runningName = "Running.odc"; (* File whose existence shows that WWServer.exe is running *)
		
		textMeta = "WWMeta.json"; (* Json file containing metadata *)
		textByDate = "WWByDate.json"; (* Json file containing calculated entries *)
		
	
	VAR
		
		maxSize: LONGINT; (* Greatest allowed allocated memory size *)
	
	(* Write the metadata duration, f, cNb & dNb with the help of fo, in json format; duration is the computation duration, f is the DuniterWotWizard.File structure, cNb and dNb are respectively the numbers of internal certifications and of external dossiers *)
	PROCEDURE WriteMeta (IN fo: TextMappers.Formatter; duration: LONGINT; f: W.File; permutations, cNb, dNb: INTEGER);
		
		VAR
			
			s: BA.DateTime;
			ss: BA.TimeString;
			sss: Dialog.String;
		
		PROCEDURE WriteFile (f: W.File; withTo: BOOLEAN);
			
			VAR
				
				i: INTEGER;
			
			PROCEDURE WriteCertOrDoss (cd: W.CertOrDoss);
				
				PROCEDURE WriteCertOrDossEnd (cd: W.CertOrDoss);
					
					BEGIN (*WriteCertOrDossEnd*)
						IF cd.date = BA.never THEN
							Dialog.MapString("#Duniter:Never", sss);
							J.PushString(sss);
						ELSE
							BA.TimestampToString(cd.date, s);
							J.PushString(s);
						END;
						J.BuildField("date");
						BA.TimestampToString(cd.limit, s);
						J.PushString(s);
						J.BuildField("limit");
					END WriteCertOrDossEnd;
				
				PROCEDURE WriteCertif (c: W.Certif);
					
					BEGIN (*WriteCertif*)
						J.StartObject;
						J.PushString(c.from);
						J.BuildField("from");
						IF withTo THEN
							J.PushString(c.to);
							J.BuildField("to");
						END;
						WriteCertOrDossEnd(c);
						J.BuildObject;
					END WriteCertif;
				
				PROCEDURE WriteDossier (d: W.Dossier);
					
					VAR
						
						s: ARRAY 7 OF CHAR;
					
					BEGIN (*WriteDossier*)
						J.StartObject;
						J.PushString(d.id);
						J.BuildField("newcomer");
						J.PushInteger(d.princCertif);
						J.BuildField("main_certifs");
						Strings.RealToStringForm(100 * d.proportionOfSentries, 16, 1, - 2, " ", s);
						J.PushString(s);
						J.BuildField("percent_of_sentries");
						WriteCertOrDossEnd(d);
						WriteFile(d.certifs, FALSE);
						J.BuildField("certifs");
						J.BuildObject;
					END WriteDossier;
				
				BEGIN (*WriteCertOrDoss*)
					WITH
						|cd: W.Certif DO
							IF withTo THEN
								J.StartObject;
							END;
							WriteCertif(cd);
							IF withTo THEN
								J.BuildField("certif");
								J.BuildObject;
							END;
						|cd: W.Dossier DO
							J.StartObject;
							WriteDossier(cd);
							J.BuildField("dossier");
							J.BuildObject;
					END;
				END WriteCertOrDoss;
			
			BEGIN (*WriteFile*)
				J.StartArray;
				IF f # NIL THEN
					FOR i := 0 TO LEN(f) - 1 DO
						WriteCertOrDoss(f[i]);
					END;
				END;
				J.BuildArray;
			END WriteFile;
		
		BEGIN (*WriteMeta*)
			J.StartObject;
			J.PushInteger(B.LastBlock());
			J.BuildField("block");
			BA.TimestampToString(B.Now(), s);
			J.PushString(s);
			J.BuildField("now");
			J.PushInteger(permutations);
			J.BuildField("permutations");
			BA.TimeToString(duration, ss);
			J.PushString(ss);
			J.BuildField("computation_duration");
			J.PushInteger(cNb);
			J.BuildField("certNb");
			J.PushInteger(dNb);
			J.BuildField("dossNb");
			WriteFile(f, TRUE);
			J.BuildField("certifs&dossiers");
			J.BuildObject;
			J.GetJson().Write(fo);
		END WriteMeta;
	
	(* Print the entries sorted by dates in json format *)
	PROCEDURE ByDates (occur: A.Tree);
		
		VAR
			
			e: A.Elem;
			date: LONGINT;
			after: BOOLEAN;
			s: BA.DateTime;
			ss: Dialog.String;
		
		BEGIN (*ByDates*)
			date := - 1;
			e := occur.Next(NIL);
			WHILE e # NIL DO
				WITH e: W.PropDate DO
					IF (e.date # date) OR (e.after # after) THEN
						IF date >= 0 THEN
							J.BuildArray;
							J.BuildField("names");
							J.BuildObject;
						END;
						date := e.date; after := e.after;
						J.StartObject;
						J.PushBoolean(e.after);
						J.BuildField("after");
						IF e.date = BA.never THEN
							Dialog.MapString("#Duniter:Never", ss);
							J.PushString(ss);
						ELSE
							BA.TimestampToString(e.date, s);
							J.PushString(s);
						END;
						J.BuildField("date");
						J.StartArray;
					END;
					J.StartObject;
					J.PushString(e.id);
					J.BuildField("name");
					J.PushInteger(ENTIER(Math.Round(e.proba * 100)));
					J.BuildField("proba");
					J.BuildObject;
				END;
				e := occur.Next(e);
			END;
			IF date >= 0 THEN
				J.BuildArray;
				J.BuildField("names");
				J.BuildObject;
			END;
		END ByDates;
	
	(* Save the WotWizard lists on disk, in files textMeta and textByDate in json format *)
	PROCEDURE StoreText;
		
		VAR
			
			f: W.File;
			occur: A.Tree;
			loc: Files.Locator;
			name: Files.Name;
			res, cNb, dNb, permutations: INTEGER;
			t: TextModels.Model;
			fo: TextMappers.Formatter;
			nowS: BA.DateTime;
			ti, duration: LONGINT;
			s: BA.TimeString;
		
		BEGIN (*StoreText*)
			ti := Services.Ticks();
			IF ~W.BuildEntries(f, permutations, cNb, dNb, occur) THEN
				A.New(occur);
			END;
			duration := Services.Ticks() - ti;
			L.log.Msg("Writing json");
			ti := Services.Ticks();
			loc := Files.dir.This(""); L.log.Err(loc.res, "");
			t := TextModels.dir.New();
			fo.ConnectTo(t);
			WriteMeta(fo, duration, f, permutations, cNb, dNb);
			name := textMeta;
			Views.Register(TextViews.dir.New(t), Views.dontAsk, loc, name, BA.utf8Conv, res);
			L.log.Err(res, name);
			BA.TimestampToString(B.Now(), nowS);
			t := TextModels.dir.New();
			fo.ConnectTo(t);
			J.StartObject;
			J.PushString(nowS);
			J.BuildField("now");
			J.StartArray;
			ByDates(occur);
			J.BuildArray;
			J.BuildField("dates");
			J.BuildObject;
			J.GetJson().Write(fo);
			name := textByDate;
			Views.Register(TextViews.dir.New(t), Views.dontAsk, loc, name, BA.utf8Conv, res);
			L.log.Err(res, name);
			BA.TimeToString(Services.Ticks() - ti, s);
			L.log.Msg("End writing json. Time spent: " + s);
		END StoreText;
	
	(* Main procedure *)
	PROCEDURE Start*;
		
		CONST
			
			maxTriesNb = 100;
		
		VAR
			
			t: LONGINT;
			s: BA.TimeString;
			loc: Files.Locator;
			n: INTEGER;
			ss: Dialog.String;
		
		BEGIN (*Start*)
			t := Services.Ticks();
			B.UpdateAll;
			BA.TimeToString(Services.Ticks() - t, s);
			L.log.Msg("Total execution time: " + s);
			loc := Files.dir.This(rsrcDir); L.log.Err(loc.res, rsrcDir);
			Files.dir.Delete(loc, runningName);
			IF ~(loc.res IN {0, 2, 6}) THEN L.log.Err(loc.res, runningName); END;
			IF loc.res = 6 THEN
				L.log.Msg("Error 6 in deleting 'Running.odc' file");
				n := maxTriesNb;
				REPEAT
					Files.dir.Delete(loc, runningName); 
					DEC(n);
				UNTIL (loc.res = 0) OR (n = 0);
				IF loc.res # 0 THEN
					Strings.IntToString(loc.res, ss);
					L.log.Msg("Error in deleting 'Running.odc' file: " + ss);
				END;
				ASSERT(loc.res = 0, 100);
			END;
			HostMenus.Exit;  (* End of WWServer.exe *)
		END Start;
	
	PROCEDURE StoreParameters;
		
		VAR
			
			l: Files.Locator;
			f: TextMappers.Formatter;
			res: INTEGER;
			t: TextModels.Model;
			name: Files.Name;
		
		BEGIN (*StoreParameters*)
			l := Files.dir.This(rsrcDir); L.log.Err(l.res, rsrcDir);
			t := TextModels.dir.New();
			f.ConnectTo(t);
			f.WriteInt(maxSize);
			f.WriteLn;
			name := parametersName;
			Views.Register(TextViews.dir.New(t), Views.dontAsk, l, name, BA.utf8Conv, res); 
			L.log.Err(res, name);
		END StoreParameters;
	
	PROCEDURE Init;
		
		VAR
			
			l: Files.Locator;
			sc: TextMappers.Scanner;
			s: ARRAY 20 OF CHAR;
			name: Files.Name;
			v: Views.View;
		
		BEGIN (*Init*)
			HostFiles.IgnoreAsk;
			l := Files.dir.This(rsrcDir); L.log.Err(l.res, rsrcDir);
			name := parametersName;
			v := Views.Old(Views.dontAsk, l, name, BA.utf8Conv);
			IF v = NIL THEN
				maxSize := W.maxSize;
				StoreParameters;
			ELSE
				ASSERT(v IS TextViews.View, 100);
				sc.ConnectTo(v(TextViews.View).ThisModel());
				sc.Scan; ASSERT((sc.type = TextMappers.int) OR (sc.type = TextMappers.lint), 101);
				maxSize := sc.lint;
				W.ChangeParameters(maxSize);
			END;
			L.log.Msg("Version " + version);
			Strings.IntToString(maxSize, s);
			L.log.Msg("Memory size limit for calculating entries: " + s);
			B.AddUpdateProc(StoreText);
		END Init;
	
	BEGIN (*DuniterServer*)
		Init;
	CLOSE
		B.RemoveUpdateProc(StoreText);
	END DuniterServer.

DuniterServer.Start;