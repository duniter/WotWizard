(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterBlockchain;
	
	
	
	(* Collect blockchain data; server version *)
	
	IMPORT
		
		(**
		Lg := StdLog,
		**)
		
		A := UtilAvlTree, B := UtilBBTree, BA := DuniterBasic, L := DuniterLog, Files, Math, Services, S := SqlDB, Strings, TextMappers, TextModels, TextViews, UtilSort, U := UtilSets, Views;
	
	CONST
		
		(* Default path to the Duniter database *)
		duniBaseDef = "D:\.config\duniter\duniter_default\duniter.db";
		
		(* Driver SQLite *)
		driver* = "SQLiteDriver";
		
		(* Directory & name of the file where the path to the Duniter database is written *)
		initDir = "Duniter/Rsrc";
		initName = "Init.txt";
		
		(* Number of pages used by UtilBTree *)
		pageNb = 2000;
		
		(* Max length of a Pubkey *)
		pubkeyLen* = 44;
		
		(* Max length of a Hash *)
		hashLen* = 64;
		
		(* Number of last blocks to be read again at every update, since they could have changed *)
		secureGap = 100;
		
		(* Name of the WotWizard database, in the WotWizard.exe directory *)
		dBase = "Duniter\DBase.data";
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0; (* Index timeT *)
		idPubPlace = 1; (* Index idPubT *)
		idUidPlace = 2; (* Index idUidT *)
		idHashPlace = 3; (* Index idHashT *)
		idTimePlace = 4; (* Index idTimeT *)
		certFromPlace = 5; (* Index certFromT *)
		certToPlace = 6; (* Index certToT *)
		certTimePlace = 7; (* Index certTimeT *)
		undoListPlace = 8; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 9; (* Last read block *)
		idLenPlace = 10; (* Number of actual members *)
		
		placeNb = 11; (* Number of places *)
	
	TYPE
		
		(* Procedure called at every update *)
		UpdateProc* = PROCEDURE;
		
		(* Chained list of procedures called at every update *)
		UpdateList = POINTER TO RECORD
			next: UpdateList;
			update: UpdateProc;
		END;
		
		String* = POINTER TO ARRAY OF CHAR;
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		Hash* = ARRAY hashLen + 1 OF CHAR;
		
		(* Duniter Parameters *)
		Parameters* = RECORD
			
			(* The %growth of the UD every [dtReeval] period = 0.0488 /  (6 months) = 4.88% / (6 months) *)
			c-: REAL;
			
			(* Time period between two UD = 86400 s = 1 day *)
			dt-,
			
			(* UD(0), i.e. initial Universal Dividend = 1000 cents = 10 Ğ1 *)
			ud0-,
			
			(* Minimum delay between 2 certifications of a same issuer = 432000 s = 5 days *)
			sigPeriod-,
			
			(* Maximum quantity of active certifications made by member = 100 *)
			sigStock-,
			
			(* Maximum delay a certification can wait before being expired for non-writing = 5259600 s = 2 months *)
			sigWindow-,
			
			(* Maximum age of an active certification = 63115200 s = 2 years *)
			sigValidity-,
			
			(* Minimum delay before replaying a certification = 5259600 s = 2 months *)
			sigReplay-,
			
			(* Minimum quantity of signatures to be part of the WoT = 5 *)
			sigQty-,
			
			(* Maximum delay an identity can wait before being expired for non-writing = 5259600 s = 2 months *)
			idtyWindow-,
			
			(* Maximum delay a membership can wait before being expired for non-writing = 5259600 s = 2 months *)
			msWindow-,
			
			(* Minimum delay between 2 memberships of a same issuer = 5259600 s = 2 months *)
			msPeriod-: INTEGER;
			
			(* Minimum percent of sentries to reach to match the distance rule = 0.8 = 80% *)
			xpercent-: REAL;
			
			(* Maximum age of an active membership = 31557600 s = 1 year *)
			msValidity-,
			
			(* Maximum distance between a newcomer and [xpercent] of sentries = 5 *)
			stepMax-,
			
			(* Number of blocks used for calculating median time = 24 *)
			medianTimeBlocks-,
			
			(* The average time for writing 1 block (wished time) = 300 s = 5 min *)
			avgGenTime-,
			
			(* The number of blocks required to evaluate again PoWMin value = 12 *)
			dtDiffEval-: INTEGER;
			
			(* The percent of previous issuers to reach for personalized difficulty = 0.67 = 67% *)
			percentRot-: REAL;
			
			(* Time of first UD = 1488970800 s = 2017/03/08 11:00:00 UTC+0 *)
			udTime0-,
			
			(* Time of first reevaluation of the UD = 1490094000 s = 2017/03/21 11:00:00 UTC+0 *)
			udReevalTime0-: LONGINT;
			
			(* Time period between two re-evaluation of the UD = 15778800 s = 6 months *)
			dtReeval-,
			
			(* Maximum delay a transaction can wait before being expired for non-writing = 604800 s = 7 days *)
			txWindow-: INTEGER;
			
		END;
	
	CONST
		
		(* Types of elements in UndoList *)
		timeList = 0;
		idAddList = 1;
		joinList = 2;
		activeList = 3;
		leaveList = 4;
		idAddTimeList = 5;
		idRemoveTimeList = 6;
		certAddList = 7;
		certRemoveList = 8;
	
	TYPE
		
		(* Chained list of the operations to be undone before every update *)
		UndoList = POINTER TO RECORD (B.Data)
			next: INTEGER;
			type: BYTE;
			(* timeList -> Time; joinList, activeList, leaveList -> Identity; certAddList, certRemoveList -> Certification *)
			ref: INTEGER;
			aux,
			aux2: LONGINT;
		END;
		
		(* Factory of UndoList *)
		UndoListFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			bnb: INTEGER;
			mTime: LONGINT;
		END;
		
		(* Factory of Time *)
		TimeFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Identity = POINTER TO RECORD (B.Data)
			pubkey: Pubkey;
			uid: String;
			member: BOOLEAN;
			hash: Hash;
			block_number: INTEGER; (* Where the Identity is written *)
			application, (* Date of last membership application (joiners, actives, leavers) *)
			expires_on: LONGINT;
		END;
		
		(* Factory of Identity *)
		IdentityFac = POINTER TO RECORD (B.DataFac)
		END;
		
		Certification = POINTER TO RECORD (B.Data)
			from,
			to: Pubkey;
			block_number: INTEGER; (* Where the Certification is written *)
			expires_on: LONGINT;
		END;
		
		(* Factory of Certification *)
		CertificationFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* INTEGER index key *)
		IntKey = POINTER TO RECORD (B.Data)
			ref: INTEGER;
		END;
		
		(* Factory of IntKey *)
		IntKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of IntKey *)
		IntKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data) (* # Pubkey! *)
			ref: Pubkey;
		END;
		
		(* Factory of PubKey *)
		PubKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of PubKey *)
		PubKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Hashkey index key *)
		HashKey = POINTER TO RECORD (B.Data)
			ref: Hash;
		END;
		
		(* Factory of HashKey *)
		HashKeyFac = POINTER TO RECORD (B.DataFac)
		END;
		
		(* Manager of HashKey *)
		HashKeyMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Uid index key manager *)
		UidKeyMan = POINTER TO RECORD (B.StringKeyManager) 
		END;
		
		(* Manager of Identity sorted by expiration dates *)
		IdKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Manager of Certification sorted by expiration dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Current position in a Certification sub-index *)
		CertPos* = RECORD
			posRef: INTEGER; (* Root of the sub-index *)
			posCur: B.IndexPos; (* Position in the sub-index *)
		END;
		
		(* Member, Members, MembersFind: Distance Rule *)
		Member = RECORD
			p: Pubkey;
			links: U.Set;
		END;
		
		Members = POINTER TO ARRAY OF Member;
		
		MembersFind = RECORD (UtilSort.T)
			len: INTEGER;
			m: Members;
		END;
		
		Pubkeys = POINTER TO ARRAY OF Pubkey;
		
		PoSE = POINTER TO RECORD (A.Elem)
			pubkeys: Pubkeys;
			poS: REAL;
		END;
	
	CONST
		
		(* Sizes of B.Data *)
		pubKeyS = (pubkeyLen + 1) * B.CHS;
		
		(* Sizes of keys *)
		timeKeyS = B.INS;
		idTimeKeyS = B.INS;
		certTimeKeyS = B.INS;
	
	VAR
		
		duniBase-: Files.Name; (* Path to the Duniter database *)
		
		updateList: UpdateList; (* Head of UpdateList *)
		
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		idHashT, (* HashKey -> Identity *)
		idTimeT, (* IntKey -> nothing; addresses of Identity sorted by expiration dates *)
		certFromT, certToT, (* PubKey -> sub-index(PubKey -> Certification) *)
		certTimeT: B.Index; (* IntKey -> nothing; addresses of Certification sorted by expiration dates *)
		
		(* Sentries & Distance Rule *)
		members: MembersFind;
		sentriesS: U.Set; (* Set of sentries *)
		sentriesI: U.SetIterator; (* Iterator of sentriesS *)
		poST: A.Tree;
		
		undoList: INTEGER; (* Head of UndoList *)
		
		(* Current positions in indexes *)
		idPubkeyCur,
		idUidCur,
		certFromCur,
		certToCur: B.IndexPos;
		sentryCur: INTEGER;
		
		lastBlock: INTEGER; (* Last read & updated block *)
		now: LONGINT; (* Present medianTime and time *)
		idLenM: INTEGER; (* Number of members *)
		
		(* Factories *)
		undoListFac: UndoListFac;
		timeFac: TimeFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		hashKeyFac: HashKeyFac;
		
		(* Data managers *)
		timeMan,
		idMan,
		certMan,
		undoListMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: UidKeyMan;
		hashKeyMan: HashKeyMan;
		intKeyMan: IntKeyMan;
		idKTimeMan: IdKTimeMan;
		certKTimeMan: CertKTimeMan;
	
	PROCEDURE (p1: PoSE) Compare (p2: A.Elem): BYTE;
		
		VAR
			
			i: INTEGER;
		
		BEGIN (*Compare*)
			WITH p2: PoSE DO
				IF LEN(p1.pubkeys) < LEN(p2.pubkeys) THEN
					RETURN A.lt;
				END;
				IF LEN(p1.pubkeys) > LEN(p2.pubkeys) THEN
					RETURN A.gt;
				END;
				FOR i := 0 TO LEN(p1.pubkeys) - 1 DO
					IF p1.pubkeys[i]$ < p2.pubkeys[i]$ THEN
						RETURN A.lt;
					END;
					IF p1.pubkeys[i]$ > p2.pubkeys[i]$ THEN
						RETURN A.gt;
					END;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (id: Identity) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(id.pubkey);
			NEW(id.uid, r.InCharsLen() + 1);
			r.InChars(id.uid);
			id.member := r.InBool();
			r.InChars(id.hash);
			id.block_number := r.InInt();
			id.application := r.InLInt();
			id.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (id: Identity) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(id.pubkey);
			w.OutChars(id.uid);
			w.OutBool(id.member);
			w.OutChars(id.hash);
			w.OutInt(id.block_number);
			w.OutLInt(id.application);
			w.OutLInt(id.expires_on);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (l: UndoList) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.next := r.InInt();
			l.type := r.InByte();
			l.ref := r.InInt();
			l.aux := r.InLInt();
			l.aux2 := r.InLInt();
		END Read;
	
	PROCEDURE (l: UndoList) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(l.next);
			w.OutByte(l.type);
			w.OutInt(l.ref);
			w.OutLInt(l.aux);
			w.OutLInt(l.aux2);
		END Write;
	
	PROCEDURE (lf: UndoListFac) New (size: INTEGER): UndoList;
		
		VAR
			
			l: UndoList;
		
		BEGIN (*New*)
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.INS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (pf: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	PROCEDURE (hash: HashKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			r.InChars(hash.ref);
		END Read;
	
	PROCEDURE (hash: HashKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			w.OutChars(hash.ref);
		END Write;
	
	PROCEDURE (hf: HashKeyFac) New (size: INTEGER): HashKey;
		
		VAR
			
			hash: HashKey;
		
		BEGIN (*New*)
			NEW(hash);
			IF size = 0 THEN
				hash.ref := "";
			END;
			RETURN hash;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			ASSERT(PKMCompP(p1, p2) = B.lt, 21);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	PROCEDURE HKMCompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*HKMCompP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					IF h1.ref < h2.ref THEN
						RETURN B.lt;
					END;
					IF h1.ref > h2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END HKMCompP;
	
	PROCEDURE (hm: HashKeyMan) CompP (h1, h2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN HKMCompP(h1, h2);
		END CompP;
	
	PROCEDURE (hm: HashKeyMan) PrefP (h1: B.Data; VAR h2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			h: HashKey;
		
		BEGIN (*PrefP*)
			ASSERT((h1 # NIL) & (h2 # NIL), 20);
			ASSERT(HKMCompP(h1, h2) = B.lt, 21);
			WITH h1: HashKey DO
				WITH h2: HashKey DO
					l2 := LEN(h2.ref$);
					NEW(h);
					l := 0;
					h.ref[l] := 0X;
					WHILE (l <= l2) & ~((HKMCompP(h1, h) = B.lt) & (HKMCompP(h, h2) <= B.eq)) DO
						h.ref[l] := h2.ref[l];
						INC(l);
						h.ref[l] := 0X;
					END;
				END;
			END;
			h2 := h;
		END PrefP;
	
	(* Comparison method of two Strings. Use the lexical order. *)
	PROCEDURE (um: UidKeyMan) CompP (key1, key2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			ASSERT((key1 # NIL) & (key2 # NIL), 20);
			WITH key1: B.String DO
				WITH key2: B.String DO
					IF key1.c = NIL THEN
						IF key2.c = NIL THEN
							RETURN B.eq;
						END;
						RETURN B.lt;
					END;
					IF key2.c = NIL THEN
						RETURN B.gt;
					END;
					RETURN BA.CompP(key1.c, key2.c);
				END;
			END;
		END CompP;
	
	(* Comparison of Identity(s) by expiration dates *)
	PROCEDURE (im: IdKTimeMan) CompP (i1, i2: B.Data): BYTE;
		
		VAR
			
			id1, id2: Identity;
		
		BEGIN (*CompP*)
			WITH i1: IntKey DO
				id1 := idMan.ReadData(i1.ref)(Identity);
			END;
			WITH i2: IntKey DO
				id2 := idMan.ReadData(i2.ref)(Identity);
			END;
			IF ABS(id1.expires_on) < ABS(id2.expires_on) THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired identities *)
			END;
			IF ABS(id1.expires_on) > ABS(id2.expires_on) THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ < id2.pubkey$ THEN
				RETURN B.lt;
			END;
			IF id1.pubkey$ > id2.pubkey$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* Comparison of Certification(s) by expiration dates *)
	PROCEDURE (im: CertKTimeMan) CompP (i1, i2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH i1: IntKey DO
				c1 := certMan.ReadData(i1.ref)(Certification);
			END;
			WITH i2: IntKey DO
				c2 := certMan.ReadData(i2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired certifications *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	PROCEDURE (VAR m: MembersFind) Less (i, j: INTEGER): BOOLEAN;
		
		BEGIN (*Less*)
			RETURN m.m[i].p < m.m[j].p;
		END Less;
	
	PROCEDURE FindMemberNum (p: Pubkey; OUT n: INTEGER): BOOLEAN;
		
		BEGIN (*FindMemberNum*)
			n := members.len;
			members.m[n].p := p;
			members.BinSearch(0, n - 1, n);
			RETURN n < members.len;
		END FindMemberNum;
	
	(* Last read & updated block *)
	PROCEDURE LastBlock* (): INTEGER;
		
		BEGIN (*LastBlock*)
			RETURN lastBlock;
		END LastBlock;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b, 100);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL, 101);
					database.WritePlace(timePlace, database.CreateIndex(timeKeyS));
					database.WritePlace(idPubPlace, database.CreateIndex(0));
					database.WritePlace(idUidPlace, database.CreateIndex(0));
					database.WritePlace(idHashPlace, database.CreateIndex(0));
					database.WritePlace(idTimePlace, database.CreateIndex(idTimeKeyS));
					database.WritePlace(certFromPlace, database.CreateIndex(0));
					database.WritePlace(certToPlace, database.CreateIndex(0));
					database.WritePlace(certTimePlace, database.CreateIndex(certTimeKeyS));
					database.WritePlace(undoListPlace, B.bNil);
					database.WritePlace(lastNPlace, 0);
					database.WritePlace(idLenPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				undoListMan := database.CreateDataMan(undoListFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				idHashT := database.OpenIndex(database.ReadPlace(idHashPlace), hashKeyMan, hashKeyFac);
				idTimeT := database.OpenIndex(database.ReadPlace(idTimePlace), idKTimeMan, intKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
				certTimeT := database.OpenIndex(database.ReadPlace(certTimePlace), certKTimeMan, intKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf* (bnb: INTEGER; OUT mTime: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> uid *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPub*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPubComplete* (IN pubkey: Pubkey; OUT uid: String; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT application, expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPubComplete*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				application := id.application;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPubComplete;
	
	(* uid -> Pubkey *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* uid -> Identity *)
	PROCEDURE IdUidComplete* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey; OUT member: BOOLEAN; OUT hash: Hash; OUT block_number: INTEGER; OUT application, expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUidComplete*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				member := id.member;
				hash := id.hash;
				block_number := id.block_number;
				application := id.application;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUidComplete;
	
	(* Hash -> pubkey *)
	PROCEDURE IdHash* (IN hash: Hash; OUT pub: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
			idH: HashKey;
		
		BEGIN (*IdHash*)
			NEW(idH);
			idH.ref := hash;
			IF idHashT.Search(idH) THEN
				id := idMan.ReadData(idHashT.ReadValue())(Identity);
				pub := id.pubkey;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdHash;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idUidT.NumberOfKeys();
		END IdLen;
	
	(* Number of members *)
	PROCEDURE IdLenM* (): INTEGER;
		
		BEGIN (*IdLenM*)
			RETURN idLenM;
		END IdLenM;
	
	(* Position next Identity's pubkey for IdNextPubkey *)
	PROCEDURE IdPosPubkey* (IN pubkey: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
		
		BEGIN (*IdPosPubkey*)
			NEW(idP);
			idP.ref := pubkey;
			b := idPubT.Search(idP);
			idPubT.Previous;
			idPubkeyCur := idPubT.GetCurrPos();
		END IdPosPubkey;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			idPubT.Next;
			idPubkeyCur := idPubT.GetCurrPos();
			IF ~idPubT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := idPubT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Browse all members' pubkeys step by step *)
	PROCEDURE IdNextPubkeyM* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextPubkeyM*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			REPEAT
				idPubT.Next;
				IF ~idPubT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
			UNTIL id.member;
			idPubkeyCur := idPubT.GetCurrPos();
			pubkey := id.pubkey;
			RETURN TRUE;
		END IdNextPubkeyM;
	
	(* Position next Identity's uid for IdNextUid *)
	PROCEDURE IdPosUid* (IN uid: ARRAY OF CHAR);
		
		VAR
			
			idU: B.String;
			b: BOOLEAN;
		
		BEGIN (*IdPosUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			b := idUidT.Search(idU);
			idUidT.Previous;
			idUidCur := idUidT.GetCurrPos();
		END IdPosUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			idUidT.Next;
			idUidCur := idUidT.GetCurrPos();
			IF ~idUidT.PosSet() THEN
				RETURN FALSE;
			END;
			uid := idUidT.CurrentKey()(B.String).c;
			RETURN TRUE;
		END IdNextUid;
	
	(* Browse all members' uid(s) lexicographically step by step *)
	PROCEDURE IdNextUidM* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		VAR
			
			id: Identity;
		
		BEGIN (*IdNextUidM*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			REPEAT
				idUidT.Next;
				IF ~idUidT.PosSet() THEN
					RETURN FALSE;
				END;
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
			UNTIL id.member;
			idUidCur := idUidT.GetCurrPos();
			uid := id.uid;
			RETURN TRUE;
		END IdNextUidM;
	
	(* (Pubkey, Pubkey) -> Certification *)
	PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertFrom*)
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				pos.posRef := certFromT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertFrom;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertTo* (IN to: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertTo*)
			NEW(p);
			p.ref := to;
			IF certToT.Search(p) THEN
				pos.posRef := certToT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertTo;
	
	(* Number of keys in sub-index *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		VAR
			
			ind: B.Index;
			n: INTEGER;
		
		BEGIN (*CertPosLen*)
			IF pos.posRef < 0 THEN
				RETURN 0;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			n := ind.NumberOfKeys();
			ind.Close;
			RETURN n;
		END CertPosLen;
	
	(* Browse all Certification's pairs of Pubkey in a sub-index step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from, to: Pubkey): BOOLEAN, NEW;
		
		VAR
			
			ind: B.Index;
			ok: BOOLEAN;
			c: Certification;
		
		BEGIN (*CertNextPos*)
			IF pos.posRef < 0 THEN
				RETURN FALSE;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.SetCurrPos(pos.posCur);
			ind.Next;
			pos.posCur := ind.GetCurrPos();
			ok := ind.PosSet();
			IF ok THEN
				c := certMan.ReadData(ind.ReadValue())(Certification);
				from := c.from;
				to := c.to;
			END;
			ind.Close;
			RETURN ok;
		END CertNextPos;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the from Pubkey *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromT.ResetPos;
			ELSE
				certFromT.SetCurrPos(certFromCur);
			END;
			certFromT.Next;
			certFromCur := certFromT.GetCurrPos();
			IF ~certFromT.PosSet() THEN
				pos.posRef := - 1;
				RETURN FALSE;
			END;
			pos.posRef := certFromT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the to Pubkey *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextTo*)
			IF first THEN
				certToT.ResetPos;
			ELSE
				certToT.SetCurrPos(certToCur);
			END;
			certToT.Next;
			certToCur := certToT.GetCurrPos();
			IF ~certToT.PosSet() THEN
				pos.posRef := - 1;
				RETURN FALSE;
			END;
			pos.posRef := certToT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextTo;
	
	PROCEDURE IsSentry* (IN pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			e: INTEGER;
		
		BEGIN (*IsSentry*)
			RETURN FindMemberNum(pubkey, e) & sentriesS.In(e);
		END IsSentry;
	
	(* Return in pubkey the next sentry's pubkey if ~first or the first one if first; return FALSE if there is no more sentry *)
	PROCEDURE NextSentry* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*NextSentry*)
			IF first THEN
				b := sentriesI.FirstE(sentryCur);
			ELSE
				b := sentriesI.NextE(sentryCur);
			END;
			IF ~b THEN
				RETURN FALSE;
			END;
			pubkey := members.m[sentryCur].p;
			RETURN TRUE;
		END NextSentry;
	
	(* Return the number of sentries *)
	PROCEDURE SentriesLen* (): INTEGER;
		
		BEGIN (*SentriesLen*)
			RETURN sentriesS.nbElems;
		END SentriesLen;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentries* (pubkeys: Pubkeys): REAL;
		
		VAR
			
			set, frontier, newFrontier: U.Set;
			frontierI: U.SetIterator;
			e, i: INTEGER;
			ok: BOOLEAN;
			poS: REAL;
			poSE: PoSE;
		
		PROCEDURE Sort (pubkeys: Pubkeys);
			
			VAR
				
				i, j: INTEGER;
				p: Pubkey;
			
			BEGIN (*Sort*)
				FOR i := 1 TO LEN(pubkeys) - 1 DO
					p := pubkeys[i];
					j := i;
					WHILE (j > 0) & (p < pubkeys[j - 1]) DO
						pubkeys[j] := pubkeys[j - 1];
						DEC(j);
					END;
					pubkeys[j] := p;
				END;
			END Sort;
		
		PROCEDURE Find (poSE: PoSE; OUT poS: REAL): BOOLEAN;
			
			VAR
				
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Find*)
				e := poSE;
				IF ~poST.Search(e, n) THEN
					RETURN FALSE;
				END;
				poS := e(PoSE).poS;
				RETURN TRUE;
			END Find;
		
		PROCEDURE Store (poSE: PoSE; poS: REAL);
			
			VAR
				
				b: BOOLEAN;
				n: INTEGER;
				e: A.Elem;
			
			BEGIN (*Store*)
				poSE.poS := poS;
				e := poSE;
				b := poST.SearchIns(e, n); ASSERT(~b, 100);
			END Store;
		
		BEGIN (*PercentOfSentries*)
			Sort(pubkeys);
			NEW(poSE);
			poSE.pubkeys := pubkeys;
			IF ~Find(poSE, poS) THEN
				set := U.NewSet();
				frontier := U.NewSet();
				FOR i := 0 TO LEN(pubkeys) - 1 DO
					IF FindMemberNum(pubkeys[i], e) THEN
						set.Incl(e);
						frontier.Incl(e);
					END;
				END;
				FOR i := 1 TO pars.stepMax - 1 DO
					newFrontier := U.NewSet();
					frontierI.Attach(frontier);
					ok := frontierI.FirstE(e);
					WHILE ok DO
						newFrontier.Add(members.m[e].links);
						ok := frontierI.NextE(e);
					END;
					frontier := newFrontier;
					set.Add(frontier);
				END;
				poS := set.Inter(sentriesS).nbElems / sentriesS.nbElems;
				Store(poSE, poS);
			END;
			RETURN poS;
		END PercentOfSentries;
	
	(* Verify the distance rule for a set of certifiers' pubkeys *)
	PROCEDURE DistanceRuleOk* (pubkeys: Pubkeys): BOOLEAN;
		
		BEGIN (*DistanceRuleOk*)
			RETURN PercentOfSentries(pubkeys) >= pars.xpercent;
		END DistanceRuleOk;
	
	(* Scan the string s from position i to the position of stop excluded; update i and return the scanned string in sub *)
	PROCEDURE ScanS (IN s: ARRAY OF CHAR; stop: CHAR; OUT sub: ARRAY OF CHAR; VAR i: INTEGER);
		
		VAR
			
			j: INTEGER;
		
		BEGIN (*ScanS*)
			j := 0;
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				sub[j] := s[i];
				INC(i); INC(j);
			END;
			sub[j] := 0X;
			INC(i);
		END ScanS;
	
	(* Skip the string s from position i to the position of stop excluded; update i *)
	PROCEDURE SkipS (IN s: ARRAY OF CHAR; stop: CHAR; VAR i: INTEGER);
		
		BEGIN (*SkipS*)
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				INC(i);
			END;
			INC(i);
		END SkipS;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params (d: S.Database);
		
		CONST
			
			txWindow = 60 * 60 * 24 * 7;
		
		VAR
			
			res: INTEGER;
			cur: S.Row;
			ss: POINTER TO ARRAY OF CHAR;
			s: ARRAY 20 OF CHAR;
			t: S.Table;
			i: INTEGER;
		
		BEGIN (*Params*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT parameters FROM block WHERE number = 0 AND NOT fork");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT(t.columns = 1, 102); ASSERT(t.rows = 1, 103);
			 t.Read(0, cur);
			ss := cur.fields[0];
			ss[LEN(ss$)] := ':';
			i := 0;
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.c, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dt, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.ud0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigPeriod, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigStock, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigQty, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.idtyWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.xpercent, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.stepMax, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.medianTimeBlocks, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.avgGenTime, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtDiffEval, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.percentRot, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToLInt(s, pars.udReevalTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtReeval, res); ASSERT(res = 0, 104);
			pars.txWindow := txWindow;
			pars.msPeriod := pars.msWindow;
			pars.sigReplay := pars.msPeriod;
		END Params;
	
	(* Add a block in timeT *)
	PROCEDURE Times (withList: BOOLEAN; IN s1, s2: ARRAY OF CHAR);
		
		VAR
			
			t: Time;
			i: IntKey;
			res, tRef: INTEGER;
			b: BOOLEAN;
			tL: UndoList; (* timeList *)
		
		BEGIN (*Times*)
			NEW(t);
			Strings.StringToInt(s1, t.bnb, res); ASSERT(res = 0, 100);
			Strings.StringToLInt(s2, t.mTime, res); ASSERT(res = 0, 101);
			lastBlock := t.bnb;
			tRef := timeMan.WriteAllocateData(t);
			NEW(i); i.ref := t.bnb;
			b := timeT.SearchIns(i); ASSERT(~b, 102);
			timeT.WriteValue(tRef);
			IF withList THEN
				NEW(tL); tL.next := undoList; tL.type := timeList; tL.ref := tRef; tL.aux := 0;
				undoList := undoListMan.WriteAllocateData(tL);
			END;
			now := t.mTime;
		END Times;
	
	PROCEDURE RevokeId (withList: BOOLEAN; IN p: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
			idRef: INTEGER;
			id: Identity;
			idL: UndoList; (* leaversList *)
		
		BEGIN (*RevokeId*)
			NEW(idP); idP.ref := p;
			b := idPubT.Search(idP); ASSERT(b, 100);
			idRef := idPubT.ReadValue();
			id := idMan.ReadData(idRef)(Identity);
			IF withList THEN
				NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
				undoList := undoListMan.WriteAllocateData(idL);
			END;
			id.expires_on := BA.revoked;
			idMan.WriteData(idRef, id);
		END RevokeId;
	
	(* For one block, add joining & leaving identities in joinAndLeaveT and updade identities in idPubT and idUidT; update certFromT & certToT too *)
	PROCEDURE Identities (withList: BOOLEAN; IN ssJ, ssA, ssL, ssR, ssE, nb: ARRAY OF CHAR; t: S.Table);
		
		VAR
			
			i, idRef, n, res, bnb: INTEGER;
			s: ARRAY 101 OF CHAR;
			b: BOOLEAN;
			id, oldId: Identity;
			p: Pubkey;
			idP: PubKey;
			idU: B.String;
			idH: HashKey;
			idL: UndoList; (* joinList, activeList *)
			cur: S.Row;
			iK: IntKey;
		
		BEGIN (*Identities*)
			i := 1;
			WHILE ssJ[i] # ']' DO (* joiners : Insert id *)
				INC(i);
				INC(idLenM);
				NEW(id);
				id.member := TRUE;
				ScanS(ssJ, ':', id.pubkey, i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 100);
				b := TimeOf(n, id.application); ASSERT(b, 101);
				id.expires_on := id.application + pars.msValidity;
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '"', s, i); NEW(id.uid, LEN(s$) + 1); id.uid^ := s$;
				IF ssJ[i] # ']' THEN
					INC(i);
				END;
				REPEAT
					t.Exec("SELECT hash FROM i_index WHERE pub = '" + id.pubkey + "' ORDER BY writtenOn ASC");
					ASSERT(t.res IN {0, 6}, 102);
				UNTIL t.res = 0;
				ASSERT((t.rows = 0) OR (t.columns = 1), 103);
				id.hash := "";
				FOR n := 0 TO t.rows - 1 DO
					t.Read(n, cur);
					IF (cur.fields[0] # NIL) & (cur.fields[0]$ # "") THEN
						id.hash := cur.fields[0]$;
					END;
				END;
				ASSERT(id.hash # "", 104);
				Strings.StringToInt(nb, id.block_number, res); ASSERT(res = 0, 105);
				bnb := id.block_number;
				NEW(idU); NEW(idU.c, LEN(id.uid$) + 1); idU.c^ := id.uid$;
				NEW(idP); idP.ref := id.pubkey;
				NEW(idH); idH.ref := id.hash;
				IF idPubT.SearchIns(idP) THEN
					idRef := idPubT.ReadValue();
					oldId := idMan.ReadData(idRef)(Identity);
					ASSERT(~oldId.member & (oldId.uid$ = id.uid$) & (oldId.hash = id.hash), 106);
					NEW(iK); iK.ref := idRef;
					b := idTimeT.Erase(iK);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
					id.block_number := oldId.block_number;
					idMan.WriteData(idRef, id);
					b := idUidT.SearchIns(idU); ASSERT(b, 107);
					ASSERT(idUidT.ReadValue() = idRef, 108);
					b := idHashT.SearchIns(idH); ASSERT(b, 109);
					ASSERT(idHashT.ReadValue() = idRef, 110);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := oldId.expires_on; idL.aux2 := oldId.application;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				ELSE
					idRef := idMan.WriteAllocateData(id);
					idPubT.WriteValue(idRef);
					b := idUidT.SearchIns(idU); ASSERT(~b, 111);
					idUidT.WriteValue(idRef);
					b := idHashT.SearchIns(idH); ASSERT(~b, 112);
					idHashT.WriteValue(idRef);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := joinList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
			END;
			
			i := 1;
			WHILE ssA[i] # ']' DO (* actives *)
				INC(i);
				NEW(idP);
				ScanS(ssA, ':', idP.ref, i);
				SkipS(ssA, ':', i);
				ScanS(ssA, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 113);
				SkipS(ssA, '"', i);
				IF ssA[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 114);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 115);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.application); ASSERT(b, 116);
				id.expires_on := id.application + pars.msValidity;
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssL[i] # ']' DO (* leavers *)
				INC(i);
				NEW(idP);
				ScanS(ssL, ':', idP.ref, i);
				SkipS(ssL, ':', i);
				ScanS(ssL, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 117);
				SkipS(ssL, '"', i);
				IF ssL[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 118);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.application); ASSERT(b, 119);
				id.expires_on := - ABS(id.expires_on); (* id.expires_on < 0 if leaving *)
				idMan.WriteData(idRef, id);
			END;
			
			i := 1;
			WHILE ssR[i] # ']' DO (* revoked *)
				INC(i);
				ScanS(ssR, ':', p, i);
				SkipS(ssR, '"', i);
				IF ssR[i] # ']' THEN
					INC(i);
				END;
				NEW(idP); idP.ref := p;
				b := idPubT.Search(idP); ASSERT(b, 120);
				idRef := idPubT.ReadValue();
				NEW(iK); iK.ref := idRef;
				IF idTimeT.Erase(iK) & withList THEN
					NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				RevokeId(withList, p);
			END;
			
			i := 1;
			WHILE ssE[i] # ']' DO (* excluded *)
				INC(i);
				DEC(idLenM);
				NEW(idP);
				ScanS(ssE, '"', idP.ref, i);
				IF ssE[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 121);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				ASSERT(id.member, 122);
				id.member := FALSE;
				idMan.WriteData(idRef, id);
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := leaveList; idL.ref := idRef; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				IF id.expires_on # BA.revoked THEN
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on; idL.aux2 := id.application;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
					IF id.expires_on >= 0 THEN (* ~leaving *)
						INC(id.expires_on, pars.msValidity);
					ELSE
						DEC(id.expires_on, pars.msValidity);
					END;
					idMan.WriteData(idRef, id);
					NEW(iK); iK.ref := idRef;
					b := idTimeT.SearchIns(iK); ASSERT(~b, 123);
					IF withList THEN
						NEW(idL); idL.next := undoList; idL.type := idAddTimeList; idL.ref := idRef; idL.aux := 0;
						undoList := undoListMan.WriteAllocateData(idL);
					END;
				END;
			END;
		END Identities;
	
	(* Add certifications of one block in certFromT, certToT and certTimeT *)
	PROCEDURE Certifications (withList: BOOLEAN; IN ss, nb: ARRAY OF CHAR);
		
		VAR
			
			i, n, res, pC, oldPC: INTEGER;
			b: BOOLEAN;
			c: Certification;
			idP: PubKey;
			cL: UndoList; (*certAddList *)
			ind: B.Index;
			iK: IntKey;
			s: ARRAY 11 OF CHAR;
		
		BEGIN (*Certifications*)
			i := 1;
			WHILE ss[i] # ']' DO
				INC(i);
				NEW(c);
				ScanS(ss, ':', c.from, i);
				ScanS(ss, ':', c.to, i);
				ScanS(ss, ':', s, i);
				SkipS(ss, '"', i);
				IF ss[i] # ']' THEN
					INC(i);
				END;
				Strings.StringToInt(nb, c.block_number, res); ASSERT(res = 0, 100);
				Strings.StringToInt(s, n, res); ASSERT(res = 0, 101);
				b := TimeOf(n, c.expires_on); ASSERT(b, 102);
				INC(c.expires_on, pars.sigValidity);
				pC := certMan.WriteAllocateData(c);
				NEW(idP);
				idP.ref := c.from;
				IF certFromT.SearchIns(idP) THEN
					n := certFromT.ReadValue();
				ELSE
					n := database.CreateIndex(pubKeyS);
					certFromT.WriteValue(n);
				END;
				idP.ref := c.to;
				ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
				IF ind.SearchIns(idP) THEN
					oldPC := ind.ReadValue();
				ELSE
					oldPC := B.bNil;
				END;
				ind.WriteValue(pC);
				ind.Close;
				idP.ref := c.to;
				IF certToT.SearchIns(idP) THEN
					n := certToT.ReadValue();
				ELSE
					n := database.CreateIndex(pubKeyS);
					certToT.WriteValue(n);
				END;
				idP.ref := c.from;
				ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP);
				ind.WriteValue(pC);
				ind.Close;
				NEW(iK);
				IF oldPC # B.bNil THEN
					iK.ref := oldPC;
					b := certTimeT.Erase(iK); ASSERT(b, 103);
				END;
				iK.ref := pC;
				b := certTimeT.SearchIns(iK); ASSERT(~b, 104);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certAddList; cL.ref := pC; cL.aux := oldPC;
					undoList := undoListMan.WriteAllocateData(cL);
				ELSIF oldPC # B.bNil THEN
					certMan.EraseData(oldPC);
				END;
			END;
		END Certifications;
	
	(* Remove c keys from certFromT and certToT *)
	PROCEDURE RemoveCert (c: Certification);
		
		VAR
			
			pKFrom, pKTo: PubKey;
			b, empty: BOOLEAN;
			n: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveCert*)
			NEW(pKFrom); NEW(pKTo);
			pKFrom.ref := c.from; pKTo.ref := c.to;
			
			b := certFromT.Search(pKFrom); ASSERT(b, 100);
			n := certFromT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKTo); ASSERT(b, 101);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certFromT.Erase(pKFrom); ASSERT(b, 102);
			END;
			
			b := certToT.Search(pKTo); ASSERT(b, 103);
			n := certToT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKFrom); ASSERT(b, 104);
			empty := ind.IsEmpty();
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certToT.Erase(pKTo); ASSERT(b, 105);
			END;
		END RemoveCert;
	
	(* Remove expired certifications from certFromT and certToT *)
	PROCEDURE RemoveExpiredCerts (now, secureNow: LONGINT);
		
		VAR
			
			c: Certification;
			iK: IntKey;
			b, withList: BOOLEAN;
			pC: INTEGER;
			cL: UndoList; (* certRemoveList *)
		
		BEGIN (*RemoveExpiredCerts*)
			NEW(c); c.expires_on := now; c.from := "";
			pC := certMan.WriteAllocateData(c);
			NEW(iK); iK.ref := pC;
			b := certTimeT.Search(iK);
			certMan.EraseData(pC);
			WHILE certTimeT.PosSet() DO
				pC := certTimeT.CurrentKey()(IntKey).ref;
				certTimeT.Next;
				c := certMan.ReadData(pC)(Certification);
				RemoveCert(c);
				withList := c.expires_on >= secureNow;
				iK.ref := pC;
				b := certTimeT.Erase(iK); ASSERT(b, 100);
				IF withList THEN
					NEW(cL); cL.next := undoList; cL.type := certRemoveList; cL.ref := pC; cL.aux := 0;
					undoList := undoListMan.WriteAllocateData(cL);
				ELSE
					certMan.EraseData(pC);
				END;
			END;
		END RemoveExpiredCerts;
	
	PROCEDURE RevokeExpiredIds (now, secureNow: LONGINT);
		
		VAR
			
			id: Identity;
			iK: IntKey;
			b, withList: BOOLEAN;
			pId: INTEGER;
			idL: UndoList;
		
		BEGIN (*RevokeExpiredIds*)
			NEW(id); id.expires_on := now; id.pubkey := ""; NEW(id.uid, 1); id.uid^ := "";
			pId := idMan.WriteAllocateData(id);
			NEW(iK); iK.ref := pId;
			b := idTimeT.Search(iK);
			idMan.EraseData(pId);
			WHILE idTimeT.PosSet() DO
				pId := idTimeT.CurrentKey()(IntKey).ref;
				idTimeT.Next;
				id := idMan.ReadData(pId)(Identity);
				iK.ref := pId;
				b := idTimeT.Erase(iK); ASSERT(b, 100);
				withList := ABS(id.expires_on) >= secureNow;
				IF withList THEN
					NEW(idL); idL.next := undoList; idL.type := idRemoveTimeList; idL.ref := pId; idL.aux := 0;
					undoList := undoListMan.WriteAllocateData(idL);
				END;
				RevokeId(withList, id.pubkey);
			END;
		END RevokeExpiredIds;
	
	(* Undo the last operations done from the secureGap last blocks *)
	PROCEDURE RemoveSecureGap;
		
		VAR
			
			b: BOOLEAN;
			i: IntKey;
			p: PubKey;
			u: B.String;
			h: HashKey;
			t: Time;
			id: Identity;
			c: Certification;
			l: UndoList;
			n: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveSecureGap*)
			WHILE undoList # B.bNil DO
				l := undoListMan.ReadData(undoList)(UndoList);
				CASE l.type OF
					|timeList:
						(* Erase the Time data pointed by l.ref and the corresponding key in timeT *)
						t := timeMan.ReadData(l.ref)(Time);
						NEW(i); i.ref := t.bnb;
						b := timeT.Erase(i); ASSERT(b, 100);
						timeMan.EraseData(l.ref);
					|idAddList:
						(* Erase the Identity data pointed by l.ref and the corresponding keys in idPubT, idHashT and idUidT *)
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.Erase(p); ASSERT(b, 101);
						NEW(u); u.c := id.uid;
						b := idUidT.Erase(u); ASSERT(b, 102);
						NEW(h); h.ref := id.hash;
						b := idHashT.Erase(h); ASSERT(b, 103);
						idMan.EraseData(l.ref);
					|joinList:
						(* Let the identity be no more member *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := FALSE;
						idMan.WriteData(l.ref, id);
						DEC(idLenM);
					|activeList:
						(* Undo the Identity.expires_on update *)
						id := idMan.ReadData(l.ref)(Identity);
						id.expires_on := l.aux;
						id.application := l.aux2;
						idMan.WriteData(l.ref, id);
					|leaveList:
						(* Update the last JoinAndLeaveL data corresponding to l.ref *)
						id := idMan.ReadData(l.ref)(Identity);
						id.member := TRUE;
						idMan.WriteData(l.ref, id);
						INC(idLenM);
					|idAddTimeList:
						NEW(i); i.ref := l.ref;
						b := idTimeT.Erase(i); ASSERT(b, 104);
					|idRemoveTimeList:
						NEW(i); i.ref := l.ref;
						b := idTimeT.SearchIns(i); ASSERT(~b, 105);
					|certAddList:
						(* Erase the keys corresponding to the certification pointed by l.ref in certFromT and certToT, or, if l.aux # B.bNil, update them; modify Identity. certifiers and Identity.certified as needed *)
						c := certMan.ReadData(l.ref)(Certification);
						NEW(i); i.ref := l.ref;
						b := certTimeT.Erase(i); ASSERT(b, 106);
						IF l.aux = B.bNil THEN
							RemoveCert(c);
						ELSE
							NEW(p);
							p.ref := c.from;
							b := certFromT.Search(p); ASSERT(b, 107);
							n := certFromT.ReadValue();
							ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
							p.ref := c.to;
							b := ind.Search(p); ASSERT(b, 108);
							ind.WriteValue(SHORT(l.aux));
							ind.Close;
							p.ref := c.to;
							b := certToT.Search(p); ASSERT(b, 109);
							n := certToT.ReadValue();
							ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
							p.ref := c.from;
							b := ind.Search(p); ASSERT(b, 110);
							ind.WriteValue(SHORT(l.aux));
							ind.Close;
							i.ref := SHORT(l.aux);
							b := certTimeT.SearchIns(i); ASSERT(~b, 111);
						END;
						certMan.EraseData(l.ref);
					|certRemoveList:
						(* Insert the keys corresponding to the Certification pointed by l.ref into certFromT, certToT and certTimeT *)
						c := certMan.ReadData(l.ref)(Certification);
						NEW(p);
						p.ref := c.from;
						IF certFromT.SearchIns(p) THEN
							n := certFromT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certFromT.WriteValue(n);
						END;
						p.ref := c.to;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 112);
						ind.WriteValue(l.ref);
						ind.Close;
						IF certToT.SearchIns(p) THEN
							n := certToT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certToT.WriteValue(n);
						END;
						p.ref := c.from;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 113);
						ind.WriteValue(l.ref);
						ind.Close;
						NEW(i); i.ref := l.ref;
						b := certTimeT.SearchIns(i); ASSERT(~b, 114);
				END;
				undoListMan.EraseData(undoList);
				undoList := l.next;
			END;
		END RemoveSecureGap;
	
	(* Initialize members and sentriesS / sentriesI *)
	PROCEDURE CalculateSentries;
		
		VAR
			
			ok, b: BOOLEAN;
			pos: CertPos;
			p, to: Pubkey;
			i, e, n: INTEGER;
		
		BEGIN (*CalculateSentries*)
			members.len := IdLen();
			NEW(members.m, members.len + 1);
			i := 0;
			ok := IdNextPubkey(TRUE, p);
			WHILE ok DO
				ASSERT((i = 0) OR (p > members.m[i - 1].p), 100);
				members.m[i].p := p;
				members.m[i].links := U.NewSet();
				INC(i);
				ok := IdNextPubkey(FALSE, p);
			END;
			ASSERT(i = members.len, 101);
			FOR i := 0 TO members.len - 1 DO
				ok := CertTo(members.m[i].p, pos) & pos.CertNextPos(p, to);
				WHILE ok DO
					b := FindMemberNum(p, e); ASSERT(b, 102);
					members.m[i].links.Incl(e);
					ok := pos.CertNextPos(p, to);
				END;
			END;
			
			sentriesS := U.NewSet(); sentriesI.Attach(sentriesS);
			n := IdLenM();
			IF n = 0 THEN RETURN END;
			n := SHORT(ENTIER(Math.Ceiling(Math.Power(n, 1 / pars.stepMax))));
			ok := IdNextPubkeyM(TRUE, p);
			WHILE ok DO
				IF CertFrom(p, pos) & (pos.CertPosLen() >= n) & CertTo(p, pos) & (pos.CertPosLen() >= n) THEN
					b := FindMemberNum(p, e); ASSERT(b, 103);
					sentriesS.Incl(e);
				END;
				ok := IdNextPubkeyM(FALSE, p);
			END;
			
			A.New(poST);
		END CalculateSentries;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks (d: S.Database);
		
		VAR
			
			cur: S.Row;
			t, tt: S.Table;
			i, res, lastN: INTEGER;
			s: ARRAY 13 OF CHAR;
			withList: BOOLEAN;
			now, secureNow: LONGINT;
		
		BEGIN (*ScanBlocks*)
			idLenM := database.ReadPlace(idLenPlace);
			undoList := database.ReadPlace(undoListPlace);
			RemoveSecureGap;
			lastN := database.ReadPlace(lastNPlace);
			Strings.IntToString(lastN - secureGap, s);
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT number, medianTime, joiners, actives, leavers, revoked, excluded, certifications FROM block WHERE NOT fork AND number >= " + s + " ORDER BY number ASC");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 8), 102);
			tt := d.NewTable(); ASSERT(tt # NIL, 103);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, cur);
				withList := i >= t.rows - secureGap;
				Times(withList , cur.fields[0], cur.fields[1]);
				Identities(withList, cur.fields[2], cur.fields[3], cur.fields[4], cur.fields[5], cur.fields[6], cur.fields[0], tt);
				Certifications(withList, cur.fields[7], cur.fields[0]);
			END;
			IF t.rows > 0 THEN
				t.Read(t.rows - 1, cur);
				Strings.StringToLInt(cur.fields[1], now, res); ASSERT(res = 0, 104);
				IF secureGap = 0 THEN
					secureNow := MAX(LONGINT);
				ELSE
					IF t.rows >= secureGap THEN
						t.Read(t.rows - secureGap, cur);
					ELSE
						t.Read(0, cur);
					END;
					Strings.StringToLInt(cur.fields[1], secureNow, res); ASSERT(res = 0, 105);
				END;
				RevokeExpiredIds(now, secureNow);
				RemoveExpiredCerts(now, secureNow); (* Élimine toutes les certifications expirées avec réversibilité dans secureGap *)
			END;
			database.WritePlace(undoListPlace, undoList);
			IF lastN <= secureGap THEN
				lastN := t.rows;
			ELSE
				INC(lastN, t.rows - secureGap);
			END;
			database.WritePlace(lastNPlace, lastN);
			database.WritePlace(idLenPlace, idLenM);
			database.UpdateBase;
			IF t.rows > 0 THEN
				CalculateSentries;
			END;
		END ScanBlocks;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList; m := NIL;
			WHILE l # NIL DO
				m := l;
				l := l.next;
			END;
			NEW(l);
			l.next := NIL;
			l.update := updateProc;
			IF m = NIL THEN
				updateList := l;
			ELSE
				m.next := l;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList; m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			ASSERT(l # NIL, 20);
			IF m = NIL THEN
				updateList := l.next;
			ELSE
				m.next := l.next;
			END;
		END RemoveUpdateProc;
	
	(* Scan the Duniter database *)
	PROCEDURE Scan;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
			t: LONGINT;
			s: BA.TimeString;
			dt: BA.DateTime;
			ss: ARRAY 11 OF CHAR;
		
		BEGIN (*Scan*)
			L.log.Msg("Updating blockchain in DBase.data");
			t := Services.Ticks();
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res);
			IF res # 0 THEN L.log.Err(100 + res, duniBase); END;
			ScanBlocks(d);
			BA.TimeToString(Services.Ticks() - t, s);
			L.log.Msg("End updating blockchain in DBase.data. Time spent: " + s);
			BA.TimestampToString(now, dt);
			Strings.IntToString(LastBlock(), ss);
			L.log.Msg("It is now " + dt + " - block " + ss);
		END Scan;
	
	(* Scan the Duniter parameters in block 0 *)
	PROCEDURE Scan1;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan1*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res);
			IF res # 0 THEN L.log.Err(100 + res, duniBase); END;
			Params(d);
		END Scan1;
	
	PROCEDURE UpdateAll*;
		
		VAR
			
			l: UpdateList;
		
		BEGIN (*UpdateAll*)
			l := updateList;
			WHILE l # NIL DO
				l.update;
				l := l.next;
			END;
			BA.Collect;
		END UpdateAll;
	
	PROCEDURE Init;
		
		VAR
			
			l: Files.Locator;
			v: Views.View;
			s: TextMappers.Scanner;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			name: Files.Name;
			res: INTEGER;
			ti: LONGINT;
			ss: BA.TimeString;
		
		BEGIN (*Init*)
			duniBase := '';
			l := Files.dir.This(initDir); L.log.Err(l.res, initDir);
			v := Views.OldView(l, initName);
			IF v = NIL THEN
				duniBase := duniBaseDef;
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString('"' + duniBase + '"');
				name := initName;
				Views.Register(TextViews.dir.New(t), Views.dontAsk, l, name, BA.utf8Conv, res);
				L.log.Err(res, name);
			ELSE
				ASSERT(v IS TextViews.View, 100);
				s.ConnectTo(v(TextViews.View).ThisModel());
				s.Scan;
				IF s.type = TextMappers.string THEN
					duniBase := s.string$;
				END;
			END;
			L.log.Msg("Duniter database: " + duniBase);
			now := 0;
			L.log.Msg("Scan of block 0");
			ti := Services.Ticks();
			Scan1;
			BA.TimeToString(Services.Ticks() - ti, ss);
			L.log.Msg("End of scan of block 0. Time spent: " + ss);
			updateList := NIL;
			AddUpdateProc(Scan);
			NEW(undoListFac); NEW(timeFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan);
			NEW(hashKeyFac); NEW(hashKeyMan);
			NEW(intKeyMan); NEW(idKTimeMan); NEW(certKTimeMan);
			OpenB;
		END Init;
	
	BEGIN (*DuniterBlockchain*)
		Init;
	CLOSE
		CloseB;
	END DuniterBlockchain.
