(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterBlockchain;
	
	
	
	(* Collect blockchain data; server version *)
	
	IMPORT
		
		(*
		StdLog,
		*)
		
		A := UtilAvlTree, B := UtilBBTree, BA := DuniterBasic, L := DuniterLog, Files, Math, Services, S := SqlDB, Strings, TextMappers, TextModels, TextViews, Views;
	
	CONST
		
		(* Default path to the Duniter database *)
		duniBaseDef = "D:\.config\duniter\duniter_default\duniter.db";
		
		(* Driver SQLite *)
		driver* = "SQLiteDriver";
		
		(* Directory & name of the file where the path to the Duniter database is written *)
		initDir = "Duniter/Rsrc";
		initName = "Init.txt";
		
		pageNb = 2000; (* Number of pages used by UtilBTree *)
		
		pubkeyLen* = 44; (* Max length of a Pubkey *)
		
		hashLen* = 64;
		
		secureGap = 100; (* Number of last blocks to be read again at every update, since they could have changed *)
		
		dBase = "Duniter\DBase.data"; (* Name of the WotWizard database, in the WotWizard.exe directory *)
		
		(* Numbers of the places of the indexes in dBase *)
		timePlace = 0;
		joinAndLeavePlace = 1;
		idPubPlace = 2;
		idUidPlace = 3;
		certFromPlace = 4;
		certToPlace = 5;
		certTimePlace = 6;
		
		listPlace = 7; (* Head of the chained list of the operations to be undone before every update *)
		lastNPlace = 8; (* Last read block *)
		
		placeNb = 9; (* Number of places *)
	
	TYPE
		
		UpdateProc* = PROCEDURE; (* Procedure called at every update *)
		
		UpdateList = POINTER TO RECORD (* Chained list of procedures called at every update *)
			next: UpdateList;
			update: UpdateProc;
		END;
		
		String* = POINTER TO ARRAY OF CHAR;
		Pubkey* = ARRAY pubkeyLen + 1 OF CHAR;
		Hash* = ARRAY hashLen + 1 OF CHAR;
		
		(* Duniter Parameters *)
		Parameters* = RECORD
			c-: REAL;
			dt-,
			ud0-,
			sigPeriod-,
			sigStock-,
			sigWindow-,
			sigValidity-,
			sigQty-,
			idtyWindow-,
			msWindow-,
			msPeriod-: INTEGER;
			xpercent-: REAL;
			msValidity-,
			stepMax-,
			medianTimeBlocks-,
			avgGenTime-,
			dtDiffEval-: INTEGER;
			percentRot-: REAL;
			udTime0-,
			udReevalTime0-,
			dtReeval-,
			txWindow-: INTEGER;
		END;
	
	CONST
		
		(* Types of elements in List *)
		timeList = 0;
		joinList = 1;
		leaveList = 2;
		certAddList = 3;
		certRemoveList = 4;
		activeList = 5;
		
		hasNotLeaved* = -1;
	
	TYPE
		
		(* Chained list of the operations to be undone before every update *)
		List = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			next: INTEGER;
			type: BYTE;
			(* timeList -> Time; joinList, activeList, leaveList -> Identity; certAddList, certRemoveList -> Certification *)
			ref: INTEGER;
			aux: LONGINT;
		END;
		
		ListFac = POINTER TO RECORD (B.DataFac) (* Factory of List *)
		END;
		
		(* Blocks and their times *)
		Time = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			bnb: INTEGER;
			mTime,
			time: LONGINT;
		END;
		
		TimeFac = POINTER TO RECORD (B.DataFac) (* Factory of Time *)
		END;
		
		JoinAndLeaveL = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			next,
			joiningBlock, (* Block numbers *)
			leavingBlock: INTEGER;
		END;
		
		JoinAndLeaveLFac = POINTER TO RECORD (B.DataFac) (* Factory of JoinAndLeaveL *)
		END;
		
		JoinAndLeave = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			pubkey: Pubkey;
			list: INTEGER; (* JoinAndLeaveL *)
		END;
		
		JoinAndLeaveFac = POINTER TO RECORD (B.DataFac) (* Factory of JoinAndLeave *)
		END;
		
		Identity = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			pubkey: Pubkey;
			uid: String;
			hash: Hash;
			block_number: INTEGER; (* Where the Identity is written *)
			expires_on: LONGINT;
		END;
		
		IdentityFac = POINTER TO RECORD (B.DataFac) (* Factory of Identity *)
		END;
		
		Certification = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			from,
			to: Pubkey;
			block_number: INTEGER; (* Where the Certification is written *)
			expires_on: LONGINT;
		END;
		
		CertificationFac = POINTER TO RECORD (B.DataFac) (* Factory of Certification *)
		END;
		
		(* Integer index key *)
		IntKey = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			ref: INTEGER;
		END;
		
		IntKeyFac = POINTER TO RECORD (B.DataFac) (* Factory of IntKey *)
		END;
		
		IntKeyMan = POINTER TO RECORD (B.KeyManager) (* Manager of IntKey *)
		END;
		
		(* Pubkey index key *)
		PubKey = POINTER TO RECORD (B.Data)
			dataType: BYTE;
			ref: Pubkey;
		END;
		
		PubKeyFac = POINTER TO RECORD (B.DataFac) (* Factory of PubKey *)
		END;
		
		PubKeyMan = POINTER TO RECORD (B.KeyManager) (* Manager of PubKey *)
		END;
		
		(* Uid index key manager *)
		UidKeyManager = POINTER TO RECORD (B.StringKeyManager) 
		END;

		
		(* Manager of Certification sorted by expiration dates *)
		CertKTimeMan = POINTER TO RECORD (B.KeyManager)
		END;
		
		(* Current position in a Certification sub-index *)
		CertPos* = RECORD
			posRef: INTEGER; (* Root of the sub-index *)
			posCur: B.IndexPos; (* Position in the sub-index *)
		END;
		
		(* Element of sentriesT *)
		SentriesE = POINTER TO RECORD (A.Elem)
			pubkey: Pubkey;
		END;
	
	CONST
		
		(* Types of Data *)
		listType = 1;
		timeType = 2;
		joinAndLeaveLType = 3;
		joinAndLeaveType = 4;
		identityType = 5;
		certificationType = 6;
		intKeyType = 7;
		pubKeyType = 8;
		
		(* Sizes of B.Data *)
		pubKeyS = (pubkeyLen + 1) * B.CHS;
	
	VAR
		
		duniBase-: Files.Name; (* Path to the Duniter database *)
		
		updateList: UpdateList; (* Head of UpdateList *)
		
		pars-: Parameters; (* Duniter parmeters *)
		
		database: B.Database; (* WotWizard database *)
		
		(* UtilBTree indexes *)
		timeT, (* IntKey -> Time *)
		joinAndLeaveT, (* PubKey -> JoinAndLeave *)
		idPubT, (* PubKey -> Identity *)
		idUidT, (* B.String -> Identity *)
		certFromT, certToT, (* PubKey -> sub-index(PubKey -> Certification) *)
		certTimeT: B.Index; (* IntKey -> nothing; addresses of Certification sorted by expiration dates *)
		
		sentriesT: A.Tree; (* AVL tree of sentries *)
		
		list: INTEGER; (* Head of List *)
		
		(* Current positions in indexes *)
		jlPubkeyCur,
		idPubkeyCur,
		idUidCur,
		certFromCur,
		certToCur: B.IndexPos;
		sentryCur: A.Elem;
		
		lastBlock: INTEGER; (* Last read & updated block *)
		now, rNow: LONGINT; (* Present medianTime and time *)
		
		(* Factories *)
		listFac: ListFac;
		timeFac: TimeFac;
		joinAndLeaveLFac: JoinAndLeaveLFac;
		joinAndLeaveFac: JoinAndLeaveFac;
		identityFac: IdentityFac;
		certificationFac: CertificationFac;
		intKeyFac: IntKeyFac;
		uidKeyFac: B.StringFac;
		pubKeyFac: PubKeyFac;
		
		(* Data managers *)
		timeMan,
		joinAndLeaveLMan,
		joinAndLeaveMan,
		idMan,
		certMan,
		listMan: B.DataMan;
		
		(* Key managers *)
		pubKeyMan: PubKeyMan;
		uidKeyMan: UidKeyManager;
		intKeyMan: IntKeyMan;
		certKTimeMan: CertKTimeMan;
	
	(* Data & Data factories procedures *)
	
	PROCEDURE (t: Time) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			t.dataType := r.InByte(); ASSERT(t.dataType = timeType, 100);
			t.bnb := r.InInt();
			t.mTime := r.InLInt();
			t.time := r.InLInt();
		END Read;
	
	PROCEDURE (t: Time) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			t.dataType := timeType; w.OutByte(t.dataType);
			w.OutInt(t.bnb);
			w.OutLInt(t.mTime);
			w.OutLInt(t.time);
		END Write;
	
	PROCEDURE (tf: TimeFac) New (size: INTEGER): Time;
		
		VAR
			
			t: Time;
		
		BEGIN (*New*)
			NEW(t);
			RETURN t;
		END New;
	
	PROCEDURE (jlL: JoinAndLeaveL) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jlL.dataType := r.InByte(); ASSERT(jlL.dataType = joinAndLeaveLType, 100);
			jlL.next := r.InInt();
			jlL.joiningBlock := r.InInt();
			jlL.leavingBlock := r.InInt();
		END Read;
	
	PROCEDURE (jlL: JoinAndLeaveL) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			jlL.dataType := joinAndLeaveLType; w.OutByte(jlL.dataType);
			w.OutInt(jlL.next);
			w.OutInt(jlL.joiningBlock);
			w.OutInt(jlL.leavingBlock);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveLFac) New (size: INTEGER): JoinAndLeaveL;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*New*)
			NEW(jlL);
			RETURN jlL;
		END New;
	
	PROCEDURE (jl: JoinAndLeave) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			jl.dataType := r.InByte(); ASSERT(jl.dataType = joinAndLeaveType, 100);
			r.InChars(jl.pubkey);
			jl.list := r.InInt();
		END Read;
	
	PROCEDURE (jl: JoinAndLeave) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			jl.dataType := joinAndLeaveType; w.OutByte(jl.dataType);
			w.OutChars(jl.pubkey);
			w.OutInt(jl.list);
		END Write;
	
	PROCEDURE (jlf: JoinAndLeaveFac) New (size: INTEGER): JoinAndLeave;
		
		VAR
			
			jl: JoinAndLeave;
		
		BEGIN (*New*)
			NEW(jl);
			RETURN jl;
		END New;
	
	PROCEDURE (id: Identity) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			id.dataType := r.InByte(); ASSERT(id.dataType = identityType, 100);
			r.InChars(id.pubkey);
			NEW(id.uid, r.InCharsLen() + 1);
			r.InChars(id.uid);
			r.InChars(id.hash);
			id.block_number := r.InInt();
			id.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (id: Identity) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			id.dataType := identityType; w.OutByte(id.dataType);
			w.OutChars(id.pubkey);
			w.OutChars(id.uid);
			w.OutChars(id.hash);
			w.OutInt(id.block_number);
			w.OutLInt(id.expires_on);
		END Write;
	
	PROCEDURE (idf: IdentityFac) New (size: INTEGER): Identity;
		
		VAR
			
			id: Identity;
		
		BEGIN (*New*)
			NEW(id);
			RETURN id;
		END New;
	
	PROCEDURE (c: Certification) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			c.dataType := r.InByte(); ASSERT(c.dataType = certificationType, 100);
			r.InChars(c.from);
			r.InChars(c.to);
			c.block_number := r.InInt();
			c.expires_on := r.InLInt();
		END Read;
	
	PROCEDURE (c: Certification) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			c.dataType := certificationType; w.OutByte(c.dataType);
			w.OutChars(c.from);
			w.OutChars(c.to);
			w.OutInt(c.block_number);
			w.OutLInt(c.expires_on);
		END Write;
	
	PROCEDURE (cf: CertificationFac) New (size: INTEGER): Certification;
		
		VAR
			
			c: Certification;
		
		BEGIN (*New*)
			NEW(c);
			RETURN c;
		END New;
	
	PROCEDURE (l: List) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			l.dataType := r.InByte(); ASSERT(l.dataType = listType, 100);
			l.next := r.InInt();
			l.type := r.InByte();
			l.ref := r.InInt();
			l.aux := r.InLInt();
		END Read;
	
	PROCEDURE (l: List) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			l.dataType := listType; w.OutByte(l.dataType);
			w.OutInt(l.next);
			w.OutByte(l.type);
			w.OutInt(l.ref);
			w.OutLInt(l.aux);
		END Write;
	
	PROCEDURE (lf: ListFac) New (size: INTEGER): List;
		
		VAR
			
			l: List;
		
		BEGIN (*New*)
			NEW(l);
			RETURN l;
		END New;
	
	PROCEDURE (i: IntKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			i.dataType := r.InByte(); ASSERT(i.dataType = intKeyType, 100);
			i.ref := r.InInt();
		END Read;
	
	PROCEDURE (i: IntKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			i.dataType := intKeyType; w.OutByte(i.dataType);
			w.OutInt(i.ref);
		END Write;
	
	PROCEDURE (if: IntKeyFac) New (size: INTEGER): IntKey;
		
		VAR
			
			i: IntKey;
		
		BEGIN (*New*)
			ASSERT((size = 0) OR (size = B.BYS + B.INS), 20);
			IF size = 0 THEN
				RETURN NIL;
			END;
			NEW(i);
			RETURN i;
		END New;
	
	PROCEDURE (pub: PubKey) Read (VAR r: B.Reader);
		
		BEGIN (*Read*)
			pub.dataType := r.InByte(); ASSERT(pub.dataType = pubKeyType, 100);
			r.InChars(pub.ref);
		END Read;
	
	PROCEDURE (pub: PubKey) Write (VAR w: B.Writer);
		
		BEGIN (*Write*)
			pub.dataType := pubKeyType; w.OutByte(pub.dataType);
			w.OutChars(pub.ref);
		END Write;
	
	PROCEDURE (if: PubKeyFac) New (size: INTEGER): PubKey;
		
		VAR
			
			pub: PubKey;
		
		BEGIN (*New*)
			NEW(pub);
			IF size = 0 THEN
				pub.ref := "";
			END;
			RETURN pub;
		END New;
	
	(* Key managers procedures *)
	
	PROCEDURE (im: IntKeyMan) CompP (i1, i2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			IF i1 = NIL THEN
				IF i2 = NIL THEN
					RETURN B.eq;
				END;
				RETURN B.lt;
			END;
			IF i2 = NIL THEN
				RETURN B.gt;
			END;
			WITH i1: IntKey DO
				WITH i2: IntKey DO
					IF i1.ref < i2.ref THEN
						RETURN B.lt;
					END;
					IF i1.ref > i2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END CompP;
	
	PROCEDURE PKMCompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*PKMCompP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					IF p1.ref < p2.ref THEN
						RETURN B.lt;
					END;
					IF p1.ref > p2.ref THEN
						RETURN B.gt;
					END;
					RETURN B.eq;
				END;
			END;
		END PKMCompP;
	
	PROCEDURE (pm: PubKeyMan) CompP (p1, p2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			RETURN PKMCompP(p1, p2);
		END CompP;
	
	PROCEDURE (pm: PubKeyMan) PrefP (p1: B.Data; VAR p2: B.Data);
		
		VAR
			
			l, l2: INTEGER;
			p: PubKey;
		
		BEGIN (*PrefP*)
			ASSERT((p1 # NIL) & (p2 # NIL), 20);
			ASSERT(PKMCompP(p1, p2) = B.lt, 21);
			WITH p1: PubKey DO
				WITH p2: PubKey DO
					l2 := LEN(p2.ref$);
					NEW(p);
					l := 0;
					p.ref[l] := 0X;
					WHILE (l <= l2) & ~((PKMCompP(p1, p) = B.lt) & (PKMCompP(p, p2) <= B.eq)) DO
						p.ref[l] := p2.ref[l];
						INC(l);
						p.ref[l] := 0X;
					END;
				END;
			END;
			p2 := p;
		END PrefP;
	
	(* Comparison method of two Strings. Use the lexical order. *)
	PROCEDURE (um: UidKeyManager) CompP (key1, key2: B.Data): BYTE;
		
		BEGIN (*CompP*)
			ASSERT((key1 # NIL) & (key2 # NIL), 20);
			WITH key1: B.String DO
				WITH key2: B.String DO
					IF key1.c = NIL THEN
						IF key2.c = NIL THEN
							RETURN B.eq;
						END;
						RETURN B.lt;
					END;
					IF key2.c = NIL THEN
						RETURN B.gt;
					END;
					RETURN BA.CompP(key1.c, key2.c);
				END;
			END;
		END CompP;
	
	(* Comparison of Certification(s) by expiration dates *)
	PROCEDURE (im: CertKTimeMan) CompP (i1, i2: B.Data): BYTE;
		
		VAR
			
			c1, c2: Certification;
		
		BEGIN (*CompP*)
			WITH i1: IntKey DO
				c1 := certMan.ReadData(i1.ref)(Certification);
			END;
			WITH i2: IntKey DO
				c2 := certMan.ReadData(i2.ref)(Certification);
			END;
			IF c1.expires_on < c2.expires_on THEN
				RETURN B.gt; (* Inverse order, for the use of B.Index.Search to get all the expired certifications *)
			END;
			IF c1.expires_on > c2.expires_on THEN
				RETURN B.lt;
			END;
			IF c1.from$ < c2.from$ THEN
				RETURN B.lt;
			END;
			IF c1.from$ > c2.from$ THEN
				RETURN B.gt;
			END;
			IF c1.to$ < c2.to$ THEN
				RETURN B.lt;
			END;
			IF c1.to$ > c2.to$ THEN
				RETURN B.gt;
			END;
			RETURN B.eq;
		END CompP;
	
	(* SentriesE comparison procedure *)
	PROCEDURE (s1: SentriesE) Compare (s2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH s2: SentriesE DO
				IF s1.pubkey$ < s2.pubkey$ THEN
					RETURN A.lt;
				END;
				IF s1.pubkey$ > s2.pubkey$ THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	(* Last read & updated block *)
	PROCEDURE LastBlock* (): INTEGER;
		
		BEGIN (*LastBlock*)
			RETURN lastBlock;
		END LastBlock;
	
	(* medianTime *)
	PROCEDURE Now* (): LONGINT;
		
		BEGIN (*Now*)
			RETURN now;
		END Now;
	
	(* time *)
	PROCEDURE RealNow* (): LONGINT;
		
		BEGIN (*RealNow*)
			RETURN rNow;
		END RealNow;
	
	(* Open the WotWizard database *)
	PROCEDURE OpenB;
		
		VAR
			
			b: BOOLEAN;
		
		BEGIN (*OpenB*)
			IF database = NIL THEN
				B.fac.CloseBase(dBase);
				database := B.fac.OpenBase(dBase, pageNb);
				IF database = NIL THEN
					b := B.fac.CreateBase(dBase, placeNb); ASSERT(b, 100);
					database := B.fac.OpenBase(dBase, pageNb); ASSERT(database # NIL, 101);
					database.WritePlace(timePlace, database.CreateIndex(B.INS));
					database.WritePlace(joinAndLeavePlace, database.CreateIndex(0));
					database.WritePlace(idPubPlace, database.CreateIndex(0));
					database.WritePlace(idUidPlace, database.CreateIndex(0));
					database.WritePlace(certFromPlace, database.CreateIndex(0));
					database.WritePlace(certToPlace, database.CreateIndex(0));
					database.WritePlace(certTimePlace, database.CreateIndex(B.INS));
					database.WritePlace(listPlace, B.bNil);
					database.WritePlace(lastNPlace, 0);
				END;
				timeMan := database.CreateDataMan(timeFac);
				joinAndLeaveLMan := database.CreateDataMan(joinAndLeaveLFac);
				joinAndLeaveMan := database.CreateDataMan(joinAndLeaveFac);
				idMan := database.CreateDataMan(identityFac);
				certMan := database.CreateDataMan(certificationFac);
				listMan := database.CreateDataMan(listFac);
				timeT := database.OpenIndex(database.ReadPlace(timePlace), intKeyMan, intKeyFac);
				joinAndLeaveT := database.OpenIndex(database.ReadPlace(joinAndLeavePlace), pubKeyMan, pubKeyFac);
				idPubT := database.OpenIndex(database.ReadPlace(idPubPlace), pubKeyMan, pubKeyFac);
				idUidT := database.OpenIndex(database.ReadPlace(idUidPlace), uidKeyMan, uidKeyFac);
				certFromT := database.OpenIndex(database.ReadPlace(certFromPlace), pubKeyMan, pubKeyFac);
				certToT := database.OpenIndex(database.ReadPlace(certToPlace), pubKeyMan, pubKeyFac);
				certTimeT := database.OpenIndex(database.ReadPlace(certTimePlace), certKTimeMan, intKeyFac);
			END;
		END OpenB;
	
	(* Close the WotWizard database *)
	PROCEDURE CloseB;
		
		BEGIN (*CloseB*)
			IF database # NIL THEN
				database.CloseBase;
				database := NIL;
			END;
		END CloseB;
	
	(* Block number -> times *)
	PROCEDURE TimeOf* (bnb: INTEGER; OUT mTime, time: LONGINT): BOOLEAN;
		
		VAR
			
			t: Time;
			tP: IntKey;
		
		BEGIN (*TimeOf*)
			NEW(tP); tP.ref := bnb;
			IF timeT.Search(tP) THEN
				t := timeMan.ReadData(timeT.ReadValue())(Time);
				mTime := t.mTime;
				time := t.time;
				RETURN TRUE
			END;
			RETURN FALSE;
		END TimeOf;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPub* (IN pubkey: Pubkey; OUT list: INTEGER): BOOLEAN;
		
		VAR
			
			jl: JoinAndLeave;
			jlP: PubKey;
		
		BEGIN (*JLPub*)
			NEW(jlP);
			jlP.ref := pubkey;
			IF joinAndLeaveT.Search(jlP) THEN
				jl := joinAndLeaveMan.ReadData(joinAndLeaveT.ReadValue())(JoinAndLeave);
				list := jl.list;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END JLPub;
	
	(* Pubkey -> joining and leaving blocks (leavingBlock = hasNotLeaved if no leaving block) *)
	PROCEDURE JLPubLNext* (VAR list: INTEGER; OUT joiningBlock, leavingBlock: INTEGER): BOOLEAN;
		
		VAR
			
			jlL: JoinAndLeaveL;
		
		BEGIN (*JLPubLNext*)
			IF list = B.bNil THEN
				RETURN FALSE;
			END;
			jlL := joinAndLeaveLMan.ReadData(list)(JoinAndLeaveL);
			list := jlL.next;
			joiningBlock := jlL.joiningBlock;
			leavingBlock := jlL.leavingBlock;
			RETURN TRUE;
		END JLPubLNext;
	
	(*Number of JoinAndLeave *)
	PROCEDURE JLLen* (): INTEGER;
		
		BEGIN (*JLLen*)
			RETURN joinAndLeaveT.NumberOfKeys();
		END JLLen;
	
	(* Browse all JoinAndLeave's pubkeys step by step *)
	PROCEDURE JLNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*JLNextPubkey*)
			IF first THEN
				joinAndLeaveT.ResetPos;
			ELSE
				joinAndLeaveT.SetCurrPos(jlPubkeyCur);
			END;
			joinAndLeaveT.Next;
			jlPubkeyCur := joinAndLeaveT.GetCurrPos();
			IF ~joinAndLeaveT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := joinAndLeaveT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END JLNextPubkey;
	
	(* Pubkey -> Identity *)
	PROCEDURE IdPub* (IN pubkey: Pubkey; OUT uid: String; OUT hash: Hash; OUT block_number: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idP: PubKey;
		
		BEGIN (*IdPub*)
			NEW(idP);
			idP.ref := pubkey;
			IF idPubT.Search(idP) THEN
				id := idMan.ReadData(idPubT.ReadValue())(Identity);
				uid := id.uid;
				hash := id.hash;
				block_number := id.block_number;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdPub;
	
	(* uid -> Identity *)
	PROCEDURE IdUid* (IN uid: ARRAY OF CHAR; OUT pubkey: Pubkey; OUT hash: Hash; OUT block_number: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			idU: B.String;
		
		BEGIN (*IdUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			IF idUidT.Search(idU) THEN
				id := idMan.ReadData(idUidT.ReadValue())(Identity);
				pubkey := id.pubkey;
				hash := id.hash;
				block_number := id.block_number;
				expires_on := id.expires_on;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdUid;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idUidT.NumberOfKeys();
		END IdLen;
	
	(* Position next Identity's pubkey for IdNextPubkey *)
	PROCEDURE IdPosPubkey* (IN pubkey: Pubkey);
		
		VAR
			
			idP: PubKey;
			b: BOOLEAN;
		
		BEGIN (*IdPosPubkey*)
			NEW(idP);
			idP.ref := pubkey;
			b := idPubT.Search(idP);
			idPubT.Previous;
			idPubkeyCur := idPubT.GetCurrPos();
		END IdPosPubkey;
	
	(* Browse all Identity's pubkeys step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubT.ResetPos;
			ELSE
				idPubT.SetCurrPos(idPubkeyCur);
			END;
			idPubT.Next;
			idPubkeyCur := idPubT.GetCurrPos();
			IF ~idPubT.PosSet() THEN
				RETURN FALSE;
			END;
			pubkey := idPubT.CurrentKey()(PubKey).ref;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Position next Identity's uid for IdNextUid *)
	PROCEDURE IdPosUid* (IN uid: ARRAY OF CHAR);
		
		VAR
			
			idU: B.String;
			b: BOOLEAN;
		
		BEGIN (*IdPosUid*)
			NEW(idU);
			NEW(idU.c, LEN(uid$) + 1); idU.c^ := uid$;
			b := idUidT.Search(idU);
			idUidT.Previous;
			idUidCur := idUidT.GetCurrPos();
		END IdPosUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidT.ResetPos;
			ELSE
				idUidT.SetCurrPos(idUidCur);
			END;
			idUidT.Next;
			idUidCur := idUidT.GetCurrPos();
			IF ~idUidT.PosSet() THEN
				RETURN FALSE;
			END;
			uid := idUidT.CurrentKey()(B.String).c;
			RETURN TRUE;
		END IdNextUid;
	
	(* (Pubkey, Pubkey) -> Certification *)
	PROCEDURE Cert* (IN from, to: Pubkey; OUT bnb: INTEGER; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			p: PubKey;
			ind: B.Index;
			ok: BOOLEAN;
		
		BEGIN (*Cert*)
			ok := FALSE;
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				ind := database.OpenIndex(certFromT.ReadValue(), pubKeyMan, pubKeyFac);
				p.ref := to;
				IF ind.Search(p) THEN
					c := certMan.ReadData(ind.ReadValue())(Certification);
					bnb := c.block_number;
					expires_on := c.expires_on;
					ok := TRUE;
				END;
				ind.Close;
			END;
			RETURN ok;
		END Cert;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertFrom*)
			NEW(p);
			p.ref := from;
			IF certFromT.Search(p) THEN
				pos.posRef := certFromT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertFrom;
	
	(* Pubkey -> head of sub-index *)
	PROCEDURE CertTo* (IN to: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			p: PubKey;
			ind: B.Index;
		
		BEGIN (*CertTo*)
			NEW(p);
			p.ref := to;
			IF certToT.Search(p) THEN
				pos.posRef := certToT.ReadValue();
				ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
				ind.ResetPos;
				pos.posCur := ind.GetCurrPos();
				ind.Close;
				RETURN TRUE;
			END;
			pos.posRef := - 1;
			RETURN FALSE;
		END CertTo;
	
	(* Number of keys in sub-index *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		VAR
			
			ind: B.Index;
			n: INTEGER;
		
		BEGIN (*CertPosLen*)
			IF pos.posRef < 0 THEN
				RETURN 0;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			n := ind.NumberOfKeys();
			ind.Close;
			RETURN n;
		END CertPosLen;
	
	(* Browse all Certification's pairs of Pubkey in a sub-index step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from, to: Pubkey): BOOLEAN, NEW;
		
		VAR
			
			ind: B.Index;
			ok: BOOLEAN;
			c: Certification;
		
		BEGIN (*CertNextPos*)
			IF pos.posRef < 0 THEN
				RETURN FALSE;
			END;
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.SetCurrPos(pos.posCur);
			ind.Next;
			pos.posCur := ind.GetCurrPos();
			ok := ind.PosSet();
			IF ok THEN
				c := certMan.ReadData(ind.ReadValue())(Certification);
				from := c.from;
				to := c.to;
			END;
			ind.Close;
			RETURN ok;
		END CertNextPos;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the from Pubkey *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromT.ResetPos;
			ELSE
				certFromT.SetCurrPos(certFromCur);
			END;
			certFromT.Next;
			certFromCur := certFromT.GetCurrPos();
			IF ~certFromT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certFromT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Browse all sub-indexes step by step in the lexicographic order of the to Pubkey *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			ind: B.Index;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certToT.ResetPos;
			ELSE
				certToT.SetCurrPos(certToCur);
			END;
			certToT.Next;
			certToCur := certToT.GetCurrPos();
			IF ~certToT.PosSet() THEN
				RETURN FALSE;
			END;
			pos.posRef := certToT.ReadValue();
			ind := database.OpenIndex(pos.posRef, pubKeyMan, pubKeyFac);
			ind.ResetPos;
			pos.posCur := ind.GetCurrPos();
			ind.Close;
			RETURN TRUE;
		END CertNextTo;
	
	PROCEDURE IsSentry* (IN pubkey: Pubkey): BOOLEAN;
		
		VAR
			
			sE: SentriesE;
			e: A.Elem;
			m: INTEGER;
		
		BEGIN (*IsSentry*)
			NEW(sE);
			sE.pubkey := pubkey;
			e := sE;
			RETURN sentriesT.Search(e, m);
		END IsSentry;
	
	(* Return in pubkey the next sentry's pubkey if ~first or the first one if first; return FALSE if there is no more sentry *)
	PROCEDURE NextSentry* (first: BOOLEAN; OUT pubkey: Pubkey): BOOLEAN;
		
		BEGIN (*NextSentry*)
			IF first THEN
				sentryCur := NIL;
			END;
			sentryCur := sentriesT.Next(sentryCur);
			IF sentryCur = NIL THEN
				RETURN FALSE;
			END;
			WITH sentryCur: SentriesE DO
				pubkey := sentryCur.pubkey$;
			END;
			RETURN TRUE;
		END NextSentry;
	
	(* Return the number of sentries *)
	PROCEDURE SentriesLen* (): INTEGER;
		
		BEGIN (*SentriesLen*)
			RETURN sentriesT.NumberOfElems();
		END SentriesLen;
	
	(* Array of certifiers' pubkeys -> % of sentries reached in pars.stepMax - 1 steps *)
	PROCEDURE PercentOfSentries* (IN pubkeys: ARRAY OF Pubkey): REAL;
		
		VAR
			
			set, newSet: A.Tree;
			sE: SentriesE;
			e, ee, eee: A.Elem;
			i, n: INTEGER;
			b: BOOLEAN;
			pos: CertPos;
			from, to: Pubkey;
		
		BEGIN (*PercentOfSentries*)
			A.New(set);
			FOR i := 0 TO LEN(pubkeys) - 1 DO
				NEW(sE);
				sE.pubkey := pubkeys[i];
				e := sE;
				b := set.SearchIns(e, n); ASSERT(~b, 100);
			END;
			FOR i := 1 TO pars.stepMax - 1 DO
				A.New(newSet);
				e := set.Next(NIL);
				WHILE e # NIL DO
					eee := set.Next(e);
					b := newSet.SearchIns(e, n);
					WITH e: SentriesE DO
						b := CertTo(e.pubkey, pos); ASSERT(b, 101);
						WHILE pos.CertNextPos(from, to) DO
							NEW(sE);
							sE.pubkey := from;
							ee := sE;
							b := newSet.SearchIns(ee, n);
						END;
					END;
					e := eee;
				END;
				set := newSet;
			END;
			n := 0;
			e := set.Next(NIL);
			WHILE e # NIL DO
				WITH e: SentriesE DO
					IF IsSentry(e.pubkey) THEN
						INC(n);
					END;
				END;
				e := set.Next(e);
			END;
			RETURN n / SentriesLen();
		END PercentOfSentries;
	
	(* Verify the distance rule for a set of certifiers' pubkeys *)
	PROCEDURE DistanceRuleOk* (IN pubkeys: ARRAY OF Pubkey): BOOLEAN;
		
		BEGIN (*DistanceRuleOk*)
			RETURN PercentOfSentries(pubkeys) >= pars.xpercent;
		END DistanceRuleOk;
	
	(* Scan the string s from position i to the position of stop excluded; update i and return the scanned string in sub *)
	PROCEDURE ScanS (IN s: ARRAY OF CHAR; stop: CHAR; OUT sub: ARRAY OF CHAR; VAR i: INTEGER);
		
		VAR
			
			j: INTEGER;
		
		BEGIN (*ScanS*)
			j := 0;
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				sub[j] := s[i];
				INC(i); INC(j);
			END;
			sub[j] := 0X;
			INC(i);
		END ScanS;
	
	(* Skip the string s from position i to the position of stop excluded; update i *)
	PROCEDURE SkipS (IN s: ARRAY OF CHAR; stop: CHAR; VAR i: INTEGER);
		
		BEGIN (*SkipS*)
			WHILE (s[i] # stop) & (s[i] # 0X) DO
				INC(i);
			END;
			INC(i);
		END SkipS;
	
	(* Extract Duniter parameters from block 0 *)
	PROCEDURE Params (d: S.Database);
		
		CONST
			
			txWindow = 60 * 60 * 24 * 7;
		
		VAR
			
			res: INTEGER;
			cur: S.Row;
			ss: POINTER TO ARRAY OF CHAR;
			s: ARRAY 20 OF CHAR;
			t: S.Table;
			i: INTEGER;
		
		BEGIN (*Params*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT parameters FROM block WHERE number = 0 AND NOT fork");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT(t.columns = 1, 102); ASSERT(t.rows = 1, 103);
			 t.Read(0, cur);
			ss := cur.fields[0];
			ss[LEN(ss$)] := ':';
			i := 0;
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.c, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dt, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.ud0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigPeriod, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigStock, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.sigQty, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.idtyWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msWindow, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.xpercent, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.msValidity, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.stepMax, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.medianTimeBlocks, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.avgGenTime, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtDiffEval, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToReal(s, pars.percentRot, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.udTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.udReevalTime0, res); ASSERT(res = 0, 104);
			ScanS(ss, ':', s, i); Strings.StringToInt(s, pars.dtReeval, res); ASSERT(res = 0, 104);
			pars.txWindow := txWindow;
			pars.msPeriod := pars.msWindow;
		END Params;
	
	(* Add a block in timeT *)
	PROCEDURE Times (withList: BOOLEAN; IN s1, s2, s3: ARRAY OF CHAR);
		
		VAR
			
			t: Time;
			i: IntKey;
			res, tRef: INTEGER;
			b: BOOLEAN;
			tL: List; (* timeList *)
		
		BEGIN (*Times*)
			NEW(t);
			Strings.StringToInt(s1, t.bnb, res); ASSERT(res = 0, 100);
			Strings.StringToLInt(s2, t.mTime, res); ASSERT(res = 0, 101);
			Strings.StringToLInt(s3, t.time, res); ASSERT(res = 0, 102);
			lastBlock := t.bnb;
			tRef := timeMan.WriteAllocateData(t);
			NEW(i); i.ref := t.bnb;
			b := timeT.SearchIns(i); ASSERT(~b, 103);
			timeT.WriteValue(tRef);
			IF withList THEN
				NEW(tL); tL.next := list; tL.type := timeList; tL.ref := tRef; tL.aux := 0;
				list := listMan.WriteAllocateData(tL);
			END;
			now := MAX(now, t.mTime);
			rNow := MAX(rNow, t.time);
		END Times;
	
	(* For one block, add joining & leaving identities in joinAndLeaveT and updade identities in idPubT and idUidT; update certFromT & certToT too *)
	PROCEDURE Identities (withList: BOOLEAN; IN ssJ, ssA, ssE, nb: ARRAY OF CHAR; t: S.Table);
		
		VAR
			
			i, idRef, jlRef, n, res: INTEGER;
			tt: LONGINT;
			s: ARRAY 101 OF CHAR;
			b: BOOLEAN;
			id: Identity;
			idP: PubKey;
			idU: B.String;
			idL: List; (* joinList, activeList, leaveList *)
			jl: JoinAndLeave;
			jlL: JoinAndLeaveL;
			cur: S.Row;
		
		BEGIN (*Identities*)
			i := 1;
			WHILE ssJ[i] # ']' DO (* joiners : Insert id *)
				INC(i);
				NEW(id);
				ScanS(ssJ, ':', id.pubkey, i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 100);
				b := TimeOf(n, id.expires_on, tt); ASSERT(b, 101);
				INC(id.expires_on, pars.msValidity);
				SkipS(ssJ, ':', i);
				SkipS(ssJ, ':', i);
				ScanS(ssJ, '"', s, i); NEW(id.uid, LEN(s$) + 1); id.uid^ := s$;
				IF ssJ[i] # ']' THEN
					INC(i);
				END;
				REPEAT
					t.Exec("SELECT hash FROM i_index WHERE pub = '" + id.pubkey + "' ORDER BY writtenOn ASC");
					ASSERT(t.res IN {0, 6}, 102);
				UNTIL t.res = 0;
				ASSERT((t.rows = 0) OR (t.columns = 1), 103);
				id.hash := "";
				FOR n := 0 TO t.rows - 1 DO
					t.Read(n, cur);
					IF (cur.fields[0] # NIL) & (cur.fields[0]$ # "") THEN
						id.hash := cur.fields[0]$;
					END;
				END;
				ASSERT(id.hash # "", 104);
				Strings.StringToInt(nb, id.block_number, res); ASSERT(res = 0, 105);
				idRef := idMan.WriteAllocateData(id);
				NEW(idP); idP.ref := id.pubkey;
				b := idPubT.SearchIns(idP); ASSERT(~b, 106);
				idPubT.WriteValue(idRef);
				NEW(idU); NEW(idU.c, LEN(id.uid$) + 1); idU.c^ := id.uid$;
				b := idUidT.SearchIns(idU); ASSERT(~b, 107);
				idUidT.WriteValue(idRef);
				IF joinAndLeaveT.SearchIns(idP) THEN
					jlRef := joinAndLeaveT.ReadValue();
					jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				ELSE
					NEW(jl);
					jl.pubkey := id.pubkey;
					jl.list := B.bNil;
					jlRef := joinAndLeaveMan.AllocateData(jl);
					joinAndLeaveT.WriteValue(jlRef);
				END;
				NEW(jlL);
				jlL.next := jl .list;
				jlL.joiningBlock := id.block_number;
				jlL.leavingBlock := hasNotLeaved;
				jl.list := joinAndLeaveLMan.WriteAllocateData(jlL);
				joinAndLeaveMan.WriteData(jlRef, jl);
				IF withList THEN
					NEW(idL); idL.next := list; idL.type := joinList; idL.ref := idRef; idL.aux := 0;
					list := listMan.WriteAllocateData(idL);
				END;
			END;
			i := 1;
			WHILE ssA[i] # ']' DO (* actives : Update *)
				INC(i);
				NEW(idP);
				ScanS(ssA, ':', idP.ref, i);
				SkipS(ssA, ':', i);
				ScanS(ssA, '-', s, i); Strings.StringToInt(s, n, res); ASSERT(res = 0, 109);
				SkipS(ssA, '"', i);
				IF ssA[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 110);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := list; idL.type := activeList; idL.ref := idRef; idL.aux := id.expires_on;
					list := listMan.WriteAllocateData(idL);
				END;
				b := TimeOf(n, id.expires_on, tt); ASSERT(b, 112);
				INC(id.expires_on, pars.msValidity);
				idMan.WriteData(idRef, id);
			END;
			i := 1;
			WHILE ssE[i] # ']' DO (* excluded : Remove id *)
				INC(i);
				NEW(idP);
				ScanS(ssE, '"', idP.ref, i);
				IF ssE[i] # ']' THEN
					INC(i);
				END;
				b := idPubT.Search(idP); ASSERT(b, 113);
				idRef := idPubT.ReadValue();
				id := idMan.ReadData(idRef)(Identity);
				IF withList THEN
					NEW(idL); idL.next := list; idL.type := leaveList; idL.ref := idRef; idL.aux := 0;
					list := listMan.WriteAllocateData(idL);
				ELSE
					idMan.EraseData(idRef);
				END;
				b := idPubT.Erase(idP); ASSERT(b, 114);
				NEW(idU); idU.c := id.uid;
				b := idUidT.Erase(idU); ASSERT(b, 115);
				b := joinAndLeaveT.Search(idP); ASSERT(b, 116);
				jlRef := joinAndLeaveT.ReadValue();
				jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
				jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
				ASSERT(jlL.leavingBlock = hasNotLeaved);
				Strings.StringToInt(nb, jlL.leavingBlock, res); ASSERT(res = 0, 117);
				joinAndLeaveMan.WriteData(jl.list, jlL);
			END;
		END Identities;
	
	(* Add certificatoins of one block in certFromT, certToT and certTimeT *)
	PROCEDURE Certifications (withList: BOOLEAN; IN ss, nb: ARRAY OF CHAR);
		
		VAR
			
			i, n, res, pC: INTEGER;
			exp: LONGINT;
			b: BOOLEAN;
			c: Certification;
			idP: PubKey;
			cL: List; (*certAddList *)
			ind: B.Index;
			iK: IntKey;
			s: ARRAY 11 OF CHAR;
		
		BEGIN (*Certifications*)
			i := 1;
			WHILE ss[i] # ']' DO
				INC(i);
				NEW(c);
				ScanS(ss, ':', c.from, i);
				ScanS(ss, ':', c.to, i);
				ScanS(ss, ':', s, i);
				SkipS(ss, '"', i);
				IF ss[i] # ']' THEN
					INC(i);
				END;
				Strings.StringToInt(nb, c.block_number, res); ASSERT(res = 0, 100);
				Strings.StringToInt(s, n, res); ASSERT(res = 0, 101);
				b := TimeOf(n, c.expires_on, exp); ASSERT(b, 102);
				INC(c.expires_on, pars.sigValidity);
				pC := certMan.WriteAllocateData(c);
				NEW(idP);
				idP.ref := c.from;
				IF certFromT.SearchIns(idP) THEN
					n := certFromT.ReadValue();
				ELSE
					n := database.CreateIndex(pubKeyS);
					certFromT.WriteValue(n);
				END;
				idP.ref := c.to;
				ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP); ASSERT(~b, 103);
				ind.WriteValue(pC);
				ind.Close;
				IF certToT.SearchIns(idP) THEN
					n := certToT.ReadValue();
				ELSE
					n := database.CreateIndex(pubKeyS);
					certToT.WriteValue(n);
				END;
				idP.ref := c.from;
				ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
				b := ind.SearchIns(idP); ASSERT(~b, 104);
				ind.WriteValue(pC);
				ind.Close;
				NEW(iK); iK.ref := pC;
				b := certTimeT.SearchIns(iK); ASSERT(~b, 105);
				IF withList THEN
					NEW(cL); cL.next := list; cL.type := certAddList; cL.ref := pC; cL.aux := 0;
					list := listMan.WriteAllocateData(cL);
				END;
			END;
		END Certifications;
	
	(* Remove a certification from certFromT and certToT *)
	PROCEDURE RemoveCert (c: Certification);
		
		VAR
			
			pKFrom, pKTo: PubKey;
			b, empty: BOOLEAN;
			n: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveCert*)
			NEW(pKFrom); NEW(pKTo);
			pKFrom.ref := c.from; pKTo.ref := c.to;
			
			b := certFromT.Search(pKFrom); ASSERT(b, 100);
			n := certFromT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKTo); ASSERT(b, 101);
			empty := ind.NumberOfKeys() = 0;
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certFromT.Erase(pKFrom); ASSERT(b, 102);
			END;
			
			b := certToT.Search(pKTo); ASSERT(b, 103);
			n := certToT.ReadValue();
			ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
			b := ind.Erase(pKFrom); ASSERT(b, 104);
			empty := ind.NumberOfKeys() = 0;
			ind.Close;
			IF empty THEN
				database.DeleteIndex(n);
				b := certToT.Erase(pKTo); ASSERT(b, 105);
			END;
		END RemoveCert;
	
	(* Remove expired certifications from certFromT and certToT *)
	PROCEDURE RemoveExpiredCerts (now, secureNow: LONGINT);
		
		VAR
			
			c: Certification;
			cTi: IntKey;
			b: BOOLEAN;
			pC: INTEGER;
			cL: List; (* certRemoveList *)
			iK: IntKey;
		
		BEGIN (*RemoveExpiredCerts*)
			NEW(c); c.expires_on := now; c.from := "";
			pC := certMan.WriteAllocateData(c);
			NEW(cTi); cTi.ref := pC;
			b := certTimeT.Search(cTi);
			certMan.EraseData(pC);
			WHILE certTimeT.PosSet() DO
				pC := certTimeT.CurrentKey()(IntKey).ref;
				certTimeT.Next;
				c := certMan.ReadData(pC)(Certification);
				RemoveCert(c);
				IF c.expires_on > secureNow THEN
					NEW(cL); cL.next := list; cL.type := certRemoveList; cL.ref := pC; cL.aux := 0;
					list := listMan.WriteAllocateData(cL);
				ELSE
					NEW(iK); iK.ref := pC;
					b := certTimeT.Erase(iK); ASSERT(b);
					certMan.EraseData(pC);
				END;
			END;
		END RemoveExpiredCerts;
	
	(* Undo the last operations done from the secureGap last blocks *)
	PROCEDURE RemoveSecureGap;
		
		VAR
			
			b: BOOLEAN;
			i: IntKey;
			p: PubKey;
			u: B.String;
			t: Time;
			jlL: JoinAndLeaveL;
			jl: JoinAndLeave;
			id: Identity;
			c: Certification;
			l: List;
			n, jlRef, jlLRef: INTEGER;
			ind: B.Index;
		
		BEGIN (*RemoveSecureGap*)
			WHILE list # B.bNil DO
				l := listMan.ReadData(list)(List);
				CASE l.type OF
					|timeList:
						t := timeMan.ReadData(l.ref)(Time);
						NEW(i); i.ref := t.bnb;
						b := timeT.Erase(i); ASSERT(b, 100);
						timeMan.EraseData(l.ref);
					|joinList:
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.Erase(p); ASSERT(b, 101);
						NEW(u); u.c := id.uid;
						b := idUidT.Erase(u); ASSERT(b, 102);
						idMan.EraseData(l.ref);
						b := joinAndLeaveT.Search(p); ASSERT(b, 103);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlLRef := jl.list;
						jlL := joinAndLeaveLMan.ReadData(jlLRef)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock = hasNotLeaved);
						IF jlL.next = B.bNil THEN
							joinAndLeaveMan.EraseData(jlRef);
							b := joinAndLeaveT.Erase(p); ASSERT(b, 104);
						ELSE
							jl.list := jlL.next;
							joinAndLeaveMan.WriteData(jlRef, jl);
						END;
						joinAndLeaveLMan.EraseData(jlLRef);
					|activeList:
						id := idMan.ReadData(l.ref)(Identity);
						id.expires_on := l.aux;
						idMan.WriteData(l.ref, id);
					|leaveList:
						id := idMan.ReadData(l.ref)(Identity);
						NEW(p); p.ref := id.pubkey;
						b := idPubT.SearchIns(p); ASSERT(~b, 105);
						idPubT.WriteValue(l.ref);
						NEW(u); u.c := id.uid;
						b := idUidT.SearchIns(u); ASSERT(~b, 106);
						idUidT.WriteValue(l.ref);
						b := joinAndLeaveT.Search(p); ASSERT(b, 107);
						jlRef := joinAndLeaveT.ReadValue();
						jl := joinAndLeaveMan.ReadData(jlRef)(JoinAndLeave);
						jlL := joinAndLeaveLMan.ReadData(jl.list)(JoinAndLeaveL);
						ASSERT(jlL.leavingBlock # hasNotLeaved);
						jlL.leavingBlock := hasNotLeaved;
						joinAndLeaveLMan.WriteData(jl.list, jlL);
					|certAddList:
						c := certMan.ReadData(l.ref)(Certification);
						RemoveCert(c);
						NEW(i); i.ref := l.ref;
						b := certTimeT.Erase(i); ASSERT(b, 108);
						certMan.EraseData(l.ref);
					|certRemoveList:
						c := certMan.ReadData(l.ref)(Certification);
						NEW(p);
						p.ref := c.from;
						IF certFromT.SearchIns(p) THEN
							n := certFromT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certFromT.WriteValue(n);
						END;
						p.ref := c.to;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 109);
						ind.WriteValue(l.ref);
						ind.Close;
						IF certToT.SearchIns(p) THEN
							n := certToT.ReadValue();
						ELSE
							n := database.CreateIndex(pubKeyS);
							certToT.WriteValue(n);
						END;
						p.ref := c.from;
						ind := database.OpenIndex(n, pubKeyMan, pubKeyFac);
						b := ind.SearchIns(p); ASSERT(~b, 110);
						ind.WriteValue(l.ref);
						ind.Close;
				END;
				listMan.EraseData(list);
				list := l.next;
			END;
		END RemoveSecureGap;
	
	(* Insert datas from all the blocks from the secureGapth block before the last read *)
	PROCEDURE ScanBlocks (d: S.Database);
		
		VAR
			
			cur: S.Row;
			t, tt: S.Table;
			i, res, lastN: INTEGER;
			s: ARRAY 13 OF CHAR;
			withList: BOOLEAN;
			now, secureNow: LONGINT;
		
		BEGIN (*ScanBlocks*)
			list := database.ReadPlace(listPlace);
			RemoveSecureGap;
			lastN := database.ReadPlace(lastNPlace);
			Strings.IntToString(lastN - secureGap, s);
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT number, medianTime, time, joiners, actives, excluded, certifications FROM block WHERE NOT fork AND number >= " + s + " ORDER BY number ASC");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 7), 102);
			tt := d.NewTable(); ASSERT(tt # NIL, 103);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, cur);
				withList := i >= t.rows - secureGap;
				Times(withList , cur.fields[0], cur.fields[1], cur.fields[2]);
				Identities(withList, cur.fields[3], cur.fields[4], cur.fields[5], cur.fields[0], tt);
				Certifications(withList, cur.fields[6], cur.fields[0]);
			END;
			IF t.rows > 0 THEN
				t.Read(t.rows - 1, cur);
				Strings.StringToLInt(cur.fields[1], now, res); ASSERT(res = 0, 104);
				IF t.rows >= secureGap THEN
					t.Read(t.rows - secureGap, cur);
				ELSE
					t.Read(0, cur);
				END;
				Strings.StringToLInt(cur.fields[1], secureNow, res); ASSERT(res = 0, 105);
			END;
			RemoveExpiredCerts(now, secureNow); (* Élimine toutes les certifications expirées avec réversibilité dans secureGap *)
			database.WritePlace(listPlace, list);
			IF lastN <= secureGap THEN
				lastN := t.rows;
			ELSE
				INC(lastN, t.rows - secureGap);
			END;
			database.WritePlace(lastNPlace, lastN);
			database.UpdateBase;
		END ScanBlocks;
	
	(* Initialize sentriesT *)
	PROCEDURE CalculateSentries;
		
		VAR
			
			ok, b: BOOLEAN;
			pos: CertPos;
			n, m: INTEGER;
			pubkey: Pubkey;
			sE: SentriesE;
			e: A.Elem;
		
		BEGIN (*CalculateSentries*)
			A.New(sentriesT);
			n := IdLen();
			IF n = 0 THEN RETURN END;
			n := SHORT(ENTIER(Math.Ceiling(Math.Power(n, 1 / pars.stepMax))));
			ok := IdNextPubkey(TRUE, pubkey);
			WHILE ok DO
				IF CertFrom(pubkey, pos) & (pos.CertPosLen() >= n) & CertTo(pubkey, pos) & (pos.CertPosLen() >= n) THEN
					NEW(sE);
					sE.pubkey := pubkey;
					e := sE;
					b := sentriesT.SearchIns(e, m); ASSERT(~b, 100);
				END;
				ok := IdNextPubkey(FALSE, pubkey);
			END
		END CalculateSentries;
	
	PROCEDURE AddUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*AddUpdateProc*)
			l := updateList; m := NIL;
			WHILE l # NIL DO
				m := l;
				l := l.next;
			END;
			NEW(l);
			l.next := NIL;
			l.update := updateProc;
			IF m = NIL THEN
				updateList := l;
			ELSE
				m.next := l;
			END;
		END AddUpdateProc;
	
	PROCEDURE RemoveUpdateProc* (updateProc: UpdateProc);
		
		VAR
			
			l, m: UpdateList;
		
		BEGIN (*RemoveUpdateProc*)
			l := updateList; m := NIL;
			WHILE (l # NIL) & (l.update # updateProc) DO
				m := l;
				l := l.next;
			END;
			ASSERT(l # NIL, 20);
			IF m = NIL THEN
				updateList := l.next;
			ELSE
				m.next := l.next;
			END;
		END RemoveUpdateProc;
	
	(* Scan the Duniter database *)
	PROCEDURE Scan;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
			t: LONGINT;
			s: BA.TimeString;
			dt: BA.DateTime;
			ss: ARRAY 11 OF CHAR;
		
		BEGIN (*Scan*)
			L.log.Msg("Updating blockchain in DBase.data");
			t := Services.Ticks();
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res);
			IF res # 0 THEN L.log.Err(100 + res, duniBase); END;
			ScanBlocks(d);
			BA.TimeToString(Services.Ticks() - t, s);
			L.log.Msg("End updating blockchain in DBase.data. Time spent: " + s);
			BA.TimestampToString(now, dt);
			Strings.IntToString(LastBlock(), ss);
			L.log.Msg("It is now " + dt + " - block " + ss);
			t := Services.Ticks();
			L.log.Msg("Calculating sentries");
			CalculateSentries;
			BA.TimeToString(Services.Ticks() - t, s);
			L.log.Msg("End calculating sentries. Time spent: " + s);
		END Scan;
	
	(* Scan the Duniter parameters in block 0 *)
	PROCEDURE Scan1;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
		
		BEGIN (*Scan1*)
			S.OpenDatabase(driver, "", "", duniBase, S.sync, S.hideErrors, d, res);
			IF res # 0 THEN L.log.Err(100 + res, duniBase); END;
			Params(d);
		END Scan1;
	
	PROCEDURE UpdateAll*;
		
		VAR
			
			l: UpdateList;
		
		BEGIN (*UpdateAll*)
			l := updateList;
			WHILE l # NIL DO
				l.update;
				l := l.next;
			END;
			BA.Collect;
		END UpdateAll;
	
	PROCEDURE Init;
		
		VAR
			
			l: Files.Locator;
			v: Views.View;
			s: TextMappers.Scanner;
			t: TextModels.Model;
			f: TextMappers.Formatter;
			name: Files.Name;
			res: INTEGER;
			ti: LONGINT;
			ss: BA.TimeString;
		
		BEGIN (*Init*)
			(* Can we mix both sets of constants? *)
			ASSERT((B.lt = A.lt) & (B.eq = A.eq) & (B.gt = A.gt), 100);
			duniBase := '';
			l := Files.dir.This(initDir); L.log.Err(l.res, initDir);
			v := Views.OldView(l, initName);
			IF v = NIL THEN
				duniBase := duniBaseDef;
				t := TextModels.dir.New();
				f.ConnectTo(t);
				f.WriteString('"' + duniBase + '"');
				name := initName;
				Views.Register(TextViews.dir.New(t), Views.dontAsk, l, name, BA.utf8Conv, res);
				L.log.Err(res, name);
			ELSE
				ASSERT(v IS TextViews.View, 101);
				s.ConnectTo(v(TextViews.View).ThisModel());
				s.Scan;
				IF s.type = TextMappers.string THEN
					duniBase := s.string$;
				END;
			END;
			L.log.Msg("Duniter database: " + duniBase);
			now := 0; rNow := 0;
			L.log.Msg("Scan of block 0");
			ti := Services.Ticks();
			Scan1;
			BA.TimeToString(Services.Ticks() - ti, ss);
			L.log.Msg("End of scan of block 0. Time spent: " + ss);
			updateList := NIL;
			AddUpdateProc(Scan);
			NEW(listFac); NEW(timeFac); NEW(joinAndLeaveLFac); NEW(joinAndLeaveFac);
			NEW(identityFac); NEW(certificationFac);
			NEW(intKeyFac); NEW(uidKeyFac); NEW(pubKeyFac);
			NEW(pubKeyMan); NEW(uidKeyMan); NEW(intKeyMan); NEW(certKTimeMan);
			OpenB;
		END Init;
	
	BEGIN (*DuniterBlockchain*)
		Init;
	CLOSE
		CloseB;
	END DuniterBlockchain.
