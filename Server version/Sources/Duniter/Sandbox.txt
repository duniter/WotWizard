(* 
Duniter: WotWizard.

Copyright (C) 2017 GérardMeunier

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License  for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*)

MODULE DuniterSandbox;
	
	
	
	(* Put the Duniter sandbox in AVL trees to access quickly sandbox data *)

	IMPORT
		
		(**
		Lg := StdLog,
		**)
		
		A := UtilAvlTree, B := DuniterBlockchain, BA := DuniterBasic, L := DuniterLog, Services, S := SqlDB, Strings;
	
	CONST
		
		driver = B.driver; (* Driver SQLite *)
	
	TYPE
		
		String* = B.String;
		Pubkey* = B.Pubkey;
		Hash* = B.Hash;
		
		Identity = POINTER TO RECORD
			inBC: BOOLEAN;
			hash: Hash; (* Needed in sandbox: key of identities *)
			pubkey: Pubkey;
			uid: String;
			bid: INTEGER;
			expires_on: LONGINT;
		END;
		
		(* Elements of A.Tree for identities *)
		IdE = POINTER TO ABSTRACT RECORD (A.Elem)
			ref: Identity;
		END;
		
		IdUidE = POINTER TO RECORD (IdE) (* Sorted by uid *)
		END;
		
		IdPubE = POINTER TO RECORD (IdE) (* Sorted by pubkey *)
		END;
		
		IdHashE = POINTER TO RECORD (IdE) (* Sorted by hash *)
		END;
		
		(* SQLite record for "SELECT pubkey, uid, buid, expires_on FROM idty WHERE revocation_sig IS NULL AND hash = '<hash>'" *)
		CurId* = RECORD
			pubkey*: Pubkey;
			uid*,
			buid*: String;
			expires_on*: LONGINT;
		END;
		
		(* SQLite record for "SELECT m.idtyHash, m.membership, m.issuer, m.userid, m.expires_on FROM membership m INNER JOIN block b ON m.blockHash = b.hash WHERE NOT b.fork ORDER BY m.blockNumber ASC" *)
		CurOwn* = RECORD
			hash*: Hash;
			inOrOut*: ARRAY 4 OF CHAR;
			pubkey*: Pubkey;
			uid*: String;
			expires_on*: LONGINT;
		END;
		
		Certification = POINTER TO RECORD
			from,
			to: Pubkey;
			toHash: Hash;
			expires_on: LONGINT;
		END;
		
		(* Elements of A.Tree for certifications *)
		CertE = POINTER TO ABSTRACT RECORD (A.Elem)
			ref: Certification;
			list: A.Tree; (* Subtree, sorted otherwise *)
		END;
		
		CertFromE = POINTER TO RECORD (CertE) (* Sorted by ref.from *)
		END;
		
		CertToE = POINTER TO RECORD (CertE) (* Sorted by ref.to *)
		END;
		
		CertPos* = RECORD (* Position in a certification subtree *)
			posT: A.Tree; (* The subtree *)
			posCur: A.Elem; (* The last seen element in the subtree *)
		END;
		
		(* SQLite record for "SELECT [from], [to], target, expires_on FROM cert INNER JOIN block ON cert.block_hash = block.hash WHERE NOT block.fork" *)
		CurC * = RECORD
			from*: Pubkey;
			to*: Pubkey;
			toHash*: Hash;
			expires_on*: LONGINT;
		END;
	
	VAR
		
		(* AVL trees *)
		idUidT, (* uid -> Identity *)
		idPubT, (* pubkey -> Identity *)
		idHashT, (* hash -> Identity *)
		certFromT, (* from -> Certification *)
		certToT: A.Tree; (* toHash -> Certification *)
		
		(* Positions in AVL trees *)
		idUidCur,
		idPubkeyCur,
		idHashCur,
		certFromCur,
		certToCur: A.Elem;
	
	(* Comparison procedures for AVL trees *)
	
	PROCEDURE (i1: IdUidE) Compare (i2: A.Elem): BYTE;
		
		VAR
			
			b: BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdUidE DO
				b := BA.CompP(i1.ref.uid, i2.ref.uid);
				IF b # A.eq THEN
					RETURN b;
				END;
				IF i1.ref.hash < i2.ref.hash THEN
					RETURN A.lt;
				END;
				IF i1.ref.hash > i2.ref.hash THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE (i1: IdPubE) Compare (i2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdPubE DO
				IF i1.ref.pubkey < i2.ref.pubkey THEN
					RETURN A.lt;
				END;
				IF i1.ref.pubkey > i2.ref.pubkey THEN
					RETURN A.gt;
				END;
				IF i1.ref.hash < i2.ref.hash THEN
					RETURN A.lt;
				END;
				IF i1.ref.hash > i2.ref.hash THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE (i1: IdHashE) Compare (i2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH i2: IdHashE DO
				IF i1.ref.hash$ < i2.ref.hash$ THEN
					RETURN A.lt;
				END;
				IF i1.ref.hash$ > i2.ref.hash$ THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE (c1: CertFromE) Compare (c2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH c2: CertFromE DO
				IF c1.ref.from$ < c2.ref.from$ THEN
					RETURN A.lt;
				END;
				IF c1.ref.from$ > c2.ref.from$ THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	PROCEDURE (c1: CertToE) Compare (c2: A.Elem): BYTE;
		
		BEGIN (*Compare*)
			WITH c2: CertToE DO
				IF c1.ref.toHash$ < c2.ref.toHash$ THEN
					RETURN A.lt;
				END;
				IF c1.ref.toHash$ > c2.ref.toHash$ THEN
					RETURN A.gt;
				END;
				RETURN A.eq;
			END;
		END Compare;
	
	(* hash -> Identity *)
	PROCEDURE IdHash* (IN hash: Hash; OUT inBC: BOOLEAN; OUT pubkey: Pubkey; OUT uid: String; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			id: Identity;
			hE: IdHashE;
			e: A.Elem;
			n: INTEGER;
		
		BEGIN (*IdHash*)
			NEW(id);
			id.hash := hash$;
			NEW(hE); hE.ref := id;
			e := hE;
			IF idHashT.Search(e, n) THEN
				WITH e: IdE DO
					inBC := e.ref.inBC;
					pubkey := e.ref.pubkey;
					NEW(uid, LEN(e.ref.uid$) + 1); uid^ := e.ref.uid$;
					expires_on := e.ref.expires_on;
				END;
				RETURN TRUE;
			END;
			RETURN FALSE;
		END IdHash;
	
	(* Number of identities *)
	PROCEDURE IdLen* (): INTEGER;
		
		BEGIN (*IdLen*)
			RETURN idHashT.NumberOfElems();
		END IdLen;
	
	(* Position next Identity's uid for IdNextUid *)
	PROCEDURE IdPosUid* (IN uid: ARRAY OF CHAR);
		
		VAR
			
			id: Identity;
			uP: IdUidE;
			e: A.Elem;
			n: INTEGER;
			b: BOOLEAN;
		
		BEGIN (*IdPosUid*)
			NEW(id);
			NEW(id.uid, LEN(uid$) + 1); id.uid^ := uid$;
			id.hash := "";
			NEW(uP); uP.ref := id;
			e := uP;
			b := idUidT.SearchNext(e, n);
			idUidCur := idUidT.Previous(e);
		END IdPosUid;
	
	(* Browse all Identity's uid(s) lexicographically step by step *)
	PROCEDURE IdNextUid* (first: BOOLEAN; OUT uid: String; OUT hash: Hash): BOOLEAN;
		
		BEGIN (*IdNextUid*)
			IF first THEN
				idUidCur := NIL;
			END;
			idUidCur := idUidT.Next(idUidCur);
			IF idUidCur = NIL THEN
				RETURN FALSE;
			END;
			WITH idUidCur: IdE DO
				NEW(uid, LEN(idUidCur.ref.uid$) + 1); uid^ := idUidCur.ref.uid$;
				hash := idUidCur.ref.hash;
			END;
			RETURN TRUE;
		END IdNextUid;
	
	(* Position next Identity's pubkey for IdNextPubkey *)
	PROCEDURE IdPosPubkey* (IN pubkey: Pubkey);
		
		VAR
			
			id: Identity;
			pU: IdPubE;
			e: A.Elem;
			n: INTEGER;
			b: BOOLEAN;
		
		BEGIN (*IdPosPubkey*)
			NEW(id);
			id.pubkey := pubkey$;
			id.hash := "";
			NEW(pU); pU.ref := id;
			e := pU;
			b := idPubT.SearchNext(e, n);
			idPubkeyCur := idPubT.Previous(e);
		END IdPosPubkey;
	
	(* Browse all Identity's pubkey(s)  step by step *)
	PROCEDURE IdNextPubkey* (first: BOOLEAN; OUT pubkey: Pubkey; OUT hash: Hash): BOOLEAN;
		
		BEGIN (*IdNextPubkey*)
			IF first THEN
				idPubkeyCur := NIL;
			END;
			idPubkeyCur := idPubT.Next(idPubkeyCur);
			IF idPubkeyCur = NIL THEN
				RETURN FALSE;
			END;
			WITH idPubkeyCur: IdE DO
				pubkey := idPubkeyCur.ref.pubkey;
				hash := idPubkeyCur.ref.hash;
			END;
			RETURN TRUE;
		END IdNextPubkey;
	
	(* Position next Identity's hash for IdNextHash *)
	PROCEDURE IdPosHash* (IN hash: Hash);
		
		VAR
			
			id: Identity;
			hE: IdHashE;
			e: A.Elem;
			n: INTEGER;
			b: BOOLEAN;
		
		BEGIN (*IdPosHash*)
			NEW(id);
			id.hash := hash$;
			NEW(hE); hE.ref := id;
			e := hE;
			b := idHashT.SearchNext(e, n);
			idHashCur := idHashT.Previous(e);
		END IdPosHash;
	
	(* Browse all Identity's hash(es)  step by step *)
	PROCEDURE IdNextHash* (first: BOOLEAN; OUT hash: Hash): BOOLEAN;
		
		BEGIN (*IdNextHash*)
			IF first THEN
				idHashCur := NIL;
			END;
			idHashCur := idHashT.Next(idHashCur);
			IF idHashCur = NIL THEN
				RETURN FALSE;
			END;
			WITH idHashCur: IdE DO
				hash := idHashCur.ref.hash$;
			END;
			RETURN TRUE;
		END IdNextHash;
	
	(* (Pubkey, Hash) -> Certification *)
	PROCEDURE Cert* (IN from: Pubkey; IN toHash: Hash; OUT to: Pubkey; OUT expires_on: LONGINT): BOOLEAN;
		
		VAR
			
			c: Certification;
			cf: CertFromE;
			ct: CertToE;
			e, ee: A.Elem;
			n: INTEGER;
		
		BEGIN (*Cert*)
			NEW(c);
			c.from := from;
			c.toHash := toHash;
			NEW(cf); cf.ref := c;
			e := cf;
			IF certFromT.Search(e, n) THEN
				WITH e: CertE DO
					NEW(ct); ct.ref := c;
					ee := ct; 
					IF e.list.Search(ee, n) THEN
						WITH ee: CertE DO
							to := ee.ref.to;
							expires_on := ee.ref.expires_on;
						END;
						RETURN TRUE;
					END;
				END;
			END;
			RETURN FALSE;
		END Cert;
	
	(* Pubkey -> head of subtree *)
	PROCEDURE CertFrom* (IN from: Pubkey; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			c: Certification;
			cf: CertFromE;
			e: A.Elem;
			n: INTEGER;
		
		BEGIN (*CertFrom*)
			NEW(c);
			c.from := from;
			NEW(cf); cf.ref := c;
			e := cf;
			IF certFromT.Search(e, n) THEN
				WITH e: CertE DO
					pos.posT := e.list;
					pos.posCur := NIL;
				END;
				RETURN TRUE;
			END;
			pos.posT := NIL;
			RETURN FALSE;
		END CertFrom;
	
	(* Hash -> head of subtree *)
	PROCEDURE CertTo* (IN toHash: Hash; OUT pos: CertPos): BOOLEAN;
		
		VAR
			
			c: Certification;
			ct: CertToE;
			e: A.Elem;
			n: INTEGER;
		
		BEGIN (*CertTo*)
			NEW(c);
			c.toHash := toHash;
			NEW(ct); ct.ref := c;
			e := ct;
			IF certToT.Search(e, n) THEN
				WITH e: CertE DO
					pos.posT := e.list;
					pos.posCur := NIL;
				END;
				RETURN TRUE;
			END;
			pos.posT := NIL;
			RETURN FALSE;
		END CertTo;
	
	(* Number of elements in subtree *)
	PROCEDURE (IN pos: CertPos) CertPosLen* (): INTEGER, NEW;
		
		BEGIN (*CertPosLen*)
			IF pos.posT = NIL THEN
				RETURN 0;
			END;
			RETURN pos.posT.NumberOfElems();
		END CertPosLen;
	
	(* Browse all Certification(s) in a subtree step by step *)
	PROCEDURE (VAR pos: CertPos) CertNextPos* (OUT from: Pubkey; OUT toHash: Hash): BOOLEAN, NEW;
		
		VAR
			
			e: A.Elem;
		
		BEGIN (*CertNextPos*)
			IF pos.posT = NIL THEN
				RETURN FALSE;
			END;
			pos.posCur := pos.posT.Next(pos.posCur);
			e := pos.posCur;
			IF e = NIL THEN
				RETURN FALSE;
			END;
			WITH e: CertE DO
				from := e.ref.from;
				toHash := e.ref.toHash;
			END;
			RETURN TRUE;
		END CertNextPos;
	
	(* Number of certifiers who certified in sandbox *)
	PROCEDURE CertFromLen* (): INTEGER;
		
		BEGIN (*CertFromLen*)
			RETURN certFromT.NumberOfElems();
		END CertFromLen;
	
	(* Browse all subtrees for all from Pubkey step by step *)
	PROCEDURE CertNextFrom* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certFromCur := NIL;
			END;
			certFromCur := certFromT.Next(certFromCur);
			IF certFromCur = NIL THEN
				RETURN FALSE;
			END;
			WITH certFromCur: CertE DO
				pos.posT := certFromCur.list;
				pos.posCur := NIL;
			END;
			RETURN TRUE;
		END CertNextFrom;
	
	(* Number of persons certified in sandbox *)
	PROCEDURE CertToLen* (): INTEGER;
		
		BEGIN (*CertToLen*)
			RETURN certToT.NumberOfElems();
		END CertToLen;
	
	(* Browse all subtrees for all toHash Hash step by step *)
	PROCEDURE CertNextTo* (first: BOOLEAN; OUT pos: CertPos): BOOLEAN;
		
		BEGIN (*CertNextFrom*)
			IF first THEN
				certToCur := NIL;
			END;
			certToCur := certToT.Next(certToCur);
			IF certToCur = NIL THEN
				RETURN FALSE;
			END;
			WITH certToCur: CertE DO
				pos.posT := certToCur.list;
				pos.posCur := NIL;
			END;
			RETURN TRUE;
		END CertNextTo;
	
	(* Extract bid out of buid *)
	PROCEDURE ExtractBlockId (VAR buid: ARRAY OF CHAR; OUT bid: INTEGER; OUT hash: Hash): BOOLEAN;
		
		VAR
			
			i, j, res: INTEGER;
		
		BEGIN (*ExtractBlockId*)
			i := 0;
			WHILE (buid[i] # '-') & (buid[i] # 0X) DO
				INC(i);
			END;
			buid[i] := 0X;
			Strings.StringToInt(buid, bid, res);
			j := 0;
			REPEAT
				INC(i);
				hash[j] := buid[i];
				INC(j);
			UNTIL buid[i] = 0X;
			RETURN res = 0;
		END ExtractBlockId;
	
	(* Scan the membership and the idty tables in the Duniter database and build idHashT, idPubT and idUidT; remove all items which reference a forked block *)
	PROCEDURE MembershipIds (d: S.Database);
		
		VAR
			
			t: S.Table;
			i, n, bnb: INTEGER;
			tr: A.Tree;
			curOwn: CurOwn;
			curId: CurId;
			id: Identity;
			idH: IdHashE;
			idP: IdPubE;
			idU: IdUidE;
			p: Pubkey;
			e, ee: A.Elem;
			b: BOOLEAN;
			h: Hash;
			uid: String;
			r: S.Row;
			exp: LONGINT;
		
		BEGIN (*MembershipIds*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT (* Membership applications *)
				t.Exec("SELECT m.idtyHash, m.membership, m.issuer, m.userid, m.expires_on FROM membership m INNER JOIN block b ON m.blockHash = b.hash WHERE NOT b.fork ORDER BY m.blockNumber ASC");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 5), 102);
			A.New(tr);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, curOwn);
				NEW(id); id.hash := curOwn.hash; id.expires_on := 0;
				NEW(idH); idH.ref := id; e := idH;
				IF curOwn.inOrOut$ = "IN" THEN
					b := tr.SearchIns(e, n);
					WITH e: IdHashE DO
						e.ref.pubkey := curOwn.pubkey;
						e.ref.uid := curOwn.uid;
						e.ref.expires_on := MAX(e.ref.expires_on, curOwn.expires_on); (* The last one is the good one *)
					END;
				ELSE ASSERT(curOwn.inOrOut$ = "OUT", 103); (* Leaving *)
					b := tr.Delete(idH);
				END;
			END;
			A.New(idHashT);
			e := tr.Next(NIL);
			WHILE e # NIL DO (* For every membership applications *)
				WITH e: IdHashE DO
					IF B.IdHash(e.ref.hash, p) THEN (* If identity already in BC... *)
						IF B.IdPubComplete(p, uid, b, h, bnb, exp) & ~b & (exp # BA.revoked) THEN (* ... and if no more member but not revoked *)
							NEW(id);
							id.inBC := TRUE; id.hash := e.ref.hash; id.pubkey := p;
							id.uid := uid; id.bid := bnb;
							id.expires_on := MIN(ABS(exp), e.ref.expires_on);
							NEW(idH); idH.ref := id; ee := idH;
							b := idHashT.SearchIns(ee, n); ASSERT(~b, 104);
						END;
					ELSIF ~(B.IdPub(e.ref.pubkey, uid) OR B.IdUid(e.ref.uid, p)) THEN  (* Not in BC *)
						REPEAT (* New identities *)
							t.Exec("SELECT pubkey, uid, buid, expires_on FROM idty WHERE revocation_sig IS NULL AND hash = '" + e.ref.hash + "'");
							ASSERT(t.res IN {0, 6}, 105);
						UNTIL t.res = 0;
						ASSERT((t.rows = 0) OR (t.rows = 1) & (t.columns = 4), 106);
						IF t.rows = 1 THEN
							NEW(id);
							t.Read(0, curId);
							b := ExtractBlockId(curId.buid, id.bid, h); ASSERT(b, 107);
							REPEAT
								t.Exec("SELECT fork FROM block WHERE hash = '" + h + "'");
								ASSERT(t.res IN {0, 6}, 108);
							UNTIL t.res = 0;
							ASSERT((t.rows = 1) & (t.columns = 1), 109);
							t.Read(0, r);
							IF r.fields[0]$ = "0" THEN
								id.inBC := FALSE;
								id.hash := e.ref.hash;
								id.pubkey := curId.pubkey;
								id.uid := curId.uid;
								id.expires_on := MIN(e.ref.expires_on, curId.expires_on);
								NEW(idH); idH.ref := id; ee := idH;
								b := idHashT.SearchIns(ee, n); ASSERT(~b, 110);
							END;
						END;
					END;
				END;
				e := tr.Next(e);
			END;
			
			A.New(idPubT); A.New(idUidT);
			e := idHashT.Next(NIL);
			WHILE e # NIL DO
				WITH e: IdHashE DO
					NEW(idU); idU.ref := e.ref; ee := idU;
					b := idUidT.SearchIns(ee, n); ASSERT(~b, 111);
					NEW(idP); idP.ref := e.ref; ee := idP;
					b := idPubT.SearchIns(ee, n); ASSERT(~b, 112);
				END;
				e := idHashT.Next(e);
			END;
		END MembershipIds;
	
	(* Builds certFromT and certToT from the Duniter database; remove all certifications where block_hash is in a fork *)
	PROCEDURE Certifications (d: S.Database);
		
		VAR
			
			t: S.Table;
			i, n, bnb: INTEGER;
			curC: CurC;
			c: Certification;
			cF: CertFromE;
			cT: CertToE;
			e, ee: A.Elem;
			b, inBC, member: BOOLEAN;
			uid: String;
			hash: Hash;
			now,
			exp: LONGINT;
			pubkey: Pubkey;
		
		BEGIN (*Certifications*)
			t := d.NewTable(); ASSERT(t # NIL, 100);
			REPEAT
				t.Exec("SELECT [from], [to], target, expires_on FROM cert INNER JOIN block ON cert.block_hash = block.hash WHERE NOT block.fork");
				ASSERT(t.res IN {0, 6}, 101);
			UNTIL t.res = 0;
			ASSERT((t.rows = 0) OR (t.columns = 4), 102);
			now := B.Now();
			A.New(certFromT); A.New(certToT);
			FOR i := 0 TO t.rows - 1 DO
				t.Read(i, curC);
				IF (now <= curC.expires_on) & (IdHash(curC.toHash, inBC, pubkey, uid, exp) OR B.IdPubComplete(curC.to, uid, member, hash, bnb, exp) & (hash = curC.toHash) & member) & (~B.Cert(curC.from, curC.to, bnb, exp) OR (curC.expires_on - B.pars.sigWindow > exp - B.pars.sigValidity + B.pars.sigReplay)) THEN
					NEW(c);
					c.from := curC.from;
					c.to := curC.to;
					c.toHash := curC.toHash;
					c.expires_on := curC.expires_on;
					
					NEW(cF); cF.ref := c; e := cF;
					IF ~certFromT.SearchIns(e, n) THEN
						A.New(e(CertFromE).list);
					END;
					NEW(cT); cT.ref := c; ee := cT;
					b := e(CertFromE).list.SearchIns(ee, n);
					
					NEW(cT); cT.ref := c; e := cT;
					IF ~certToT.SearchIns(e, n) THEN
						A.New(e(CertToE).list);
					END;
					NEW(cF); cF.ref := c; ee := cF;
					b := e(CertToE).list.SearchIns(ee, n);
				END;
			END;
		END Certifications;
	
	(* Scan the sandbox in the Duniter database *)
	PROCEDURE Scan;
		
		VAR
			
			d: S.Database;
			res: INTEGER;
			t: LONGINT;
			s: BA.TimeString;
		
		BEGIN (*Scan*)
			L.log.Msg("Loading sandbox");
			t := Services.Ticks();
			S.OpenDatabase(driver, "", "", B.duniBase, S.sync, S.hideErrors, d, res); ASSERT(res = 0, 100);
			MembershipIds(d);
			Certifications(d);
			BA.TimeToString(Services.Ticks() - t, s);
			L.log.Msg("End loading sandbox. Time spent: " + s);
		END Scan;
	
	PROCEDURE Init;
		
		BEGIN (*Init*)
			B.AddUpdateProc(Scan);
		END Init;
	
	BEGIN (*DuniterSandbox*)
		Init;
	CLOSE
		B.RemoveUpdateProc(Scan);
	END DuniterSandbox.
